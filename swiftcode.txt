################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift
################################################################################
   1 | //
   2 | //  Christmas_GamesUITestsLaunchTests.swift
   3 | //  Christmas GamesUITests
   4 | //
   5 | //  Created by Dean Roger Harmon on 12/16/25.
   6 | //
   7 | 
   8 | import XCTest
   9 | 
  10 | final class Christmas_GamesUITestsLaunchTests: XCTestCase {
  11 | 
  12 |     override class var runsForEachTargetApplicationUIConfiguration: Bool {
  13 |         true
  14 |     }
  15 | 
  16 |     override func setUpWithError() throws {
  17 |         continueAfterFailure = false
  18 |     }
  19 | 
  20 |     @MainActor
  21 |     func testLaunch() throws {
  22 |         let app = XCUIApplication()
  23 |         app.launch()
  24 | 
  25 |         // Insert steps here to perform after app launch but before taking a screenshot,
  26 |         // such as logging into a test account or navigating somewhere in the app
  27 | 
  28 |         let attachment = XCTAttachment(screenshot: app.screenshot())
  29 |         attachment.name = "Launch Screen"
  30 |         attachment.lifetime = .keepAlways
  31 |         add(attachment)
  32 |     }
  33 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift


################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift
################################################################################
   1 | import XCTest
   2 | 
   3 | final class MainMenuUITests: XCTestCase {
   4 |     
   5 |     func testNavigateToGameCatalog() throws {
   6 |         let app = XCUIApplication()
   7 |         app.launch()
   8 |         
   9 |         // Tap Game Catalog button
  10 |         app.buttons["Game Catalog"].tap()
  11 |         
  12 |         // Verify we're on the Game Catalog screen
  13 |         XCTAssertTrue(app.navigationBars["Game Catalog"].exists)
  14 |     }
  15 |     
  16 |     func testCreateNewEvent() throws {
  17 |         let app = XCUIApplication()
  18 |         app.launch()
  19 |         
  20 |         // Navigate to Events
  21 |         let eventsButton = app.buttons["Events"]
  22 |         XCTAssertTrue(eventsButton.exists)
  23 |         eventsButton.tap()
  24 |         
  25 |         // Tap Add Event
  26 |         app.buttons["Add Event"].tap()
  27 |         
  28 |         // Enter event name
  29 |         let eventNameField = app.textFields["Event Name"]
  30 |         eventNameField.tap()
  31 |         eventNameField.typeText("Test Event 2025")
  32 |         
  33 |         // Save
  34 |         app.buttons["Save"].tap()
  35 |         
  36 |         // Verify event appears in list
  37 |         XCTAssertTrue(app.staticTexts["Test Event 2025"].exists)
  38 |     }
  39 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift


################################################################################
START FILE: ./Christmas GamesTests/Christmas_GamesTests.swift
################################################################################
   1 | import XCTest
   2 | import SwiftData
   3 | @testable import Christmas_Games
   4 | 
   5 | final class EventEngineTests: XCTestCase {
   6 |     var context: ModelContext!
   7 |     var engine: EventEngine!
   8 |     
   9 |     @MainActor
  10 |     override func setUp() {
  11 |         super.setUp()
  12 |         // Create in-memory database for testing
  13 |         let config = ModelConfiguration(isStoredInMemoryOnly: true)
  14 |         let container = try! ModelContainer(
  15 |             for: Event.self, Person.self, GameTemplate.self, EventGame.self, Round.self,
  16 |             configurations: config
  17 |         )
  18 |         context = container.mainContext
  19 |         engine = EventEngine(context: context)
  20 |     }
  21 |     
  22 |     @MainActor
  23 |     func testStartEvent_WithNoParticipants_ThrowsError() throws {
  24 |         // Given: an event with no participants
  25 |         let event = Event(name: "Test Event")
  26 |         let template = GameTemplate(
  27 |             externalId: "test",
  28 |             name: "Test Game",
  29 |             defaultTeamCount: 2,
  30 |             defaultPlayersPerTeam: 2,
  31 |             defaultRoundsPerGame: 1,
  32 |             defaultTeamType: .any
  33 |         )
  34 |         context.insert(event)
  35 |         context.insert(template)
  36 |         
  37 |         let eventGame = EventGame(
  38 |             event: event,
  39 |             gameTemplateId: template.id,
  40 |             orderIndex: 0
  41 |         )
  42 |         context.insert(eventGame)
  43 |         event.eventGames.append(eventGame)
  44 |         
  45 |         // When/Then: starting should throw noParticipants error
  46 |         XCTAssertThrowsError(try engine.startEvent(event)) { error in
  47 |             XCTAssertEqual(error as? EventEngine.StartError, .noParticipants)
  48 |         }
  49 |     }
  50 |     
  51 |     @MainActor
  52 |     func testStartEvent_CreatesActiveRound() throws {
  53 |         // Given: an event with participants and a game
  54 |         let event = Event(name: "Test Event")
  55 |         let person1 = Person(displayName: "Test Person 1")
  56 |         let person2 = Person(displayName: "Test Person 2")
  57 |         
  58 |         context.insert(event)
  59 |         context.insert(person1)
  60 |         context.insert(person2)
  61 |         
  62 |         event.participantIds = [person1.id, person2.id]
  63 |         
  64 |         let template = GameTemplate(
  65 |             externalId: "test",
  66 |             name: "Test Game",
  67 |             defaultTeamCount: 2,
  68 |             defaultPlayersPerTeam: 1,
  69 |             defaultRoundsPerGame: 1,
  70 |             defaultTeamType: .any
  71 |         )
  72 |         context.insert(template)
  73 |         
  74 |         let eventGame = EventGame(
  75 |             event: event,
  76 |             gameTemplateId: template.id,
  77 |             orderIndex: 0
  78 |         )
  79 |         context.insert(eventGame)
  80 |         event.eventGames.append(eventGame)
  81 |         
  82 |         // When: starting the event
  83 |         try engine.startEvent(event)
  84 |         
  85 |         // Then: event should be active with a current game and an active round
  86 |         XCTAssertEqual(event.status, .active)
  87 |         XCTAssertNotNil(event.currentEventGameId)
  88 |         XCTAssertEqual(eventGame.status, .inProgress)
  89 |         XCTAssertEqual(eventGame.rounds.count, 1)
  90 |         
  91 |         let round = eventGame.rounds.first!
  92 |         XCTAssertNil(round.completedAt, "Round should not be completed")
  93 |     }
  94 |     
  95 |     @MainActor
  96 |     func testFinalizeRound_AssignsCorrectPlacements() throws {
  97 |         // Given: a round with teams
  98 |         let event = Event(name: "Test Event")
  99 |         let person1 = Person(displayName: "Person 1")
 100 |         let person2 = Person(displayName: "Person 2")
 101 |         
 102 |         context.insert(event)
 103 |         context.insert(person1)
 104 |         context.insert(person2)
 105 |         
 106 |         let template = GameTemplate(
 107 |             externalId: "test",
 108 |             name: "Test Game",
 109 |             defaultTeamCount: 2,
 110 |             defaultPlayersPerTeam: 1,
 111 |             defaultRoundsPerGame: 1,
 112 |             defaultTeamType: .any
 113 |         )
 114 |         context.insert(template)
 115 |         
 116 |         let eventGame = EventGame(
 117 |             event: event,
 118 |             gameTemplateId: template.id,
 119 |             orderIndex: 0
 120 |         )
 121 |         context.insert(eventGame)
 122 |         
 123 |         let round = Round(eventGame: eventGame, roundIndex: 0)
 124 |         context.insert(round)
 125 |         eventGame.rounds.append(round)
 126 |         
 127 |         let team1 = RoundTeam(memberPersonIds: [person1.id])
 128 |         let team2 = RoundTeam(memberPersonIds: [person2.id])
 129 |         round.teams = [team1, team2]
 130 |         
 131 |         // When: finalizing round with team1 as winner
 132 |         try engine.finalizeRound(round, winnerTeamId: team1.id)
 133 |         
 134 |         // Then: placements should be assigned correctly
 135 |         XCTAssertNotNil(round.completedAt)
 136 |         XCTAssertEqual(round.placements[person1.id], 1, "Winner should get 1st place")
 137 |         XCTAssertEqual(round.placements[person2.id], 2, "Loser should get 2nd place")
 138 |     }
 139 |     
 140 |     @MainActor
 141 |     func testResetEvent_ClearsAllGamesAndRounds() throws {
 142 |         // Given: an event with completed games and rounds
 143 |         let event = Event(name: "Test Event", status: .completed)
 144 |         context.insert(event)
 145 |         
 146 |         let template = GameTemplate(
 147 |             externalId: "test",
 148 |             name: "Test Game",
 149 |             defaultTeamCount: 2,
 150 |             defaultPlayersPerTeam: 1,
 151 |             defaultRoundsPerGame: 1,
 152 |             defaultTeamType: .any
 153 |         )
 154 |         context.insert(template)
 155 |         
 156 |         let eventGame = EventGame(
 157 |             event: event,
 158 |             gameTemplateId: template.id,
 159 |             orderIndex: 0,
 160 |             status: .completed
 161 |         )
 162 |         context.insert(eventGame)
 163 |         event.eventGames.append(eventGame)
 164 |         
 165 |         let round = Round(eventGame: eventGame, roundIndex: 0, completedAt: Date())
 166 |         context.insert(round)
 167 |         eventGame.rounds.append(round)
 168 |         
 169 |         // When: resetting the event
 170 |         try engine.resetEvent(event)
 171 |         
 172 |         // Then: event should be reset
 173 |         XCTAssertEqual(event.status, .available)
 174 |         XCTAssertNil(event.currentEventGameId)
 175 |         XCTAssertEqual(eventGame.status, .notStarted)
 176 |         XCTAssertTrue(eventGame.rounds.isEmpty, "All rounds should be deleted")
 177 |     }
 178 | }


END FILE: ./Christmas GamesTests/Christmas_GamesTests.swift


################################################################################
START FILE: ./Christmas Games/RunGameView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct RunGameView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     let event: Event
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var templates: [GameTemplate]
  15 |     
  16 |     @State private var message: String?
  17 |     @State private var showMessage = false
  18 | 
  19 |     @State private var showPickNextGame = false
  20 |     @State private var showResetConfirm = false
  21 | 
  22 | 
  23 |     @State private var showSwap = false
  24 |     @State private var swapOutgoing: UUID?
  25 | 
  26 |     @State private var showAfterRoundDialog = false
  27 |     @State private var isInPostRoundDecision = false
  28 | 
  29 |     @State private var showWinnerPicker = false
  30 |     @State private var showSkipConfirmation = false
  31 |     @State private var showEventStats = false
  32 |     
  33 |     @State private var showTransition = false
  34 |     @State private var pendingNextGame: EventGame?
  35 |     
  36 |     // Winner celebration settings
  37 |     @AppStorage("winnerCelebration_enabled") private var winnerCelebrationEnabled: Bool = true
  38 |     @AppStorage("winnerCelebration_showForMultiRound") private var showCelebrationForMultiRound: Bool = false
  39 |     @AppStorage("winnerCelebration_useGifs") private var winnerCelebrationUseGifs: Bool = true
  40 | 
  41 |     // Winner celebration state
  42 |     @State private var showWinnerCelebrationOverlay = false
  43 |     @State private var celebrationTitle: String = ""
  44 |     @State private var celebrationLines: [String] = []
  45 |     
  46 |     @ViewBuilder
  47 |     private var winnerCelebrationLayer: some View {
  48 |         if showWinnerCelebrationOverlay {
  49 |             WinnerCelebrationOverlay(
  50 |                 title: celebrationTitle,
  51 |                 lines: celebrationLines,
  52 |                 useGifs: winnerCelebrationUseGifs
  53 |             )
  54 |             .transition(.opacity.combined(with: .scale))
  55 |             .zIndex(200)
  56 |         }
  57 |     }
  58 | 
  59 |     
  60 |     
  61 |     var body: some View {
  62 |         ZStack {
  63 |             themeManager.background
  64 |                 .ignoresSafeArea()
  65 | 
  66 |             VStack(spacing: 12) {
  67 |                 content
  68 |                 Spacer()
  69 |             }
  70 |             .padding()
  71 | 
  72 |             if event.status == .paused {
  73 |                 pausedOverlay
  74 |             }
  75 |             
  76 |             if showTransition {
  77 |                 GameTransitionView {
  78 |                     completeTransition()
  79 |                 }
  80 |                 .transition(.opacity)
  81 |                 .zIndex(100)
  82 |             }
  83 |         }
  84 |         .navigationTitle("Run Game")
  85 |         .toolbarBackground(.hidden, for: .navigationBar)
  86 |         .toolbar {
  87 |             ToolbarItem(placement: .topBarLeading) {
  88 |                 Menu {
  89 |                     Button {
  90 |                         showEventStats = true
  91 |                     } label: {
  92 |                         Label("View Stats", systemImage: "chart.bar.fill")
  93 |                     }
  94 |                 } label: {
  95 |                     Text("Event")
  96 |                         .foregroundColor(themeManager.text)
  97 |                 }
  98 |             }
  99 |             
 100 |             ToolbarItemGroup(placement: .topBarTrailing) {
 101 |                 // Pause/Resume button
 102 |                 if event.status == .active {
 103 |                     Button("Pause") {
 104 |                         do { try engine.pauseEvent(event) }
 105 |                         catch { show(error) }
 106 |                     }
 107 |                     .foregroundColor(themeManager.text)
 108 |                 } else if event.status == .paused {
 109 |                     Button("Resume") {
 110 |                         do { try engine.resumeEvent(event) }
 111 |                         catch { show(error) }
 112 |                     }
 113 |                     .foregroundColor(themeManager.text)
 114 |                 }
 115 |                 
 116 |                 // Skip Game button (only when game is active and not paused)
 117 |                 if currentGame != nil && event.status == .active {
 118 |                     Button("Skip Game") { showSkipConfirmation = true }
 119 |                         .foregroundColor(themeManager.text)
 120 |                 }
 121 |                 
 122 |                 // Pick Game button
 123 |                 Button("Pick Game") { showPickNextGame = true }
 124 |                     .foregroundColor(themeManager.text)
 125 |                     .disabled(event.status == .paused)
 126 |             }
 127 |         }
 128 |         .sheet(isPresented: $showPickNextGame) {
 129 |             PickNextGameSheet(event: event) { selection, skipMode in
 130 |                 handlePick(selection: selection, skipMode: skipMode)
 131 |             }
 132 |             .environmentObject(themeManager)
 133 |         }
 134 |         .sheet(isPresented: $showEventStats) {
 135 |             CurrentEventStatsSheet(event: event)
 136 |                 .environmentObject(themeManager)
 137 |                 .onDisappear {
 138 |                     // Reshow dialog if we were in post-round decision mode
 139 |                     if isInPostRoundDecision {
 140 |                         DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
 141 |                             showAfterRoundDialog = true
 142 |                         }
 143 |                     }
 144 |                 }
 145 |         }
 146 |         .confirmationDialog("What would you like to do next?", isPresented: $showAfterRoundDialog, titleVisibility: .visible) {
 147 |             if let eg = currentGame {
 148 |                 Button("Play Another Round") {
 149 |                     do { 
 150 |                         _ = try engine.createNextRound(for: eg)
 151 |                         isInPostRoundDecision = false
 152 |                         showAfterRoundDialog = false
 153 |                     } catch { 
 154 |                         show(error) 
 155 |                     }
 156 |                 }
 157 |                 
 158 |                 Button("Continue to Next Game") {
 159 |                     isInPostRoundDecision = false
 160 |                     showAfterRoundDialog = false
 161 |                     handlePickNextGameRandom(currentGame: eg)
 162 |                 }
 163 |                 
 164 |                 Button("Manually Choose Next Game") {
 165 |                     isInPostRoundDecision = false
 166 |                     showAfterRoundDialog = false
 167 |                     showPickNextGame = true
 168 |                 }
 169 |                 
 170 |                 Button("View Event Stats") {
 171 |                     showEventStats = true
 172 |                     // Don't clear isInPostRoundDecision - we want to come back
 173 |                 }
 174 |             }
 175 |         }
 176 |         .alert("Message", isPresented: $showMessage) {
 177 |             Button("OK", role: .cancel) { }
 178 |         } message: {
 179 |             Text(message ?? "Unknown error")
 180 |         }
 181 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
 182 |             Button("Reset Event", role: .destructive) {
 183 |                 do {
 184 |                     try EventEngine(context: context).resetEvent(event)
 185 |                 } catch {
 186 |                     show(error)
 187 |                 }
 188 |             }
 189 |             Button("Cancel", role: .cancel) { }
 190 |         } message: {
 191 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 192 |         }
 193 |         .confirmationDialog("Skip Current Game", isPresented: $showSkipConfirmation, titleVisibility: .visible) {
 194 |             Button("Skip to Next Game", role: .destructive) {
 195 |                 handleSkipGame()
 196 |             }
 197 |             Button("Cancel", role: .cancel) { }
 198 |         } message: {
 199 |             Text("This will skip the current game and move to the next available game. Current players will be carried over if possible.")
 200 |         }
 201 |     }
 202 | 
 203 |     private var pausedOverlay: some View {
 204 |         ZStack {
 205 |             Color.black.opacity(0.7)
 206 |                 .ignoresSafeArea()
 207 |             
 208 |             VStack(spacing: 20) {
 209 |                 Image(systemName: "pause.circle.fill")
 210 |                     .font(.system(size: 80))
 211 |                     .foregroundStyle(.white)
 212 |                 
 213 |                 Text("Event Paused")
 214 |                     .font(.title)
 215 |                     .fontWeight(.bold)
 216 |                     .foregroundStyle(.white)
 217 |                 
 218 |                 Button("Resume") {
 219 |                     do { try engine.resumeEvent(event) }
 220 |                     catch { show(error) }
 221 |                 }
 222 |                 .buttonStyle(.borderedProminent)
 223 |                 .controlSize(.large)
 224 |             }
 225 |         }
 226 |     }
 227 | 
 228 |     private var engine: EventEngine { EventEngine(context: context) }
 229 | 
 230 |     private var peopleById: [UUID: Person] {
 231 |         Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 232 |     }
 233 | 
 234 |     private var currentGame: EventGame? {
 235 |         guard let id = event.currentEventGameId else { return nil }
 236 |         return event.eventGames.first(where: { $0.id == id })
 237 |     }
 238 | 
 239 |     private var currentTemplate: GameTemplate? {
 240 |         guard let eg = currentGame else { return nil }
 241 |         return templates.first(where: { $0.id == eg.gameTemplateId })
 242 |     }
 243 | 
 244 |     private var currentRound: Round? {
 245 |         guard let eg = currentGame else { return nil }
 246 |         return eg.rounds
 247 |             .sorted(by: { $0.roundIndex > $1.roundIndex })
 248 |             .first(where: { $0.completedAt == nil })
 249 |     }
 250 | 
 251 |     private func teamLabel(_ index: Int) -> String {
 252 |         let scalar = UnicodeScalar(65 + index)!
 253 |         return String(Character(scalar))
 254 |     }
 255 | 
 256 |     private func teamNames(_ team: RoundTeam) -> String {
 257 |         team.memberPersonIds
 258 |             .compactMap { peopleById[$0]?.displayName }
 259 |             .joined(separator: ", ")
 260 |     }
 261 | 
 262 |     @ViewBuilder
 263 |     private var content: some View {
 264 |         if let eg = currentGame, let template = currentTemplate {
 265 |             header(template: template, eventGame: eg)
 266 |             if let round = currentRound {
 267 |                 roundCard(template: template, eventGame: eg, round: round)
 268 |             } else {
 269 |                 // No active round - either all rounds complete or none created yet
 270 |                 VStack(spacing: 16) {
 271 |                     if eg.rounds.isEmpty {
 272 |                         Text("No rounds created yet.")
 273 |                             .foregroundStyle(.secondary)
 274 |                         
 275 |                         Button("Start First Round") {
 276 |                             do {
 277 |                                 _ = try engine.createNextRound(for: eg)
 278 |                             } catch {
 279 |                                 show(error)
 280 |                             }
 281 |                         }
 282 |                         .buttonStyle(.borderedProminent)
 283 |                         .disabled(event.status == .paused)
 284 |                     } else {
 285 |                         // All rounds are complete - ready for next game
 286 |                         Text("All rounds complete!")
 287 |                             .font(.title3)
 288 |                             .foregroundStyle(.secondary)
 289 |                         
 290 |                         Button("Choose Next Game") {
 291 |                             showPickNextGame = true
 292 |                         }
 293 |                         .buttonStyle(.borderedProminent)
 294 |                         .disabled(event.status == .paused)
 295 |                     }
 296 |                 }
 297 |                 .padding()
 298 |             }
 299 |         } else {
 300 |             emptyState
 301 |         }
 302 |     }
 303 | 
 304 |     private var emptyState: some View {
 305 |         VStack(spacing: 12) {
 306 |             Text("No game is currently running.")
 307 |                 .foregroundStyle(.secondary)
 308 | 
 309 |             Button("Start Event") {
 310 |                 do { try engine.startEvent(event) }
 311 |                 catch { show(error) }
 312 |             }
 313 |             .buttonStyle(.borderedProminent)
 314 |             .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty || event.status == .paused)
 315 |         }
 316 |     }
 317 | 
 318 |     private func header(template: GameTemplate, eventGame: EventGame) -> some View {
 319 |         VStack(alignment: .leading, spacing: 8) {
 320 |             Text(template.name).font(.title2).bold()
 321 | 
 322 |             if let playInstructions = (eventGame.overridePlayInstructions ?? template.playInstructions),
 323 |                !playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
 324 |                 Text(playInstructions)
 325 |                     .foregroundStyle(.secondary)
 326 |             }
 327 | 
 328 |             HStack {
 329 |                 Text("Status: \(eventGame.statusRaw.capitalized)")
 330 |                     .foregroundStyle(.secondary)
 331 |                 Spacer()
 332 |                 Text("Players: \(event.participantIds.count)")
 333 |                     .foregroundStyle(.secondary)
 334 |             }
 335 |         }
 336 |     }
 337 | 
 338 |     private func roundCard(template: GameTemplate, eventGame: EventGame, round: Round) -> some View {
 339 |         VStack(alignment: .leading, spacing: 12) {
 340 |             HStack {
 341 |                 Text("Round \(round.roundIndex + 1)").font(.headline)
 342 |                 Spacer()
 343 |                 if round.isLocked { Text("Locked").foregroundStyle(.secondary) }
 344 |             }
 345 | 
 346 |             if round.teams.isEmpty {
 347 |                 Button("Generate Teams") {
 348 |                     do { try engine.generateTeams(for: round) }
 349 |                     catch { show(error) }
 350 |                 }
 351 |                 .buttonStyle(.borderedProminent)
 352 |                 .disabled(event.status == .paused)
 353 |             } else {
 354 |                 teamsList(round: round)
 355 | 
 356 |                 if !round.isLocked {
 357 |                     actionRowUnlocked(round: round)
 358 |                 } else {
 359 |                     Button("Continue") { showAfterRoundDialog = true }
 360 |                         .buttonStyle(.borderedProminent)
 361 |                         .disabled(event.status == .paused)
 362 |                 }
 363 | 
 364 |                 previousRoundsCompact(eventGame: eventGame)
 365 |             }
 366 |         }
 367 |         .sheet(isPresented: $showSwap) {
 368 |             SwapPlayerSheet(
 369 |                 event: event,
 370 |                 currentRound: round,
 371 |                 people: people,
 372 |                 outgoing: swapOutgoing
 373 |             ) { incoming in
 374 |                 do {
 375 |                     if let out = swapOutgoing {
 376 |                         try engine.swapPlayer(in: round, from: out, to: incoming)
 377 |                     }
 378 |                 } catch { show(error) }
 379 |             }
 380 |             .environmentObject(themeManager)
 381 |         }
 382 |     }
 383 | 
 384 |     private func teamsList(round: Round) -> some View {
 385 |         VStack(alignment: .leading, spacing: 10) {
 386 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, team in
 387 |                 VStack(alignment: .leading, spacing: 6) {
 388 |                     Text("Team \(teamLabel(index))")
 389 |                         .font(.subheadline)
 390 |                         .bold()
 391 |                         .foregroundColor(teamColor(for: index))
 392 | 
 393 |                     ForEach(team.memberPersonIds, id: \.self) { pid in
 394 |                         HStack {
 395 |                             Text(peopleById[pid]?.displayName ?? "Unknown")
 396 |                             Spacer()
 397 |                             if !round.isLocked && event.status != .paused {
 398 |                                 Button("Swap") {
 399 |                                     swapOutgoing = pid
 400 |                                     showSwap = true
 401 |                                 }
 402 |                                 .buttonStyle(.bordered)
 403 |                             }
 404 |                         }
 405 |                     }
 406 |                 }
 407 |                 .padding(.vertical, 6)
 408 |             }
 409 |         }
 410 |     }
 411 |     
 412 |     private func teamColor(for index: Int) -> Color {
 413 |         let colors: [Color] = [.red, .green, .yellow, .blue, .orange, .purple]
 414 |         return index < colors.count ? colors[index] : .primary
 415 |     }
 416 | 
 417 |     private func actionRowUnlocked(round: Round) -> some View {
 418 |         HStack {
 419 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, t in
 420 |                 Button("Team \(teamLabel(index))") {
 421 |                     do {
 422 |                         try engine.finalizeRound(round, winnerTeamId: t.id)
 423 |                         handleRoundFinalized(round: round, winnerTeamId: t.id)
 424 |                     } catch {
 425 |                         show(error)
 426 |                     }
 427 |                 }
 428 |                 .buttonStyle(.borderedProminent)
 429 |             }
 430 | 
 431 |             Button("Tie") {
 432 |                 do {
 433 |                     try engine.finalizeRound(round, winnerTeamId: nil)
 434 |                     handleRoundFinalized(round: round, winnerTeamId: nil)
 435 |                 } catch {
 436 |                     show(error)
 437 |                 }
 438 |             }
 439 |             .buttonStyle(.bordered)
 440 |         }
 441 |     }
 442 | 
 443 | 
 444 |     private func previousRoundsCompact(eventGame: EventGame) -> some View {
 445 |         let completed = eventGame.rounds
 446 |             .sorted { $0.roundIndex > $1.roundIndex }
 447 |             .filter { $0.completedAt != nil }
 448 | 
 449 |         return Group {
 450 |             if !completed.isEmpty {
 451 |                 Divider()
 452 |                 Text("Previous Rounds").font(.subheadline).bold()
 453 |                 ForEach(completed.prefix(3)) { r in
 454 |                     Text(historyLine(r))
 455 |                         .font(.footnote)
 456 |                         .foregroundStyle(.secondary)
 457 |                 }
 458 |             }
 459 |         }
 460 |     }
 461 | 
 462 |     private func historyLine(_ round: Round) -> String {
 463 |         if round.resultType == .tie {
 464 |             return "Round \(round.roundIndex + 1): Tie"
 465 |         }
 466 |         if let winTeam = round.winningTeamId,
 467 |            let team = round.teams.first(where: { $0.id == winTeam }) {
 468 |             let names = team.memberPersonIds
 469 |                 .compactMap { peopleById[$0]?.displayName }
 470 |                 .joined(separator: ", ")
 471 |             return "Round \(round.roundIndex + 1): Winner – \(names)"
 472 |         }
 473 |         return "Round \(round.roundIndex + 1): Completed"
 474 |     }
 475 | 
 476 |     private func handleRoundFinalized(round: Round, winnerTeamId: UUID?) {
 477 |         let shouldCelebrate = shouldShowWinnerCelebration(for: round)
 478 | 
 479 |         if winnerCelebrationEnabled && shouldCelebrate {
 480 |             buildCelebrationPayload(round: round, winnerTeamId: winnerTeamId)
 481 | 
 482 |             withAnimation(.spring(response: 0.35, dampingFraction: 0.8)) {
 483 |                 showWinnerCelebrationOverlay = true
 484 |             }
 485 | 
 486 |             // Dismiss after a short beat, THEN show the post-round dialog
 487 |             DispatchQueue.main.asyncAfter(deadline: .now() + 1.2) {
 488 |                 withAnimation(.easeOut(duration: 0.2)) {
 489 |                     showWinnerCelebrationOverlay = false
 490 |                 }
 491 | 
 492 |                 // Now go to the menu (DO NOT call handleRoundFinalized again)
 493 |                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
 494 |                     isInPostRoundDecision = true
 495 |                     showAfterRoundDialog = true
 496 |                 }
 497 |             }
 498 |         } else {
 499 |             // No celebration -> go straight to the menu
 500 |             isInPostRoundDecision = true
 501 |             showAfterRoundDialog = true
 502 |         }
 503 |     }
 504 | 
 505 | 
 506 |     private func shouldShowWinnerCelebration(for round: Round) -> Bool {
 507 |         // If you later add "roundsPerGame" to templates, this can be more intelligent.
 508 |         // For now: treat "multi-round" as "this game already has completed rounds."
 509 |         // i.e., if there were previous completed rounds, default to NOT celebrating unless user enables it.
 510 |         guard let eg = round.eventGame else { return true }
 511 |         let completedRoundCount = eg.rounds.filter { $0.completedAt != nil }.count
 512 | 
 513 |         if completedRoundCount > 1 { // means we are in a game that has been played across multiple rounds
 514 |             return showCelebrationForMultiRound
 515 |         }
 516 |         return true
 517 |     }
 518 | 
 519 |     private func buildCelebrationPayload(round: Round, winnerTeamId: UUID?) {
 520 |         if round.resultType == .tie || winnerTeamId == nil {
 521 |             celebrationTitle = "It’s a Tie!"
 522 |             celebrationLines = ["Everyone takes 1st place"]
 523 |             return
 524 |         }
 525 | 
 526 |         // Build 1st/2nd place lines using round.placements computed by EventEngine.finalizeRound
 527 |         // placements: [personId: placementInt]
 528 |         let placements = round.placements
 529 | 
 530 |         let first = placements
 531 |             .filter { $0.value == 1 }
 532 |             .compactMap { peopleById[$0.key]?.displayName }
 533 |             .sorted()
 534 | 
 535 |         let second = placements
 536 |             .filter { $0.value == 2 }
 537 |             .compactMap { peopleById[$0.key]?.displayName }
 538 |             .sorted()
 539 | 
 540 |         celebrationTitle = "Congratulations!"
 541 |         var lines: [String] = []
 542 | 
 543 |         if !first.isEmpty {
 544 |             lines.append("1st Place: " + first.joined(separator: ", "))
 545 |         }
 546 |         if !second.isEmpty {
 547 |             lines.append("2nd Place: " + second.joined(separator: ", "))
 548 |         }
 549 | 
 550 |         if lines.isEmpty {
 551 |             lines = ["Winners recorded"]
 552 |         }
 553 | 
 554 |         celebrationLines = lines
 555 |     }
 556 | 
 557 |     
 558 |     private func handlePickNextGameRandom(currentGame: EventGame) {
 559 |         do {
 560 |             try engine.completeGame(currentGame)
 561 |             
 562 |             if let next = try engine.pickNextGameRandom(event: event) {
 563 |                 // Store the next game and show transition
 564 |                 pendingNextGame = next
 565 |                 withAnimation {
 566 |                     showTransition = true
 567 |                 }
 568 |             } else {
 569 |                 event.status = .completed
 570 |                 try context.save()
 571 |             }
 572 |         } catch {
 573 |             show(error)
 574 |         }
 575 |     }
 576 | 
 577 |     private func handlePick(selection: EventGame, skipMode: PickNextGameSheet.SkipMode?) {
 578 |         do {
 579 |             if let skipMode {
 580 |                 if skipMode == .pushLater { try engine.pushGameToLater(selection) }
 581 |                 if skipMode == .remove { try engine.removeGameFromEvent(selection) }
 582 |                 return
 583 |             }
 584 | 
 585 |             // Complete current game if there is one
 586 |             if let cg = currentGame { 
 587 |                 try engine.completeGame(cg) 
 588 |             }
 589 |             
 590 |             // Store the next game and show transition
 591 |             pendingNextGame = selection
 592 |             withAnimation {
 593 |                 showTransition = true
 594 |             }
 595 |         } catch {
 596 |             show(error)
 597 |         }
 598 |     }
 599 |     
 600 |     private func completeTransition() {
 601 |         do {
 602 |             // Start the pending game
 603 |             if let nextGame = pendingNextGame {
 604 |                 try engine.start(event: event, eventGame: nextGame)
 605 |                 try context.save()
 606 |             }
 607 |             
 608 |             // Hide transition
 609 |             withAnimation {
 610 |                 showTransition = false
 611 |             }
 612 |             pendingNextGame = nil
 613 |         } catch {
 614 |             show(error)
 615 |             withAnimation {
 616 |                 showTransition = false
 617 |             }
 618 |             pendingNextGame = nil
 619 |         }
 620 |     }
 621 | 
 622 |     private func handleSkipGame() {
 623 |         guard let game = currentGame else { return }
 624 |         
 625 |         // Get current player IDs
 626 |         let playerIds: [UUID]
 627 |         if let round = currentRound, !round.teams.isEmpty {
 628 |             playerIds = round.teams.flatMap { $0.memberPersonIds }
 629 |         } else {
 630 |             playerIds = []
 631 |         }
 632 |         
 633 |         do {
 634 |             try engine.skipToNextGame(game, keepingPlayers: playerIds)
 635 |             
 636 |             // Force view refresh
 637 |             try context.save()
 638 |         } catch {
 639 |             show(error)
 640 |         }
 641 |     }
 642 | 
 643 |     private func show(_ error: Error) {
 644 |         message = error.localizedDescription
 645 |         showMessage = true
 646 |     }
 647 | }
 648 | 
 649 | // MARK: - Pick Next Game
 650 | 
 651 | struct PickNextGameSheet: View {
 652 |     enum SkipMode { case pushLater, remove }
 653 | 
 654 |     @Environment(\.dismiss) private var dismiss
 655 | 
 656 |     let event: Event
 657 |     let onPick: (EventGame, SkipMode?) -> Void
 658 | 
 659 |     @Query(sort: \GameTemplate.name)
 660 |     private var templates: [GameTemplate]
 661 |     
 662 |     // Filter and sort state
 663 |     @State private var searchText = ""
 664 |     @AppStorage("pickNextGame_filterTeamSize") private var filterTeamSize: Int?
 665 |     @AppStorage("pickNextGame_filterTeamCount") private var filterTeamCount: Int?
 666 |     @AppStorage("pickNextGame_sortOption") private var sortOption: SortOption = .orderIndex
 667 |     @AppStorage("pickNextGame_teamTypeFilter") private var teamTypeFilter: TeamTypeFilter = .all
 668 |     @AppStorage("pickNextGame_statusFilter") private var statusFilter: StatusFilter = .active
 669 |     
 670 |     enum SortOption: String, CaseIterable, Codable {
 671 |         case orderIndex = "Order"
 672 |         case alphabetical = "A-Z"
 673 |         case reverseAlphabetical = "Z-A"
 674 |     }
 675 |     
 676 |     enum TeamTypeFilter: String, CaseIterable, Codable {
 677 |         case all = "All"
 678 |         case any = "Any"
 679 |         case maleOnly = "Male Only"
 680 |         case femaleOnly = "Female Only"
 681 |         case couplesOnly = "Couples Only"
 682 |     }
 683 |     
 684 |     enum StatusFilter: String, CaseIterable, Codable {
 685 |         case active = "Active"
 686 |         case notStarted = "Not Started"
 687 |         case allGames = "All Games"
 688 |     }
 689 | 
 690 |     var body: some View {
 691 |         NavigationStack {
 692 |             List {
 693 |                 // Filters section
 694 |                 Section {
 695 |                     // Search bar
 696 |                     HStack {
 697 |                         Image(systemName: "magnifyingglass")
 698 |                             .foregroundStyle(.secondary)
 699 |                         TextField("Search games...", text: $searchText)
 700 |                             .textFieldStyle(.plain)
 701 |                         if !searchText.isEmpty {
 702 |                             Button {
 703 |                                 searchText = ""
 704 |                             } label: {
 705 |                                 Image(systemName: "xmark.circle.fill")
 706 |                                     .foregroundStyle(.secondary)
 707 |                             }
 708 |                         }
 709 |                     }
 710 |                     .padding(.vertical, 4)
 711 |                     
 712 |                     HStack {
 713 |                         Picker("Team Size", selection: $filterTeamSize) {
 714 |                             Text("Any").tag(nil as Int?)
 715 |                             ForEach(availableTeamSizes, id: \.self) { size in
 716 |                                 Text("\(size)").tag(size as Int?)
 717 |                             }
 718 |                         }
 719 |                         .pickerStyle(.menu)
 720 |                         
 721 |                         Picker("Teams", selection: $filterTeamCount) {
 722 |                             Text("Any").tag(nil as Int?)
 723 |                             ForEach(availableTeamCounts, id: \.self) { count in
 724 |                                 Text("\(count)").tag(count as Int?)
 725 |                             }
 726 |                         }
 727 |                         .pickerStyle(.menu)
 728 |                     }
 729 |                     
 730 |                     HStack {
 731 |                         Picker("Sort", selection: $sortOption) {
 732 |                             ForEach(SortOption.allCases, id: \.self) { option in
 733 |                                 Text(option.rawValue).tag(option)
 734 |                             }
 735 |                         }
 736 |                         .pickerStyle(.menu)
 737 |                         
 738 |                         Picker("Team Type", selection: $teamTypeFilter) {
 739 |                             ForEach(TeamTypeFilter.allCases, id: \.self) { filter in
 740 |                                 Text(filter.rawValue).tag(filter)
 741 |                             }
 742 |                         }
 743 |                         .pickerStyle(.menu)
 744 |                     }
 745 |                     
 746 |                     Picker("Status", selection: $statusFilter) {
 747 |                         ForEach(StatusFilter.allCases, id: \.self) { filter in
 748 |                             Text(filter.rawValue).tag(filter)
 749 |                         }
 750 |                     }
 751 |                     .pickerStyle(.segmented)
 752 |                 } header: {
 753 |                     Text("\(statusFilter.rawValue) Games (\(filteredAndSortedGames.count))")
 754 |                 }
 755 |                 
 756 |                 // Eligible games list
 757 |                 Section("Select Game") {
 758 |                     ForEach(filteredAndSortedGames) { eg in
 759 |                         Button {
 760 |                             onPick(eg, nil)
 761 |                             dismiss()
 762 |                         } label: {
 763 |                             gameRow(for: eg)
 764 |                         }
 765 |                     }
 766 |                 }
 767 | 
 768 |                 // Skip options
 769 |                 if !filteredAndSortedGames.isEmpty {
 770 |                     Section("Skip Options") {
 771 |                         ForEach(filteredAndSortedGames) { eg in
 772 |                             Menu {
 773 |                                 Button("Push to later") {
 774 |                                     onPick(eg, .pushLater)
 775 |                                     dismiss()
 776 |                                 }
 777 |                                 Button("Remove from event", role: .destructive) {
 778 |                                     onPick(eg, .remove)
 779 |                                     dismiss()
 780 |                                 }
 781 |                             } label: {
 782 |                                 Text("Skip \(gameName(for: eg))")
 783 |                             }
 784 |                         }
 785 |                     }
 786 |                 }
 787 |             }
 788 |             .navigationTitle("Choose Next Game")
 789 |             .toolbar {
 790 |                 ToolbarItem(placement: .topBarLeading) {
 791 |                     Button("Close") { dismiss() }
 792 |                 }
 793 |             }
 794 |         }
 795 |     }
 796 |     
 797 |     // MARK: - Computed Properties
 798 |     
 799 |     private var availableTeamSizes: [Int] {
 800 |         let sizes = eligibleGames.compactMap { eg -> Int? in
 801 |             let t = template(for: eg)
 802 |             return eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam
 803 |         }
 804 |         return Array(Set(sizes)).sorted()
 805 |     }
 806 |     
 807 |     private var availableTeamCounts: [Int] {
 808 |         let counts = eligibleGames.compactMap { eg -> Int? in
 809 |             let t = template(for: eg)
 810 |             return eg.overrideTeamCount ?? t?.defaultTeamCount
 811 |         }
 812 |         return Array(Set(counts)).sorted()
 813 |     }
 814 | 
 815 |     private var eligibleGames: [EventGame] {
 816 |         let games = event.eventGames
 817 |         
 818 |         switch statusFilter {
 819 |         case .notStarted:
 820 |             // Only show games that haven't been touched
 821 |             return games.filter { $0.status == .notStarted }
 822 |             
 823 |         case .active:
 824 |             // Show games that haven't had a winner recorded yet
 825 |             return games.filter { eg in
 826 |                 // Include not started games
 827 |                 if eg.status == .notStarted {
 828 |                     return true
 829 |                 }
 830 |                 
 831 |                 // Include in-progress games that don't have a completed round with a winner
 832 |                 if eg.status == .inProgress {
 833 |                     let hasCompletedRoundWithWinner = eg.rounds.contains { round in
 834 |                         round.completedAt != nil && 
 835 |                         (round.winningTeamId != nil || round.resultType == .tie)
 836 |                     }
 837 |                     return !hasCompletedRoundWithWinner
 838 |                 }
 839 |                 
 840 |                 return false
 841 |             }
 842 |             
 843 |         case .allGames:
 844 |             // Show everything
 845 |             return games
 846 |         }
 847 |     }
 848 |     
 849 |     private var filteredAndSortedGames: [EventGame] {
 850 |         var result = eligibleGames
 851 |         
 852 |         // Apply search filter
 853 |         if !searchText.isEmpty {
 854 |             result = result.filter { eg in
 855 |                 let t = template(for: eg)
 856 |                 let name = t?.name ?? ""
 857 |                 let group = t?.groupName ?? ""
 858 |                 return name.localizedCaseInsensitiveContains(searchText) ||
 859 |                        group.localizedCaseInsensitiveContains(searchText)
 860 |             }
 861 |         }
 862 |         
 863 |         // Apply team size filter
 864 |         if let filterTeamSize {
 865 |             result = result.filter { eg in
 866 |                 let t = template(for: eg)
 867 |                 let size = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 0
 868 |                 return size == filterTeamSize
 869 |             }
 870 |         }
 871 |         
 872 |         // Apply team count filter
 873 |         if let filterTeamCount {
 874 |             result = result.filter { eg in
 875 |                 let t = template(for: eg)
 876 |                 let count = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 0
 877 |                 return count == filterTeamCount
 878 |             }
 879 |         }
 880 |         
 881 |         // Apply team type filter
 882 |         if teamTypeFilter != .all {
 883 |             result = result.filter { eg in
 884 |                 let t = template(for: eg)
 885 |                 let teamType = eg.overrideTeamType ?? t?.defaultTeamType ?? .any
 886 |                 
 887 |                 switch teamTypeFilter {
 888 |                 case .all:
 889 |                     return true
 890 |                 case .any:
 891 |                     return teamType == .any
 892 |                 case .maleOnly:
 893 |                     return teamType == .maleOnly
 894 |                 case .femaleOnly:
 895 |                     return teamType == .femaleOnly
 896 |                 case .couplesOnly:
 897 |                     return teamType == .couplesOnly
 898 |                 }
 899 |             }
 900 |         }
 901 |         
 902 |         // Apply sort
 903 |         switch sortOption {
 904 |         case .orderIndex:
 905 |             result.sort { $0.orderIndex < $1.orderIndex }
 906 |         case .alphabetical:
 907 |             result.sort { eg1, eg2 in
 908 |                 let n1 = gameName(for: eg1)
 909 |                 let n2 = gameName(for: eg2)
 910 |                 return n1.localizedCaseInsensitiveCompare(n2) == .orderedAscending
 911 |             }
 912 |         case .reverseAlphabetical:
 913 |             result.sort { eg1, eg2 in
 914 |                 let n1 = gameName(for: eg1)
 915 |                 let n2 = gameName(for: eg2)
 916 |                 return n1.localizedCaseInsensitiveCompare(n2) == .orderedDescending
 917 |             }
 918 |         }
 919 |         
 920 |         return result
 921 |     }
 922 | 
 923 |     private func template(for eg: EventGame) -> GameTemplate? {
 924 |         templates.first(where: { $0.id == eg.gameTemplateId })
 925 |     }
 926 | 
 927 |     private func gameName(for eg: EventGame) -> String {
 928 |         template(for: eg)?.name ?? "Unknown Game"
 929 |     }
 930 | 
 931 |     private func gameRow(for eg: EventGame) -> some View {
 932 |         let t = template(for: eg)
 933 | 
 934 |         let name = t?.name ?? "Unknown Game"
 935 |         let group = t?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 936 |         let groupText = (group?.isEmpty == false) ? group! : nil
 937 | 
 938 |         let teamCount = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 939 |         let playersPerTeam = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 940 | 
 941 |         let teamSizeText = "Teams: \(teamCount) × \(playersPerTeam)"
 942 |         let subtitle = groupText != nil ? "\(groupText!) • \(teamSizeText)" : teamSizeText
 943 | 
 944 |         return VStack(alignment: .leading, spacing: 3) {
 945 |             Text(name)
 946 |                 .font(.body)
 947 | 
 948 |             Text(subtitle)
 949 |                 .font(.footnote)
 950 |                 .foregroundStyle(.secondary)
 951 |         }
 952 |     }
 953 | }
 954 | 
 955 | // MARK: - Swap Player
 956 | 
 957 | struct SwapPlayerSheet: View {
 958 |     @Environment(\.dismiss) private var dismiss
 959 | 
 960 |     let event: Event
 961 |     let currentRound: Round
 962 |     let people: [Person]
 963 |     let outgoing: UUID?
 964 | 
 965 |     let onSwap: (UUID) -> Void
 966 | 
 967 |     var body: some View {
 968 |         let inRound = Set(currentRound.teams.flatMap { $0.memberPersonIds })
 969 |         let bench = people.filter { event.participantIds.contains($0.id) && !inRound.contains($0.id) && $0.isActive }
 970 | 
 971 |         NavigationStack {
 972 |             List {
 973 |                 Section {
 974 |                     Text("Outgoing: \(name(outgoing))")
 975 |                         .foregroundStyle(.secondary)
 976 |                 }
 977 | 
 978 |                 Section("Choose replacement") {
 979 |                     ForEach(bench) { p in
 980 |                         Button(p.displayName) {
 981 |                             onSwap(p.id)
 982 |                             dismiss()
 983 |                         }
 984 |                     }
 985 |                 }
 986 |             }
 987 |             .navigationTitle("Swap Player")
 988 |             .toolbar {
 989 |                 ToolbarItem(placement: .topBarLeading) {
 990 |                     Button("Cancel") { dismiss() }
 991 |                 }
 992 |             }
 993 |         }
 994 |     }
 995 | 
 996 |     private func name(_ id: UUID?) -> String {
 997 |         guard let id else { return "None" }
 998 |         return people.first(where: { $0.id == id })?.displayName ?? "Unknown"
 999 |     }
1000 | }
1001 | 
1002 | #Preview {
1003 |     let config = ModelConfiguration(isStoredInMemoryOnly: true)
1004 |     let container = try! ModelContainer(for: Event.self, Person.self, GameTemplate.self, configurations: config)
1005 |     
1006 |     let event = Event(name: "Test Event")
1007 |     container.mainContext.insert(event)
1008 |     
1009 |     return NavigationStack {
1010 |         RunGameView(event: event)
1011 |     }
1012 |     .modelContainer(container)
1013 |     .environmentObject(ThemeManager())
1014 | }


END FILE: ./Christmas Games/RunGameView.swift


################################################################################
START FILE: ./Christmas Games/CreatePersonSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreatePersonSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var allPeople: [Person]
  10 | 
  11 |     @State private var displayName = ""
  12 |     @State private var sex = "M"
  13 |     @State private var weightCategory = "M"
  14 |     @State private var heightCategory = "M"
  15 |     @State private var spouseId: UUID?
  16 |     @State private var isActive = true
  17 | 
  18 |     var body: some View {
  19 |         NavigationStack {
  20 |             Form {
  21 |                 Section("Basic") {
  22 |                     TextField("Name", text: $displayName)
  23 |                 }
  24 | 
  25 |                 Section("Details") {
  26 |                     HStack {
  27 |                         Text("Gender:")
  28 |                         Spacer()
  29 |                         Picker("Gender", selection: $sex) {
  30 |                             Text("M").tag("M")
  31 |                             Text("F").tag("F")
  32 |                         }
  33 |                         .pickerStyle(.segmented)
  34 |                         .labelsHidden()
  35 |                         .frame(width: 120)
  36 |                     }
  37 | 
  38 |                     HStack {
  39 |                         Text("Weight:")
  40 |                         Spacer()
  41 |                         Picker("Weight", selection: $weightCategory) {
  42 |                             Text("S").tag("S")
  43 |                             Text("M").tag("M")
  44 |                             Text("L").tag("L")
  45 |                         }
  46 |                         .pickerStyle(.segmented)
  47 |                         .labelsHidden()
  48 |                         .frame(width: 120)
  49 |                     }
  50 | 
  51 |                     HStack {
  52 |                         Text("Height:")
  53 |                         Spacer()
  54 |                         Picker("Height", selection: $heightCategory) {
  55 |                             Text("S").tag("S")
  56 |                             Text("M").tag("M")
  57 |                             Text("L").tag("L")
  58 |                         }
  59 |                         .pickerStyle(.segmented)
  60 |                         .labelsHidden()
  61 |                         .frame(width: 120)
  62 |                     }
  63 |                 }
  64 | 
  65 |                 Section("Spouse (Optional)") {
  66 |                     Picker("Spouse", selection: $spouseId) {
  67 |                         Text("None").tag(nil as UUID?)
  68 |                         ForEach(allPeople.filter { $0.isActive }) { person in
  69 |                             Text(person.displayName).tag(person.id as UUID?)
  70 |                         }
  71 |                     }
  72 |                 }
  73 | 
  74 |                 Section {
  75 |                     Toggle("Active", isOn: $isActive)
  76 |                 }
  77 |             }
  78 |             .navigationTitle("Add Participant")
  79 |             .toolbar {
  80 |                 ToolbarItem(placement: .topBarLeading) {
  81 |                     Button("Cancel") { dismiss() }
  82 |                 }
  83 | 
  84 |                 ToolbarItemGroup(placement: .topBarTrailing) {
  85 |                     Button("Save & Add Another") { saveAndContinue() }
  86 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  87 |                     
  88 |                     Button("Done") { saveAndDismiss() }
  89 |                 }
  90 |             }
  91 |         }
  92 |     }
  93 | 
  94 |     private func saveAndContinue() {
  95 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
  96 |         guard !trimmedName.isEmpty else { return }
  97 | 
  98 |         let person = Person(
  99 |             displayName: trimmedName,
 100 |             sex: sex,
 101 |             spouseId: spouseId,
 102 |             isActive: isActive
 103 |         )
 104 |         person.weightCategory = weightCategory
 105 |         person.heightCategory = heightCategory
 106 | 
 107 |         context.insert(person)
 108 |         try? context.save()
 109 |         
 110 |         // Reset form for next entry
 111 |         displayName = ""
 112 |         sex = "M"
 113 |         weightCategory = "M"
 114 |         heightCategory = "M"
 115 |         spouseId = nil
 116 |         isActive = true
 117 |     }
 118 |     
 119 |     private func saveAndDismiss() {
 120 |         // Only save if there's a name entered
 121 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 122 |         if !trimmedName.isEmpty {
 123 |             let person = Person(
 124 |                 displayName: trimmedName,
 125 |                 sex: sex,
 126 |                 spouseId: spouseId,
 127 |                 isActive: isActive
 128 |             )
 129 |             person.weightCategory = weightCategory
 130 |             person.heightCategory = heightCategory
 131 | 
 132 |             context.insert(person)
 133 |             try? context.save()
 134 |         }
 135 |         
 136 |         dismiss()
 137 |     }
 138 | }
 139 | 
 140 | struct EditPersonSheet: View {
 141 |     @Environment(\.dismiss) private var dismiss
 142 |     @Environment(\.modelContext) private var context
 143 | 
 144 |     @Query(sort: \Person.displayName)
 145 |     private var allPeople: [Person]
 146 | 
 147 |     let person: Person
 148 | 
 149 |     @State private var displayName = ""
 150 |     @State private var sex = "M"
 151 |     @State private var weightCategory = "M"
 152 |     @State private var heightCategory = "M"
 153 |     @State private var spouseId: UUID?
 154 |     @State private var isActive = true
 155 | 
 156 |     var body: some View {
 157 |         NavigationStack {
 158 |             Form {
 159 |                 Section("Basic") {
 160 |                     TextField("Name", text: $displayName)
 161 |                 }
 162 | 
 163 |                 Section("Details") {
 164 |                     HStack {
 165 |                         Text("Gender:")
 166 |                         Spacer()
 167 |                         Picker("Gender", selection: $sex) {
 168 |                             Text("M").tag("M")
 169 |                             Text("F").tag("F")
 170 |                         }
 171 |                         .pickerStyle(.segmented)
 172 |                         .labelsHidden()
 173 |                         .frame(width: 120)
 174 |                     }
 175 | 
 176 |                     HStack {
 177 |                         Text("Weight:")
 178 |                         Spacer()
 179 |                         Picker("Weight", selection: $weightCategory) {
 180 |                             Text("S").tag("S")
 181 |                             Text("M").tag("M")
 182 |                             Text("L").tag("L")
 183 |                         }
 184 |                         .pickerStyle(.segmented)
 185 |                         .labelsHidden()
 186 |                         .frame(width: 120)
 187 |                     }
 188 | 
 189 |                     HStack {
 190 |                         Text("Height:")
 191 |                         Spacer()
 192 |                         Picker("Height", selection: $heightCategory) {
 193 |                             Text("S").tag("S")
 194 |                             Text("M").tag("M")
 195 |                             Text("L").tag("L")
 196 |                         }
 197 |                         .pickerStyle(.segmented)
 198 |                         .labelsHidden()
 199 |                         .frame(width: 120)
 200 |                     }
 201 |                 }
 202 | 
 203 |                 Section("Spouse (Optional)") {
 204 |                     Picker("Spouse", selection: $spouseId) {
 205 |                         Text("None").tag(nil as UUID?)
 206 |                         ForEach(allPeople.filter { $0.id != person.id && $0.isActive }) { p in
 207 |                             Text(p.displayName).tag(p.id as UUID?)
 208 |                         }
 209 |                     }
 210 |                 }
 211 | 
 212 |                 Section {
 213 |                     Toggle("Active", isOn: $isActive)
 214 |                 }
 215 |             }
 216 |             .navigationTitle("Edit Participant")
 217 |             .toolbar {
 218 |                 ToolbarItem(placement: .topBarLeading) {
 219 |                     Button("Cancel") { dismiss() }
 220 |                 }
 221 | 
 222 |                 ToolbarItem(placement: .topBarTrailing) {
 223 |                     Button("Save") { save() }
 224 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 225 |                 }
 226 |             }
 227 |             .onAppear {
 228 |                 displayName = person.displayName
 229 |                 sex = person.sex ?? "M"
 230 |                 weightCategory = person.weightCategory ?? "M"
 231 |                 heightCategory = person.heightCategory ?? "M"
 232 |                 spouseId = person.spouseId
 233 |                 isActive = person.isActive
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func save() {
 239 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 240 |         guard !trimmedName.isEmpty else { return }
 241 | 
 242 |         person.displayName = trimmedName
 243 |         person.sex = sex
 244 |         person.weightCategory = weightCategory
 245 |         person.heightCategory = heightCategory
 246 |         person.spouseId = spouseId
 247 |         person.isActive = isActive
 248 | 
 249 |         try? context.save()
 250 |         dismiss()
 251 |     }
 252 | }
 253 | 
 254 | #Preview {
 255 |     CreatePersonSheet()
 256 |         .modelContainer(for: [Person.self])
 257 | }


END FILE: ./Christmas Games/CreatePersonSheet.swift


################################################################################
START FILE: ./Christmas Games/MainMenuView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | /// Main Menu matching the PDF wireframe (vertical menu buttons).
   5 | /// Order (per wireframe): Events → Game Catalog → Participant Catalog → Start/Resume Event → Event Stats
   6 | struct MainMenuView: View {
   7 |     @Query(sort: \Event.createdAt, order: .reverse)
   8 |     private var events: [Event]
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var games: [GameTemplate]
  15 |     
  16 |     @StateObject private var themeManager = ThemeManager()
  17 |     @State private var showThemeSettings = false
  18 |     @State private var showGameSettings = false
  19 | 
  20 |     var body: some View {
  21 |         NavigationStack {
  22 |             ZStack {
  23 |                 // Solid color background based on theme
  24 |                 themeManager.background
  25 |                     .ignoresSafeArea()
  26 |                 
  27 |                 VStack(spacing: 0) {
  28 |                     header
  29 | 
  30 |                     ScrollView {
  31 |                         VStack(spacing: 14) {
  32 |                             NavigationLink {
  33 |                                 EventsListView()
  34 |                                     .environmentObject(themeManager)
  35 |                             } label: {
  36 |                                 MenuRow(
  37 |                                     title: "Events",
  38 |                                     subtitle: "\(events.count) total",
  39 |                                     systemImage: "calendar"
  40 |                                 )
  41 |                             }
  42 | 
  43 |                             NavigationLink {
  44 |                                 GameCatalogView()
  45 |                                     .environmentObject(themeManager)
  46 |                             } label: {
  47 |                                 MenuRow(
  48 |                                     title: "Game Catalog",
  49 |                                     subtitle: "\(games.count) games",
  50 |                                     systemImage: "list.bullet.rectangle"
  51 |                                 )
  52 |                             }
  53 | 
  54 |                             NavigationLink {
  55 |                                 ParticipantCatalogView()
  56 |                                     .environmentObject(themeManager)
  57 |                             } label: {
  58 |                                 MenuRow(
  59 |                                     title: "Participant Catalog",
  60 |                                     subtitle: "\(people.count) participants",
  61 |                                     systemImage: "person.3"
  62 |                                 )
  63 |                             }
  64 | 
  65 |                             NavigationLink {
  66 |                                 EventStatsView()
  67 |                                     .environmentObject(themeManager)
  68 |                             } label: {
  69 |                                 MenuRow(
  70 |                                     title: "Event Stats",
  71 |                                     subtitle: "Results grid",
  72 |                                     systemImage: "chart.bar"
  73 |                                 )
  74 |                             }
  75 |                         }
  76 |                         .padding(16)
  77 |                     }
  78 |                 }
  79 |             }
  80 |             .toolbar {
  81 |                 ToolbarItemGroup(placement: .topBarTrailing) {
  82 |                     Button {
  83 |                         showGameSettings = true
  84 |                     } label: {
  85 |                         Image(systemName: "gear")
  86 |                             .foregroundColor(themeManager.text)
  87 |                             .font(.title3)
  88 |                     }
  89 |                     
  90 |                     Button {
  91 |                         showThemeSettings = true
  92 |                     } label: {
  93 |                         Image(systemName: "paintpalette.fill")
  94 |                             .foregroundColor(themeManager.text)
  95 |                             .font(.title3)
  96 |                     }
  97 |                 }
  98 |             }
  99 |             .toolbarBackground(.hidden, for: .navigationBar)
 100 |             .sheet(isPresented: $showThemeSettings) {
 101 |                 ThemeSettingsView()
 102 |                     .environmentObject(themeManager)
 103 |             }
 104 |             .sheet(isPresented: $showGameSettings) {
 105 |                 GameSettingsView()
 106 |                     .environmentObject(themeManager)
 107 |             }
 108 |         }
 109 |         .environmentObject(themeManager)
 110 |     }
 111 | 
 112 |     private var header: some View {
 113 |         VStack(spacing: 6) {
 114 |             Text("Harmon Family Games")
 115 |                 .font(.title2)
 116 |                 .fontWeight(.semibold)
 117 |                 .foregroundColor(themeManager.text)
 118 |         }
 119 |         .frame(maxWidth: .infinity)
 120 |         .padding(.top, 18)
 121 |         .padding(.bottom, 12)
 122 |     }
 123 | }
 124 | 
 125 | private struct MenuRow: View {
 126 |     let title: String
 127 |     let subtitle: String
 128 |     let systemImage: String
 129 | 
 130 |     var body: some View {
 131 |         HStack(spacing: 14) {
 132 |             Image(systemName: systemImage)
 133 |                 .font(.title3)
 134 |                 .frame(width: 28)
 135 |                 .foregroundColor(.primary)
 136 | 
 137 |             VStack(alignment: .leading, spacing: 2) {
 138 |                 Text(title)
 139 |                     .font(.headline)
 140 |                     .foregroundColor(.primary)
 141 |                 Text(subtitle)
 142 |                     .font(.footnote)
 143 |                     .foregroundStyle(.secondary)
 144 |             }
 145 | 
 146 |             Spacer()
 147 | 
 148 |             Image(systemName: "chevron.right")
 149 |                 .font(.footnote)
 150 |                 .foregroundStyle(.secondary)
 151 |         }
 152 |         .padding(.vertical, 14)
 153 |         .padding(.horizontal, 14)
 154 |         .frame(maxWidth: .infinity)
 155 |         .background(
 156 |             RoundedRectangle(cornerRadius: 14, style: .continuous)
 157 |                 .fill(Color(UIColor.systemBackground))
 158 |                 .shadow(color: .black.opacity(0.15), radius: 5, x: 0, y: 2)
 159 |         )
 160 |         .contentShape(Rectangle())
 161 |     }
 162 | }
 163 | 
 164 | // MARK: - Theme Settings View
 165 | 
 166 | struct ThemeSettingsView: View {
 167 |     @Environment(\.dismiss) private var dismiss
 168 |     @EnvironmentObject var themeManager: ThemeManager
 169 |     
 170 |     @State private var selectedColor: Color = .red
 171 |     @State private var themeIntensity: Double = 0.15
 172 |     
 173 |     var body: some View {
 174 |         NavigationStack {
 175 |             ZStack {
 176 |                 themeManager.background
 177 |                     .ignoresSafeArea()
 178 |                 
 179 |                 ScrollView {
 180 |                     VStack(alignment: .leading, spacing: 24) {
 181 |                         // Preview Section
 182 |                         VStack(alignment: .leading, spacing: 12) {
 183 |                             Text("Preview")
 184 |                                 .font(.title2)
 185 |                                 .bold()
 186 |                                 .foregroundColor(themeManager.primary)
 187 |                             
 188 |                             VStack(spacing: 16) {
 189 |                                 // Sample card showing how the theme looks
 190 |                                 VStack(alignment: .leading, spacing: 8) {
 191 |                                     HStack {
 192 |                                         Image(systemName: "star.fill")
 193 |                                             .foregroundColor(themeManager.primary)
 194 |                                         Text("Sample Item")
 195 |                                             .font(.headline)
 196 |                                             .foregroundColor(.primary)
 197 |                                     }
 198 |                                     Text("This is how text will appear with your theme")
 199 |                                         .font(.subheadline)
 200 |                                         .foregroundStyle(.secondary)
 201 |                                 }
 202 |                                 .padding()
 203 |                                 .background(themeManager.card)
 204 |                                 .cornerRadius(12)
 205 |                                 
 206 |                                 // Sample button
 207 |                                 Button(action: {}) {
 208 |                                     Text("Sample Button")
 209 |                                         .font(.headline)
 210 |                                         .foregroundColor(themeManager.onPrimary)
 211 |                                         .frame(maxWidth: .infinity)
 212 |                                         .padding()
 213 |                                         .background(themeManager.primary)
 214 |                                         .cornerRadius(12)
 215 |                                 }
 216 |                             }
 217 |                         }
 218 |                         .padding()
 219 |                         .background(themeManager.card)
 220 |                         .cornerRadius(12)
 221 |                         
 222 |                         // Color Picker Section
 223 |                         VStack(alignment: .leading, spacing: 12) {
 224 |                             Text("Theme & Background")
 225 |                                 .font(.title2)
 226 |                                 .bold()
 227 |                                 .foregroundColor(themeManager.primary)
 228 |                             
 229 |                             ColorPicker(selection: $selectedColor, supportsOpacity: false) {
 230 |                                 Text("Pick your primary color")
 231 |                                     .foregroundColor(.primary)
 232 |                             }
 233 |                             .padding()
 234 |                             .background(themeManager.card)
 235 |                             .cornerRadius(8)
 236 |                             .onChange(of: selectedColor) { _, newValue in
 237 |                                 if let hex = newValue.toHex() {
 238 |                                     themeManager.selectedThemeId = hex
 239 |                                 }
 240 |                             }
 241 |                             
 242 |                             // Intensity Slider
 243 |                             VStack(alignment: .leading, spacing: 4) {
 244 |                                 HStack {
 245 |                                     Text("Background Intensity")
 246 |                                     Spacer()
 247 |                                     Text("\(Int(themeIntensity * 100))%")
 248 |                                         .font(.caption)
 249 |                                         .bold()
 250 |                                         .foregroundColor(themeManager.secondary)
 251 |                                 }
 252 |                                 
 253 |                                 Slider(value: $themeIntensity, in: 0.05...1.0, step: 0.05)
 254 |                                     .tint(themeManager.primary)
 255 |                                     .onChange(of: themeIntensity) { _, newValue in
 256 |                                         themeManager.currentIntensity = newValue
 257 |                                     }
 258 |                             }
 259 |                             .padding()
 260 |                             .background(themeManager.card)
 261 |                             .cornerRadius(8)
 262 |                         }
 263 |                         .padding()
 264 |                         .background(themeManager.card)
 265 |                         .cornerRadius(12)
 266 |                         
 267 |                         // Quick Color Presets
 268 |                         VStack(alignment: .leading, spacing: 12) {
 269 |                             Text("Quick Presets")
 270 |                                 .font(.title2)
 271 |                                 .bold()
 272 |                                 .foregroundColor(themeManager.primary)
 273 |                             
 274 |                             LazyVGrid(columns: [
 275 |                                 GridItem(.flexible()),
 276 |                                 GridItem(.flexible()),
 277 |                                 GridItem(.flexible())
 278 |                             ], spacing: 12) {
 279 |                                 ColorPresetButton(name: "Christmas", color: Color(hex: "B22222"), selectedColor: $selectedColor)
 280 |                                 ColorPresetButton(name: "Ocean", color: Color(hex: "1A5490"), selectedColor: $selectedColor)
 281 |                                 ColorPresetButton(name: "Forest", color: Color(hex: "228B22"), selectedColor: $selectedColor)
 282 |                                 ColorPresetButton(name: "Sunset", color: Color(hex: "CC5500"), selectedColor: $selectedColor)
 283 |                                 ColorPresetButton(name: "Purple", color: Color(hex: "6A0DAD"), selectedColor: $selectedColor)
 284 |                                 ColorPresetButton(name: "Classic", color: Color(hex: "007AFF"), selectedColor: $selectedColor)
 285 |                             }
 286 |                         }
 287 |                         .padding()
 288 |                         .background(themeManager.card)
 289 |                         .cornerRadius(12)
 290 |                     }
 291 |                     .padding()
 292 |                 }
 293 |             }
 294 |             .navigationTitle("Theme Settings")
 295 |             .navigationBarTitleDisplayMode(.inline)
 296 |             .toolbar {
 297 |                 ToolbarItem(placement: .topBarTrailing) {
 298 |                     Button("Done") {
 299 |                         dismiss()
 300 |                     }
 301 |                     .foregroundColor(themeManager.primary)
 302 |                 }
 303 |             }
 304 |         }
 305 |         .onAppear {
 306 |             selectedColor = Color(hex: themeManager.selectedThemeId)
 307 |             themeIntensity = themeManager.currentIntensity
 308 |         }
 309 |     }
 310 | }
 311 | 
 312 | // MARK: - Color Preset Button
 313 | 
 314 | private struct ColorPresetButton: View {
 315 |     let name: String
 316 |     let color: Color
 317 |     @Binding var selectedColor: Color
 318 |     
 319 |     var body: some View {
 320 |         Button {
 321 |             selectedColor = color
 322 |         } label: {
 323 |             VStack(spacing: 8) {
 324 |                 Circle()
 325 |                     .fill(color)
 326 |                     .frame(width: 50, height: 50)
 327 |                     .overlay(
 328 |                         Circle()
 329 |                             .stroke(Color.gray.opacity(0.3), lineWidth: 2)
 330 |                     )
 331 |                 
 332 |                 Text(name)
 333 |                     .font(.caption)
 334 |                     .foregroundColor(.primary)
 335 |             }
 336 |             .frame(maxWidth: .infinity)
 337 |             .padding(.vertical, 8)
 338 |         }
 339 |     }
 340 | }


END FILE: ./Christmas Games/MainMenuView.swift


################################################################################
START FILE: ./Christmas Games/CSVImportPreviewSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CSVImportPreviewSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let csvData: Data
   9 |     let filename: String?
  10 | 
  11 |     private let maxPreviewRows = 25
  12 |     private let maxPreviewColumns = 12
  13 | 
  14 |     @State private var parseResult: ParseResult = .empty
  15 |     @State private var isImporting = false
  16 | 
  17 |     @State private var alertTitle = "Message"
  18 |     @State private var alertMessage: String?
  19 |     @State private var showAlert = false
  20 | 
  21 |     var body: some View {
  22 |         NavigationStack {
  23 |             Group {
  24 |                 if parseResult.rows.isEmpty {
  25 |                     ContentUnavailableView("No preview available", systemImage: "doc.text")
  26 |                 } else {
  27 |                     previewBody
  28 |                 }
  29 |             }
  30 |             .navigationTitle("CSV Preview")
  31 |             .navigationBarTitleDisplayMode(.inline)
  32 |             .toolbar {
  33 |                 ToolbarItem(placement: .topBarLeading) {
  34 |                     Button("Cancel") { dismiss() }
  35 |                         .disabled(isImporting)
  36 |                 }
  37 |                 ToolbarItem(placement: .topBarTrailing) {
  38 |                     Button(isImporting ? "Importing…" : "Import") {
  39 |                         importNow()
  40 |                     }
  41 |                     .disabled(isImporting)
  42 |                 }
  43 |             }
  44 |             .onAppear {
  45 |                 parseResult = CSVParser.parse(data: csvData, maxRows: maxPreviewRows, maxColumns: maxPreviewColumns)
  46 |                 if let w = parseResult.warning {
  47 |                     alertTitle = "Preview warning"
  48 |                     alertMessage = w
  49 |                     showAlert = true
  50 |                 }
  51 |             }
  52 |             .alert(alertTitle, isPresented: $showAlert) {
  53 |                 Button("OK", role: .cancel) { }
  54 |             } message: {
  55 |                 Text(alertMessage ?? "Unknown error")
  56 |             }
  57 |         }
  58 |     }
  59 | 
  60 |     private var previewBody: some View {
  61 |         List {
  62 |             Section("File") {
  63 |                 HStack {
  64 |                     Text("Name")
  65 |                     Spacer()
  66 |                     Text(filename ?? "CSV")
  67 |                         .foregroundStyle(.secondary)
  68 |                 }
  69 |                 HStack {
  70 |                     Text("Rows shown")
  71 |                     Spacer()
  72 |                     Text("\(max(0, parseResult.rows.count - (parseResult.hasHeader ? 1 : 0)))")
  73 |                         .foregroundStyle(.secondary)
  74 |                 }
  75 |                 HStack {
  76 |                     Text("Columns shown")
  77 |                     Spacer()
  78 |                     Text("\(parseResult.columnCount)")
  79 |                         .foregroundStyle(.secondary)
  80 |                 }
  81 |                 HStack {
  82 |                     Text("Header row")
  83 |                     Spacer()
  84 |                     Text(parseResult.hasHeader ? "Yes" : "No")
  85 |                         .foregroundStyle(.secondary)
  86 |                 }
  87 |             }
  88 | 
  89 |             if parseResult.hasHeader, let header = parseResult.rows.first {
  90 |                 Section("Headers") {
  91 |                     ForEach(Array(header.prefix(parseResult.columnCount)).indices, id: \.self) { idx in
  92 |                         Text(header[idx].isEmpty ? "(blank)" : header[idx])
  93 |                     }
  94 |                 }
  95 |             }
  96 | 
  97 |             Section("Preview") {
  98 |                 let startIndex = parseResult.hasHeader ? 1 : 0
  99 |                 let displayRows = Array(parseResult.rows.dropFirst(startIndex))
 100 | 
 101 |                 ForEach(displayRows.indices, id: \.self) { r in
 102 |                     VStack(alignment: .leading, spacing: 6) {
 103 |                         Text("Row \(r + 1)")
 104 |                             .font(.subheadline)
 105 |                             .bold()
 106 | 
 107 |                         let row = displayRows[r]
 108 |                         ForEach(0..<parseResult.columnCount, id: \.self) { c in
 109 |                             let value = c < row.count ? row[c] : ""
 110 |                             let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)
 111 |                             if !trimmed.isEmpty {
 112 |                                 Text(trimmed)
 113 |                                     .font(.footnote)
 114 |                                     .foregroundStyle(.secondary)
 115 |                                     .lineLimit(2)
 116 |                             }
 117 |                         }
 118 |                     }
 119 |                     .padding(.vertical, 4)
 120 |                 }
 121 |             }
 122 |         }
 123 |     }
 124 | 
 125 |     private func importNow() {
 126 |         isImporting = true
 127 |         defer { isImporting = false }
 128 | 
 129 |         do {
 130 |             let r = try GameCatalogCSVImporter.importCSV(context: context, csvData: csvData)
 131 |             alertTitle = "Import complete"
 132 |             alertMessage = "Imported/updated \(r.insertedOrUpdated). Skipped \(r.skipped). Removed \(r.removed)."
 133 |             showAlert = true
 134 |         } catch {
 135 |             alertTitle = "Import failed"
 136 |             alertMessage = error.localizedDescription
 137 |             showAlert = true
 138 |         }
 139 |     }
 140 | }
 141 | 
 142 | // MARK: - Lightweight CSV Parser (preview only)
 143 | 
 144 | private enum CSVParser {
 145 |     static func parse(data: Data, maxRows: Int, maxColumns: Int) -> ParseResult {
 146 |         guard let s = String(data: data, encoding: .utf8) ?? String(data: data, encoding: .isoLatin1) else {
 147 |             return .init(rows: [], columnCount: 0, hasHeader: false, warning: "Could not decode file as UTF-8/Latin1.")
 148 |         }
 149 | 
 150 |         let normalized = s.replacingOccurrences(of: "\r\n", with: "\n").replacingOccurrences(of: "\r", with: "\n")
 151 |         let lines = normalized.split(separator: "\n", omittingEmptySubsequences: true)
 152 | 
 153 |         var rows: [[String]] = []
 154 |         rows.reserveCapacity(min(lines.count, maxRows + 1))
 155 | 
 156 |         for line in lines.prefix(maxRows + 1) {
 157 |             rows.append(parseLine(String(line)))
 158 |         }
 159 | 
 160 |         let columnCount = min(maxColumns, rows.map { $0.count }.max() ?? 0)
 161 |         let hasHeader = inferHeader(rows.first)
 162 | 
 163 |         var warning: String? = nil
 164 |         if columnCount == 0 {
 165 |             warning = "No columns detected. Check delimiter/format."
 166 |         } else if lines.count > maxRows + 1 {
 167 |             warning = "Preview is limited to the first \(maxRows) data rows."
 168 |         }
 169 | 
 170 |         return .init(rows: rows, columnCount: columnCount, hasHeader: hasHeader, warning: warning)
 171 |     }
 172 | 
 173 |     private static func parseLine(_ line: String) -> [String] {
 174 |         var result: [String] = []
 175 |         var current = ""
 176 |         var inQuotes = false
 177 |         var i = line.startIndex
 178 | 
 179 |         while i < line.endIndex {
 180 |             let ch = line[i]
 181 | 
 182 |             if ch == "\"" {
 183 |                 let next = line.index(after: i)
 184 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 185 |                     current.append("\"")
 186 |                     i = line.index(after: next)
 187 |                     continue
 188 |                 } else {
 189 |                     inQuotes.toggle()
 190 |                     i = line.index(after: i)
 191 |                     continue
 192 |                 }
 193 |             }
 194 | 
 195 |             if ch == "," && !inQuotes {
 196 |                 result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 197 |                 current = ""
 198 |                 i = line.index(after: i)
 199 |                 continue
 200 |             }
 201 | 
 202 |             current.append(ch)
 203 |             i = line.index(after: i)
 204 |         }
 205 | 
 206 |         result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 207 |         return result
 208 |     }
 209 | 
 210 |     private static func inferHeader(_ firstRow: [String]?) -> Bool {
 211 |         guard let row = firstRow, !row.isEmpty else { return false }
 212 |         let sample = row.prefix(10)
 213 |         let nonEmpty = sample.filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
 214 |         guard !nonEmpty.isEmpty else { return false }
 215 | 
 216 |         let nonNumericCount = nonEmpty.filter { Double($0) == nil }.count
 217 |         return Double(nonNumericCount) / Double(nonEmpty.count) >= 0.7
 218 |     }
 219 | }
 220 | 
 221 | private struct ParseResult {
 222 |     let rows: [[String]]
 223 |     let columnCount: Int
 224 |     let hasHeader: Bool
 225 |     let warning: String?
 226 | 
 227 |     static let empty = ParseResult(rows: [], columnCount: 0, hasHeader: false, warning: nil)
 228 | }


END FILE: ./Christmas Games/CSVImportPreviewSheet.swift


################################################################################
START FILE: ./Christmas Games/FairnessEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | final class FairnessEngine {
   5 | 
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     func generateTeams(for round: Round, in event: Event) throws -> [RoundTeam] {
  13 | 
  14 |         guard let eventGame = round.eventGame else {
  15 |             throw FairnessError.missingEventGame
  16 |         }
  17 | 
  18 |         let settings = try effectiveSettings(for: eventGame)
  19 | 
  20 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  21 |         let required = settings.teamCount * settings.playersPerTeam
  22 | 
  23 |         guard eligiblePeople.count >= required else {
  24 |             throw FairnessError.notEnoughPlayers(required: required, available: eligiblePeople.count)
  25 |         }
  26 | 
  27 |         // Detect if this is a regeneration (teams already exist)
  28 |         let currentPlayerIds = Set(round.teams.flatMap { $0.memberPersonIds })
  29 |         let isRegeneration = !currentPlayerIds.isEmpty
  30 | 
  31 |         // Choose participants for this round based on "equal playing time"
  32 |         // If regenerating, try to exclude current players to force rotation
  33 |         let chosen = chooseParticipants(
  34 |             eligible: eligiblePeople,
  35 |             required: required,
  36 |             event: event,
  37 |             excluding: isRegeneration ? currentPlayerIds : []
  38 |         )
  39 | 
  40 |         if settings.teamType == .couplesOnly {
  41 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
  42 |         }
  43 | 
  44 |         // Generate candidate partitions and pick best by score
  45 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
  46 | 
  47 |         let candidates = 600
  48 |         var best: [RoundTeam] = []
  49 |         var bestScore = Double.greatestFiniteMagnitude
  50 | 
  51 |         for _ in 0..<candidates {
  52 |             let shuffled = chosen.shuffled().map { $0.id }
  53 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
  54 | 
  55 |             let score = scoreTeams(
  56 |                 teams: teams,
  57 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
  58 |                 historySignatures: historySignatures,
  59 |                 allowSpousesSameTeam: false
  60 |             )
  61 | 
  62 |             if score < bestScore {
  63 |                 bestScore = score
  64 |                 best = teams
  65 |                 if score == 0 { break }
  66 |             }
  67 |         }
  68 | 
  69 |         return best
  70 |     }
  71 | 
  72 |     /// Generate teams with a preferred set of players (used for skipping games)
  73 |     func generateTeamsWithPreferredPlayers(
  74 |         for round: Round,
  75 |         in event: Event,
  76 |         preferredPlayers: [UUID]
  77 |     ) throws -> [RoundTeam] {
  78 | 
  79 |         guard let eventGame = round.eventGame else {
  80 |             throw FairnessError.missingEventGame
  81 |         }
  82 | 
  83 |         let settings = try effectiveSettings(for: eventGame)
  84 |         let required = settings.teamCount * settings.playersPerTeam
  85 | 
  86 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  87 |         let eligibleIds = Set(eligiblePeople.map { $0.id })
  88 | 
  89 |         // Filter preferred players to only those who are eligible
  90 |         let validPreferred = preferredPlayers.filter { eligibleIds.contains($0) }
  91 | 
  92 |         // Adjust player count if needed
  93 |         let chosen: [Person]
  94 |         if validPreferred.count == required {
  95 |             // Perfect match - use as-is
  96 |             chosen = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
  97 |         } else if validPreferred.count < required {
  98 |             // Need more players - add from bench by fairness
  99 |             let playedCounts = roundsPlayedCounts(event: event)
 100 |             let benchPlayers = eligiblePeople.filter { !validPreferred.contains($0.id) }
 101 |             let additionalNeeded = required - validPreferred.count
 102 | 
 103 |             let additional = benchPlayers
 104 |                 .sorted {
 105 |                     let a = playedCounts[$0.id, default: 0]
 106 |                     let b = playedCounts[$1.id, default: 0]
 107 |                     if a != b { return a < b }
 108 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 109 |                 }
 110 |                 .prefix(additionalNeeded)
 111 | 
 112 |             let preferredPeople = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 113 |             chosen = preferredPeople + additional
 114 |         } else {
 115 |             // Too many players - remove by most playing time
 116 |             let playedCounts = roundsPlayedCounts(event: event)
 117 |             chosen = validPreferred
 118 |                 .compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 119 |                 .sorted {
 120 |                     let a = playedCounts[$0.id, default: 0]
 121 |                     let b = playedCounts[$1.id, default: 0]
 122 |                     if a != b { return a < b } // Keep those with LESS playing time
 123 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 124 |                 }
 125 |                 .prefix(required)
 126 |                 .map { $0 }
 127 |         }
 128 | 
 129 |         guard chosen.count == required else {
 130 |             throw FairnessError.notEnoughPlayers(required: required, available: chosen.count)
 131 |         }
 132 | 
 133 |         if settings.teamType == .couplesOnly {
 134 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
 135 |         }
 136 | 
 137 |         // Generate candidate partitions and pick best by score
 138 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
 139 | 
 140 |         let candidates = 600
 141 |         var best: [RoundTeam] = []
 142 |         var bestScore = Double.greatestFiniteMagnitude
 143 | 
 144 |         for _ in 0..<candidates {
 145 |             let shuffled = chosen.shuffled().map { $0.id }
 146 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
 147 | 
 148 |             let score = scoreTeams(
 149 |                 teams: teams,
 150 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
 151 |                 historySignatures: historySignatures,
 152 |                 allowSpousesSameTeam: false
 153 |             )
 154 | 
 155 |             if score < bestScore {
 156 |                 bestScore = score
 157 |                 best = teams
 158 |                 if score == 0 { break }
 159 |             }
 160 |         }
 161 | 
 162 |         return best
 163 |     }
 164 | 
 165 |     // MARK: - Settings
 166 | 
 167 |     private struct Settings {
 168 |         let teamCount: Int
 169 |         let playersPerTeam: Int
 170 |         let teamType: TeamType
 171 |     }
 172 | 
 173 |     private func effectiveSettings(for eventGame: EventGame) throws -> Settings {
 174 |         let t = try fetchTemplate(id: eventGame.gameTemplateId)
 175 | 
 176 |         let teamCount = eventGame.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 177 |         let playersPerTeam = eventGame.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 178 |         let teamType = eventGame.overrideTeamType ?? t?.defaultTeamType ?? .any
 179 | 
 180 |         return Settings(teamCount: max(1, teamCount), playersPerTeam: max(1, playersPerTeam), teamType: teamType)
 181 |     }
 182 | 
 183 |     // MARK: - Participant choice (equal playing time by rounds played)
 184 | 
 185 |     private func chooseParticipants(
 186 |         eligible: [Person],
 187 |         required: Int,
 188 |         event: Event,
 189 |         excluding: Set<UUID> = []
 190 |     ) -> [Person] {
 191 |         let playedCounts = roundsPlayedCounts(event: event)
 192 | 
 193 |         // Try to exclude current players if there are enough non-excluded players
 194 |         let nonExcluded = eligible.filter { !excluding.contains($0.id) }
 195 | 
 196 |         let pool = nonExcluded.count >= required ? nonExcluded : eligible
 197 | 
 198 |         return pool
 199 |             .sorted {
 200 |                 let a = playedCounts[$0.id, default: 0]
 201 |                 let b = playedCounts[$1.id, default: 0]
 202 |                 if a != b { return a < b }
 203 |                 return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 204 |             }
 205 |             .prefix(required)
 206 |             .map { $0 }
 207 |     }
 208 | 
 209 |     private func roundsPlayedCounts(event: Event) -> [UUID: Int] {
 210 |         var counts: [UUID: Int] = [:]
 211 |         for eg in event.eventGames {
 212 |             for r in eg.rounds where r.completedAt != nil {
 213 |                 for team in r.teams {
 214 |                     for pid in team.memberPersonIds {
 215 |                         counts[pid, default: 0] += 1
 216 |                     }
 217 |                 }
 218 |             }
 219 |         }
 220 |         return counts
 221 |     }
 222 | 
 223 |     // MARK: - Matchup signature (head-to-head)
 224 | 
 225 |     private func matchupSignaturesForGame(eventGame: EventGame) -> Set<String> {
 226 |         var s = Set<String>()
 227 |         for r in eventGame.rounds where r.completedAt != nil {
 228 |             let sig = matchupSignature(teams: r.teams)
 229 |             s.insert(sig)
 230 |         }
 231 |         return s
 232 |     }
 233 | 
 234 |     private func matchupSignature(teams: [RoundTeam]) -> String {
 235 |         let normalizedTeams = teams
 236 |             .map { $0.memberPersonIds.sorted(by: { $0.uuidString < $1.uuidString }) }
 237 |             .sorted { left, right in
 238 |                 left.map(\.uuidString).joined(separator: ",") < right.map(\.uuidString).joined(separator: ",")
 239 |             }
 240 |         return normalizedTeams
 241 |             .map { $0.map(\.uuidString).joined(separator: ",") }
 242 |             .joined(separator: "||")
 243 |     }
 244 | 
 245 |     // MARK: - Scoring
 246 | 
 247 |     private func scoreTeams(
 248 |         teams: [RoundTeam],
 249 |         peopleById: [UUID: Person],
 250 |         historySignatures: Set<String>,
 251 |         allowSpousesSameTeam: Bool
 252 |     ) -> Double {
 253 | 
 254 |         var score: Double = 0
 255 | 
 256 |         // 1) Prevent repeating the exact head-to-head matchup
 257 |         let sig = matchupSignature(teams: teams)
 258 |         if historySignatures.contains(sig) {
 259 |             score += 10_000
 260 |         }
 261 | 
 262 |         // 2) Spouse constraint (unless couplesOnly)
 263 |         if !allowSpousesSameTeam {
 264 |             for team in teams {
 265 |                 let ids = Set(team.memberPersonIds)
 266 |                 for pid in ids {
 267 |                     if let spouseId = peopleById[pid]?.spouseId, ids.contains(spouseId) {
 268 |                         score += 5_000
 269 |                     }
 270 |                 }
 271 |             }
 272 |         }
 273 | 
 274 |         // 3) Balance by athleticAbility / weight / age (if available)
 275 |         func teamStat(_ team: RoundTeam, get: (Person) -> Int?) -> Double {
 276 |             let vals = team.memberPersonIds.compactMap { peopleById[$0] }.compactMap(get)
 277 |             if vals.isEmpty { return 0 }
 278 |             return Double(vals.reduce(0, +))
 279 |         }
 280 | 
 281 |         let athletic = teams.map { teamStat($0) { $0.athleticAbility } }
 282 |         let weight = teams.map { teamStat($0) { $0.weight } }
 283 |         let age = teams.map { teamStat($0) { $0.age } }
 284 | 
 285 |         score += variancePenalty(athletic) * 2.0
 286 |         score += variancePenalty(weight) * 0.25
 287 |         score += variancePenalty(age) * 0.5
 288 | 
 289 |         return score
 290 |     }
 291 | 
 292 |     private func variancePenalty(_ values: [Double]) -> Double {
 293 |         guard values.count > 1 else { return 0 }
 294 |         let mean = values.reduce(0, +) / Double(values.count)
 295 |         let varSum = values.reduce(0) { $0 + pow($1 - mean, 2) }
 296 |         return varSum
 297 |     }
 298 | 
 299 |     // MARK: - Couples-only teams
 300 | 
 301 |     private func generateCouplesOnlyTeams(teamCount: Int, eligible: [Person]) throws -> [RoundTeam] {
 302 | 
 303 |         let byId = Dictionary(uniqueKeysWithValues: eligible.map { ($0.id, $0) })
 304 | 
 305 |         var used = Set<UUID>()
 306 |         var pairs: [[UUID]] = []
 307 | 
 308 |         for person in eligible {
 309 |             guard !used.contains(person.id),
 310 |                   let spouseId = person.spouseId,
 311 |                   let spouse = byId[spouseId],
 312 |                   spouse.spouseId == person.id,
 313 |                   !used.contains(spouse.id)
 314 |             else { continue }
 315 | 
 316 |             used.insert(person.id)
 317 |             used.insert(spouse.id)
 318 |             pairs.append([person.id, spouse.id])
 319 |         }
 320 | 
 321 |         guard pairs.count >= teamCount else {
 322 |             throw FairnessError.notEnoughCouples(required: teamCount, available: pairs.count)
 323 |         }
 324 | 
 325 |         return pairs.prefix(teamCount).map { RoundTeam(memberPersonIds: $0) }
 326 |     }
 327 | 
 328 |     // MARK: - Utilities
 329 | 
 330 |     private func partition(ids: [UUID], teamCount: Int, playersPerTeam: Int) -> [RoundTeam] {
 331 |         var result: [RoundTeam] = []
 332 |         var index = 0
 333 |         for _ in 0..<teamCount {
 334 |             let slice = ids[index..<(index + playersPerTeam)]
 335 |             result.append(RoundTeam(memberPersonIds: Array(slice)))
 336 |             index += playersPerTeam
 337 |         }
 338 |         return result
 339 |     }
 340 | 
 341 |     private func fetchEligiblePeople(for event: Event) throws -> [Person] {
 342 |         let all = try context.fetch(FetchDescriptor<Person>())
 343 |         let idSet = Set(event.participantIds)
 344 |         return all.filter { $0.isActive && idSet.contains($0.id) }
 345 |     }
 346 | 
 347 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 348 |         let d = FetchDescriptor<GameTemplate>()
 349 |         let templates = try context.fetch(d)
 350 |         return templates.first(where: { $0.id == id })
 351 |     }
 352 | }
 353 | 
 354 | // MARK: - Errors
 355 | 
 356 | enum FairnessError: LocalizedError {
 357 |     case missingEventGame
 358 |     case notEnoughPlayers(required: Int, available: Int)
 359 |     case notEnoughCouples(required: Int, available: Int)
 360 | 
 361 |     var errorDescription: String? {
 362 |         switch self {
 363 |         case .missingEventGame:
 364 |             return "Round is not attached to an EventGame."
 365 |         case .notEnoughPlayers(let r, let a):
 366 |             return "Not enough players. Required \(r), available \(a)."
 367 |         case .notEnoughCouples(let r, let a):
 368 |             return "Not enough couples. Required \(r), available \(a)."
 369 |         }
 370 |     }
 371 | }


END FILE: ./Christmas Games/FairnessEngine.swift


################################################################################
START FILE: ./Christmas Games/FilesHelper.swift
################################################################################
   1 | import Foundation
   2 | import UIKit
   3 | 
   4 | enum FilesHelper {
   5 | 
   6 |     static func openAppFolder() {
   7 |         guard let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
   8 |             return
   9 |         }
  10 | 
  11 |         UIApplication.shared.open(url)
  12 |     }
  13 | 
  14 |     static func ensureGamesFolderExists() {
  15 |         guard let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
  16 |             return
  17 |         }
  18 | 
  19 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  20 | 
  21 |         if !FileManager.default.fileExists(atPath: folder.path) {
  22 |             try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  23 |         }
  24 |     }
  25 | }


END FILE: ./Christmas Games/FilesHelper.swift


################################################################################
START FILE: ./Christmas Games/GameTemplateSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreateGameTemplateSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let onCreated: (GameTemplate) -> Void
   9 | 
  10 |     @State private var name = ""
  11 |     @State private var groupName = ""
  12 |     @State private var defaultTeamCount = 2
  13 |     @State private var defaultPlayersPerTeam = 2
  14 |     @State private var defaultRoundsPerGame = 1
  15 |     @State private var teamType: TeamType = .any
  16 |     @State private var playInstructions = ""
  17 |     @State private var setupInstructions = ""
  18 | 
  19 |     var body: some View {
  20 |         NavigationStack {
  21 |             Form {
  22 |                 Section("Basic") {
  23 |                     TextField("Name", text: $name)
  24 |                     TextField("Group (optional)", text: $groupName)
  25 |                 }
  26 | 
  27 |                 Section("Defaults") {
  28 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
  29 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
  30 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
  31 | 
  32 |                     Picker("Team Type", selection: $teamType) {
  33 |                         Text("Any").tag(TeamType.any)
  34 |                         Text("Male Only").tag(TeamType.maleOnly)
  35 |                         Text("Female Only").tag(TeamType.femaleOnly)
  36 |                         Text("Couples Only").tag(TeamType.couplesOnly)
  37 |                     }
  38 |                 }
  39 | 
  40 |                 Section("Instructions") {
  41 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
  42 |                         .lineLimit(3...8)
  43 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
  44 |                         .lineLimit(3...8)
  45 |                 }
  46 |             }
  47 |             .navigationTitle("New Game Template")
  48 |             .toolbar {
  49 |                 ToolbarItem(placement: .topBarLeading) {
  50 |                     Button("Cancel") { dismiss() }
  51 |                 }
  52 | 
  53 |                 ToolbarItem(placement: .topBarTrailing) {
  54 |                     Button("Save") { save() }
  55 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  56 |                 }
  57 |             }
  58 |         }
  59 |     }
  60 | 
  61 |     private func save() {
  62 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
  63 |         guard !trimmedName.isEmpty else { return }
  64 | 
  65 |         let template = GameTemplate(
  66 |             externalId: "user_\(UUID().uuidString.lowercased())",
  67 |             name: trimmedName,
  68 |             groupName: groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName,
  69 |             defaultTeamCount: defaultTeamCount,
  70 |             defaultPlayersPerTeam: defaultPlayersPerTeam,
  71 |             defaultRoundsPerGame: defaultRoundsPerGame,
  72 |             defaultTeamType: teamType,
  73 |             playInstructions: playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions,
  74 |             setupInstructions: setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
  75 |         )
  76 | 
  77 |         context.insert(template)
  78 |         try? context.save()
  79 | 
  80 |         onCreated(template)
  81 |         dismiss()
  82 |     }
  83 | }


END FILE: ./Christmas Games/GameTemplateSheet.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogImporter {
   6 | 
   7 |     // MARK: - Public API (matches your BootstrapView calls)
   8 | 
   9 |     /// Imports games.json from Documents *if present*.
  10 |     /// Returns the number of templates imported/updated, or nil if the file doesn't exist.
  11 |     static func importFromDocumentsIfPresent(
  12 |         context: ModelContext,
  13 |         filename: String,
  14 |         fileExtension: String
  15 |     ) throws -> Int? {
  16 |         let url = documentsURL(filename: filename, fileExtension: fileExtension)
  17 | 
  18 |         guard FileManager.default.fileExists(atPath: url.path) else {
  19 |             return nil
  20 |         }
  21 | 
  22 |         let data = try Data(contentsOf: url)
  23 |         let count = try importFromData(context: context, jsonData: data)
  24 |         return count
  25 |     }
  26 | 
  27 |     /// Imports games.json from the app bundle.
  28 |     /// Returns the number of templates imported/updated.
  29 |     static func importFromBundle(
  30 |         context: ModelContext,
  31 |         filename: String,
  32 |         fileExtension: String
  33 |     ) throws -> Int {
  34 |         guard let url = Bundle.main.url(forResource: filename, withExtension: fileExtension) else {
  35 |             return 0 // treat missing bundled json as "no seed"
  36 |         }
  37 | 
  38 |         let data = try Data(contentsOf: url)
  39 |         let count = try importFromData(context: context, jsonData: data)
  40 |         return count
  41 |     }
  42 | 
  43 |     // MARK: - Backward-compatible helpers (optional; safe to keep)
  44 | 
  45 |     static func importFromBundle(context: ModelContext) throws {
  46 |         _ = try importFromBundle(context: context, filename: "games", fileExtension: "json")
  47 |     }
  48 | 
  49 |     static func importFromDocuments(context: ModelContext) throws {
  50 |         _ = try importFromDocumentsIfPresent(context: context, filename: "games", fileExtension: "json")
  51 |     }
  52 | 
  53 |     // MARK: - Core import
  54 | 
  55 |     private static func importFromData(context: ModelContext, jsonData: Data) throws -> Int {
  56 |         let decoder = JSONDecoder()
  57 |         let catalog = try decoder.decode(GameCatalog.self, from: jsonData)
  58 | 
  59 |         var count = 0
  60 |         for game in catalog.games {
  61 |             try upsert(game: game, context: context)
  62 |             count += 1
  63 |         }
  64 | 
  65 |         try context.save()
  66 |         return count
  67 |     }
  68 | 
  69 |     private static func upsert(game: GameCatalogGame, context: ModelContext) throws {
  70 |         let descriptor = FetchDescriptor<GameTemplate>(
  71 |             predicate: #Predicate { $0.externalId == game.externalId }
  72 |         )
  73 | 
  74 |         if let existing = try context.fetch(descriptor).first {
  75 |             existing.name = game.name
  76 |             existing.groupName = game.groupName
  77 |             existing.defaultTeamCount = game.defaultTeamCount
  78 |             existing.defaultPlayersPerTeam = game.defaultPlayersPerTeam
  79 |             existing.defaultRoundsPerGame = game.defaultRoundsPerGame
  80 |             existing.defaultTeamTypeRaw = game.teamType.rawValue
  81 |             existing.playInstructions = game.playInstructions
  82 |             existing.setupInstructions = game.setupInstructions
  83 |         } else {
  84 |             let template = GameTemplate(
  85 |                 externalId: game.externalId,
  86 |                 name: game.name,
  87 |                 groupName: game.groupName,
  88 |                 defaultTeamCount: game.defaultTeamCount,
  89 |                 defaultPlayersPerTeam: game.defaultPlayersPerTeam,
  90 |                 defaultRoundsPerGame: game.defaultRoundsPerGame,
  91 |                 defaultTeamType: game.teamType,
  92 |                 playInstructions: game.playInstructions,
  93 |                 setupInstructions: game.setupInstructions
  94 |             )
  95 |             context.insert(template)
  96 |         }
  97 |     }
  98 | 
  99 |     // MARK: - Paths
 100 | 
 101 |     private static func documentsURL(filename: String, fileExtension: String) -> URL {
 102 |         FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
 103 |             .appendingPathComponent("\(filename).\(fileExtension)")
 104 |     }
 105 | }
 106 | 
 107 | // MARK: - Private JSON DTOs (avoid redeclaration collisions)
 108 | 
 109 | private struct GameCatalog: Codable {
 110 |     let games: [GameCatalogGame]
 111 | }
 112 | 
 113 | private struct GameCatalogGame: Codable {
 114 |     let externalId: String
 115 |     let name: String
 116 |     let groupName: String?
 117 |     let defaultTeamCount: Int
 118 |     let defaultPlayersPerTeam: Int
 119 |     let defaultRoundsPerGame: Int
 120 |     let teamType: TeamType
 121 |     let playInstructions: String?
 122 |     let setupInstructions: String?
 123 | }


END FILE: ./Christmas Games/GameCatalogImporter.swift


################################################################################
START FILE: ./Christmas Games/EventStatsView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct EventStatsView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     @Query(sort: \Event.createdAt, order: .reverse)
   9 |     private var allEvents: [Event]
  10 | 
  11 |     @Query(sort: \Person.displayName)
  12 |     private var people: [Person]
  13 | 
  14 |     @State private var selectedEventId: UUID?
  15 | 
  16 |     @State private var showResetConfirm = false
  17 |     @State private var message: String?
  18 |     @State private var showMessage = false
  19 | 
  20 |     @State private var sortColumn: SortColumn = .rank
  21 |     @State private var sortAscending: Bool = true
  22 | 
  23 |     enum SortColumn {
  24 |         case name, games, first, second, third, rank
  25 |     }
  26 | 
  27 |     var body: some View {
  28 |         ZStack {
  29 |             themeManager.background
  30 |                 .ignoresSafeArea()
  31 | 
  32 |             VStack(spacing: 0) {
  33 |                 eventPicker
  34 | 
  35 |                 if let stats = calculatedStats {
  36 |                     statsTable(stats: stats)
  37 |                         .scrollContentBackground(.hidden)
  38 |                 } else {
  39 |                     ContentUnavailableView(
  40 |                         "No Stats Available",
  41 |                         systemImage: "chart.bar",
  42 |                         description: Text("Play some games to see statistics.")
  43 |                     )
  44 |                     .padding()
  45 |                 }
  46 |             }
  47 |         }
  48 |         .navigationTitle("Event Stats")
  49 |         .toolbarBackground(.hidden, for: .navigationBar)
  50 |         .toolbar {
  51 |             ToolbarItem(placement: .topBarTrailing) {
  52 |                 Button("Reset") { showResetConfirm = true }
  53 |                     .foregroundColor(themeManager.text)
  54 |                     .disabled(selectedEventId == nil)
  55 |             }
  56 |         }
  57 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
  58 |             Button("Reset Event", role: .destructive) {
  59 |                 resetSelectedEvent()
  60 |             }
  61 |             Button("Cancel", role: .cancel) { }
  62 |         } message: {
  63 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
  64 |         }
  65 |         .alert("Message", isPresented: $showMessage) {
  66 |             Button("OK", role: .cancel) { }
  67 |         } message: {
  68 |             Text(message ?? "Unknown error")
  69 |         }
  70 |     }
  71 | 
  72 |     private var eventPicker: some View {
  73 |         Picker("Event", selection: $selectedEventId) {
  74 |             Text("All Events").tag(nil as UUID?)
  75 |             ForEach(allEvents) { event in
  76 |                 Text(event.name).tag(event.id as UUID?)
  77 |             }
  78 |         }
  79 |         .pickerStyle(.menu)
  80 |         .padding()
  81 |     }
  82 | 
  83 |     private var calculatedStats: [PlayerStats]? {
  84 |         let eventsToAnalyze: [Event]
  85 |         if let selectedEventId {
  86 |             eventsToAnalyze = allEvents.filter { $0.id == selectedEventId }
  87 |         } else {
  88 |             eventsToAnalyze = allEvents
  89 |         }
  90 | 
  91 |         guard !eventsToAnalyze.isEmpty else { return nil }
  92 | 
  93 |         var statsDict: [UUID: PlayerStats] = [:]
  94 | 
  95 |         for event in eventsToAnalyze {
  96 |             for eventGame in event.eventGames {
  97 |                 for round in eventGame.rounds where round.completedAt != nil {
  98 | 
  99 |                     // Process placements
 100 |                     for (personId, placement) in round.placements {
 101 |                         var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 102 |                         stat.gamesPlayed += 1
 103 | 
 104 |                         switch placement {
 105 |                         case 1: stat.firstPlace += 1
 106 |                         case 2: stat.secondPlace += 1
 107 |                         case 3: stat.thirdPlace += 1
 108 |                         default: break
 109 |                         }
 110 | 
 111 |                         statsDict[personId] = stat
 112 |                     }
 113 | 
 114 |                     // Handle ties (when resultType == .tie and winningTeamId == nil)
 115 |                     if round.resultType == .tie, round.winningTeamId == nil {
 116 |                         for team in round.teams {
 117 |                             for personId in team.memberPersonIds {
 118 |                                 var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 119 |                                 if round.placements[personId] == nil {
 120 |                                     stat.gamesPlayed += 1
 121 |                                 }
 122 |                                 // Tie counts as 1st place for all
 123 |                                 stat.firstPlace += 1
 124 |                                 statsDict[personId] = stat
 125 |                             }
 126 |                         }
 127 |                     }
 128 |                 }
 129 |             }
 130 |         }
 131 | 
 132 |         guard !statsDict.isEmpty else { return nil }
 133 | 
 134 |         let peopleById = Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 135 | 
 136 |         var result = statsDict.values.map { stat -> PlayerStats in
 137 |             var s = stat
 138 |             s.displayName = peopleById[stat.personId]?.displayName ?? "Unknown"
 139 |             s.totalPoints = (s.firstPlace * 3) + (s.secondPlace * 2) + (s.thirdPlace * 1)
 140 |             return s
 141 |         }
 142 | 
 143 |         // Apply sorting based on selected column
 144 |         switch sortColumn {
 145 |         case .name:
 146 |             result.sort { lhs, rhs in
 147 |                 sortAscending
 148 |                 ? lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedAscending
 149 |                 : lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedDescending
 150 |             }
 151 |         case .games:
 152 |             result.sort { sortAscending ? $0.gamesPlayed < $1.gamesPlayed : $0.gamesPlayed > $1.gamesPlayed }
 153 |         case .first:
 154 |             result.sort { sortAscending ? $0.firstPlace < $1.firstPlace : $0.firstPlace > $1.firstPlace }
 155 |         case .second:
 156 |             result.sort { sortAscending ? $0.secondPlace < $1.secondPlace : $0.secondPlace > $1.secondPlace }
 157 |         case .third:
 158 |             result.sort { sortAscending ? $0.thirdPlace < $1.thirdPlace : $0.thirdPlace > $1.thirdPlace }
 159 |         case .rank:
 160 |             result.sort { sortAscending ? $0.totalPoints < $1.totalPoints : $0.totalPoints > $1.totalPoints }
 161 |         }
 162 | 
 163 |         // Assign ranks based on points (for display)
 164 |         let rankedByPoints = result.sorted { $0.totalPoints > $1.totalPoints }
 165 |         var rankMap: [UUID: Int] = [:]
 166 |         for (index, stat) in rankedByPoints.enumerated() {
 167 |             rankMap[stat.personId] = index + 1
 168 |         }
 169 | 
 170 |         for i in 0..<result.count {
 171 |             result[i].rank = rankMap[result[i].personId] ?? 0
 172 |         }
 173 | 
 174 |         return result
 175 |     }
 176 | 
 177 |     private func toggleSort(column: SortColumn) {
 178 |         if sortColumn == column {
 179 |             sortAscending.toggle()
 180 |         } else {
 181 |             sortColumn = column
 182 |             // Name defaults to A-Z, numbers default to high-to-low
 183 |             sortAscending = (column == .name)
 184 |         }
 185 |     }
 186 | 
 187 |     private func sortIndicator(for column: SortColumn) -> String {
 188 |         guard sortColumn == column else { return "" }
 189 |         return sortAscending ? " ↑" : " ↓"
 190 |     }
 191 | 
 192 |     private func statsTable(stats: [PlayerStats]) -> some View {
 193 |         List {
 194 |             Section {
 195 |                 HStack {
 196 |                     Button(action: { toggleSort(column: .name) }) {
 197 |                         Text("Name\(sortIndicator(for: .name))")
 198 |                             .frame(maxWidth: .infinity, alignment: .leading)
 199 |                     }
 200 |                     .buttonStyle(.plain)
 201 | 
 202 |                     Button(action: { toggleSort(column: .games) }) {
 203 |                         Text("Games\(sortIndicator(for: .games))")
 204 |                             .frame(width: 50)
 205 |                     }
 206 |                     .buttonStyle(.plain)
 207 | 
 208 |                     Button(action: { toggleSort(column: .first) }) {
 209 |                         Text("1st\(sortIndicator(for: .first))")
 210 |                             .frame(width: 40)
 211 |                     }
 212 |                     .buttonStyle(.plain)
 213 | 
 214 |                     Button(action: { toggleSort(column: .second) }) {
 215 |                         Text("2nd\(sortIndicator(for: .second))")
 216 |                             .frame(width: 40)
 217 |                     }
 218 |                     .buttonStyle(.plain)
 219 | 
 220 |                     Button(action: { toggleSort(column: .third) }) {
 221 |                         Text("3rd\(sortIndicator(for: .third))")
 222 |                             .frame(width: 40)
 223 |                     }
 224 |                     .buttonStyle(.plain)
 225 | 
 226 |                     Button(action: { toggleSort(column: .rank) }) {
 227 |                         Text("Rank\(sortIndicator(for: .rank))")
 228 |                             .frame(width: 50)
 229 |                     }
 230 |                     .buttonStyle(.plain)
 231 |                 }
 232 |                 .font(.caption)
 233 |                 .bold()
 234 |             }
 235 | 
 236 |             ForEach(stats) { stat in
 237 |                 HStack {
 238 |                     Text(stat.displayName)
 239 |                         .frame(maxWidth: .infinity, alignment: .leading)
 240 | 
 241 |                     Text("\(stat.gamesPlayed)").frame(width: 50)
 242 |                     Text("\(stat.firstPlace)").frame(width: 40)
 243 |                     Text("\(stat.secondPlace)").frame(width: 40)
 244 |                     Text("\(stat.thirdPlace)").frame(width: 40)
 245 | 
 246 |                     Text("\(stat.rank)")
 247 |                         .frame(width: 50)
 248 |                         .bold()
 249 |                 }
 250 |                 .font(.body)
 251 |             }
 252 |         }
 253 |     }
 254 | 
 255 |     private func resetSelectedEvent() {
 256 |         guard let selectedEventId,
 257 |               let event = allEvents.first(where: { $0.id == selectedEventId }) else {
 258 |             return
 259 |         }
 260 | 
 261 |         do {
 262 |             try EventEngine(context: context).resetEvent(event)
 263 |             message = "Event '\(event.name)' has been reset successfully."
 264 |             showMessage = true
 265 |         } catch {
 266 |             message = error.localizedDescription
 267 |             showMessage = true
 268 |         }
 269 |     }
 270 | }
 271 | 
 272 | // MARK: - Stats Model
 273 | 
 274 | private struct PlayerStats: Identifiable {
 275 |     let id = UUID()
 276 |     let personId: UUID
 277 |     var displayName: String = ""
 278 |     var gamesPlayed: Int = 0
 279 |     var firstPlace: Int = 0
 280 |     var secondPlace: Int = 0
 281 |     var thirdPlace: Int = 0
 282 |     var totalPoints: Int = 0
 283 |     var rank: Int = 0
 284 | }
 285 | 
 286 | #Preview {
 287 |     NavigationStack {
 288 |         EventStatsView()
 289 |     }
 290 |     .modelContainer(for: [Event.self, Person.self])
 291 |     .environmentObject(ThemeManager())
 292 | }


END FILE: ./Christmas Games/EventStatsView.swift


################################################################################
START FILE: ./Christmas Games/EventEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | final class EventEngine {
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     // MARK: - Participants
  13 | 
  14 |     func setParticipants(for event: Event, participantIds: [UUID]) throws {
  15 |         event.participantIds = participantIds
  16 |         touch(event)
  17 |         try context.save()
  18 |     }
  19 | 
  20 |     // MARK: - Event Games: Import / Add / Remove
  21 | 
  22 |     /// Imports all GameTemplate rows into the given Event as EventGame rows.
  23 |     /// Idempotent: re-running does NOT create duplicates.
  24 |     func importAllCatalogGames(into event: Event) throws {
  25 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  26 |         let existingTemplateIds = Set(event.eventGames.map { $0.gameTemplateId })
  27 | 
  28 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  29 |         var nextIndex = maxIndex + 1
  30 | 
  31 |         for template in templates {
  32 |             guard !existingTemplateIds.contains(template.id) else { continue }
  33 | 
  34 |             let eg = EventGame(
  35 |                 event: event,
  36 |                 gameTemplateId: template.id,
  37 |                 orderIndex: nextIndex
  38 |             )
  39 |             nextIndex += 1
  40 | 
  41 |             context.insert(eg)
  42 |             event.eventGames.append(eg)
  43 |         }
  44 | 
  45 |         touch(event)
  46 |         try context.save()
  47 |     }
  48 | 
  49 |     /// Adds a single template to the event (no duplicates).
  50 |     func addGameTemplate(_ template: GameTemplate, to event: Event) throws {
  51 |         let exists = event.eventGames.contains(where: { $0.gameTemplateId == template.id })
  52 |         guard !exists else { return }
  53 | 
  54 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  55 |         let eg = EventGame(
  56 |             event: event,
  57 |             gameTemplateId: template.id,
  58 |             orderIndex: maxIndex + 1
  59 |         )
  60 | 
  61 |         context.insert(eg)
  62 |         event.eventGames.append(eg)
  63 | 
  64 |         touch(event)
  65 |         try context.save()
  66 |     }
  67 | 
  68 |     /// Removes an EventGame from the event.
  69 |     func removeEventGame(_ eventGame: EventGame, from event: Event) throws {
  70 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
  71 |         context.delete(eventGame)
  72 | 
  73 |         // If you removed the current game, clear pointer
  74 |         if event.currentEventGameId == eventGame.id {
  75 |             event.currentEventGameId = nil
  76 |         }
  77 | 
  78 |         touch(event)
  79 |         try context.save()
  80 |     }
  81 | 
  82 |     // MARK: - Skip Current Game
  83 |     
  84 |     /// Skip current game and start a new random game, keeping same players
  85 |     func skipToNextGame(_ currentGame: EventGame, keepingPlayers playerIds: [UUID]) throws {
  86 |         guard let event = currentGame.event else { return }
  87 |         
  88 |         // Mark current game as completed (skipped)
  89 |         currentGame.status = .completed
  90 |         
  91 |         // Pick next random game
  92 |         guard let nextGame = try pickNextGameRandom(event: event) else {
  93 |             // No more games available
  94 |             event.status = .completed
  95 |             event.currentEventGameId = nil
  96 |             touch(event)
  97 |             try context.save()
  98 |             return
  99 |         }
 100 |         
 101 |         // Start the new game
 102 |         event.status = .active
 103 |         event.currentEventGameId = nextGame.id
 104 |         nextGame.status = .inProgress
 105 |         
 106 |         // Create round 0 if none exist
 107 |         if nextGame.rounds.isEmpty {
 108 |             let r = Round(eventGame: nextGame, roundIndex: 0, teams: [])
 109 |             context.insert(r)
 110 |             nextGame.rounds.append(r)
 111 |         }
 112 |         
 113 |         // Generate teams with preferred players
 114 |         if let currentRound = nextGame.rounds.first(where: { $0.completedAt == nil }) {
 115 |             let fairness = FairnessEngine(context: context)
 116 |             let teams = try fairness.generateTeamsWithPreferredPlayers(
 117 |                 for: currentRound,
 118 |                 in: event,
 119 |                 preferredPlayers: playerIds
 120 |             )
 121 |             currentRound.teams = teams
 122 |         }
 123 |         
 124 |         touch(event)
 125 |         try context.save()
 126 |     }
 127 | 
 128 |     // MARK: - Event Lifecycle
 129 | 
 130 |     func startEvent(_ event: Event) throws {
 131 |         // Starting the event means: mark active and immediately start the next game.
 132 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 133 | 
 134 |         event.status = .active
 135 | 
 136 |         if let next = try pickNextGameRandom(event: event) {
 137 |             try start(event: event, eventGame: next)
 138 |         }
 139 | 
 140 |         touch(event)
 141 |         try context.save()
 142 |     }
 143 | 
 144 |     func pauseEvent(_ event: Event) throws {
 145 |         event.status = .paused
 146 |         touch(event)
 147 |         try context.save()
 148 |     }
 149 | 
 150 |     // MARK: - Reset Event
 151 | 
 152 | func resetEvent(_ event: Event) throws {
 153 |     // Delete all rounds from all games
 154 |     for eventGame in event.eventGames {
 155 |         for round in eventGame.rounds {
 156 |             context.delete(round)
 157 |         }
 158 |         eventGame.rounds.removeAll()
 159 |         eventGame.status = .notStarted
 160 |     }
 161 |     
 162 |     // Reset event state
 163 |     event.status = .available
 164 |     event.currentEventGameId = nil
 165 |     
 166 |     touch(event)
 167 |     try context.save()
 168 | }
 169 |     
 170 |     func resumeEvent(_ event: Event) throws {
 171 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 172 | 
 173 |         event.status = .active
 174 | 
 175 |         // If there is no current game (or it is completed), start the next game.
 176 |         let current = event.currentEventGameId.flatMap { id in
 177 |             event.eventGames.first(where: { $0.id == id })
 178 |         }
 179 | 
 180 |         if current == nil || current?.status == .completed {
 181 |             if let next = try pickNextGameRandom(event: event) {
 182 |                 try start(event: event, eventGame: next)
 183 |             } else {
 184 |                 event.status = .completed
 185 |                 event.currentEventGameId = nil
 186 |             }
 187 |         }
 188 | 
 189 |         touch(event)
 190 |         try context.save()
 191 |     }
 192 | 
 193 |     /// Starts a specific EventGame:
 194 |     /// - sets event active
 195 |     /// - sets currentEventGameId
 196 |     /// - sets game status to inProgress
 197 |     /// - creates round 0 if missing
 198 |     func start(event: Event, eventGame: EventGame) throws {
 199 |         // Must have participants to play
 200 |         guard !event.participantIds.isEmpty else {
 201 |             throw StartError.noParticipants
 202 |         }
 203 | 
 204 |         // Resolve template to know defaultRoundsPerGame
 205 |         guard try fetchTemplate(id: eventGame.gameTemplateId) != nil else {
 206 |             throw StartError.missingTemplate
 207 |         }
 208 | 
 209 |         event.status = .active
 210 |         event.currentEventGameId = eventGame.id
 211 |         eventGame.status = .inProgress
 212 | 
 213 |         // Create round 0 if no rounds exist, OR if all rounds are completed
 214 |         let hasActiveRound = eventGame.rounds.contains { $0.completedAt == nil }
 215 |         if eventGame.rounds.isEmpty || !hasActiveRound {
 216 |             let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 217 |             let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 218 |             context.insert(r)
 219 |             eventGame.rounds.append(r)
 220 |         }
 221 | 
 222 |         touch(event)
 223 |         try context.save()
 224 |     }
 225 |     
 226 |     // MARK: - Game / Round progression
 227 | 
 228 |     func createNextRound(for eventGame: EventGame) throws -> Round {
 229 |         let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 230 |         let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 231 |         r.eventGame = eventGame  // Explicitly set inverse relationship
 232 |         context.insert(r)
 233 |         eventGame.rounds.append(r)
 234 | 
 235 |         if let event = eventGame.event {
 236 |             touch(event)
 237 |         }
 238 |         try context.save()
 239 |         return r
 240 |     }
 241 | 
 242 |     func completeGame(_ eventGame: EventGame) throws {
 243 |         eventGame.status = .completed
 244 |         if let event = eventGame.event {
 245 |             // If the completed game was current, clear pointer (next game will set it)
 246 |             if event.currentEventGameId == eventGame.id {
 247 |                 event.currentEventGameId = nil
 248 |             }
 249 |             touch(event)
 250 |         }
 251 |         try context.save()
 252 |     }
 253 | 
 254 |     func pickNextGameRandom(event: Event) throws -> EventGame? {
 255 |         let remaining = event.eventGames.filter { $0.status == .notStarted }
 256 |         guard !remaining.isEmpty else { return nil }
 257 | 
 258 |         // Simple variety heuristic: prefer a different group than the last completed game.
 259 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
 260 |         let templateById = Dictionary(uniqueKeysWithValues: templates.map { ($0.id, $0) })
 261 | 
 262 |         let lastCompleted = event.eventGames
 263 |             .filter { $0.status == .completed }
 264 |             .sorted { ($0.orderIndex) > ($1.orderIndex) }
 265 |             .first
 266 | 
 267 |         let lastGroup = lastCompleted.flatMap { templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines) }
 268 | 
 269 |         if let lastGroup, !lastGroup.isEmpty {
 270 |             let differentGroup = remaining.filter {
 271 |                 let g = templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 272 |                 return (g?.isEmpty == false) ? (g != lastGroup) : true
 273 |             }
 274 |             if let pick = differentGroup.randomElement() {
 275 |                 return pick
 276 |             }
 277 |         }
 278 | 
 279 |         return remaining.randomElement()
 280 |     }
 281 | 
 282 |     func pushGameToLater(_ eventGame: EventGame) throws {
 283 |         guard let event = eventGame.event else { return }
 284 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
 285 |         eventGame.orderIndex = maxIndex + 1
 286 |         touch(event)
 287 |         try context.save()
 288 |     }
 289 | 
 290 |     func removeGameFromEvent(_ eventGame: EventGame) throws {
 291 |         guard let event = eventGame.event else {
 292 |             context.delete(eventGame)
 293 |             try context.save()
 294 |             return
 295 |         }
 296 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
 297 |         context.delete(eventGame)
 298 |         if event.currentEventGameId == eventGame.id {
 299 |             event.currentEventGameId = nil
 300 |         }
 301 |         touch(event)
 302 |         try context.save()
 303 |     }
 304 | 
 305 |     // MARK: - Teams / Rounds
 306 | 
 307 |     func generateTeams(for round: Round) throws {
 308 |         guard let eventGame = round.eventGame, let event = eventGame.event else { return }
 309 | 
 310 |         let fairness = FairnessEngine(context: context)
 311 |         let teams = try fairness.generateTeams(for: round, in: event)
 312 | 
 313 |         round.teams = teams
 314 |         touch(event)
 315 |         try context.save()
 316 |     }
 317 | 
 318 |     func swapPlayer(in round: Round, from outgoing: UUID, to incoming: UUID) throws {
 319 |         var updated = round.teams
 320 |         guard let teamIndex = updated.firstIndex(where: { $0.memberPersonIds.contains(outgoing) }) else { return }
 321 | 
 322 |         var team = updated[teamIndex]
 323 |         team.memberPersonIds = team.memberPersonIds.map { $0 == outgoing ? incoming : $0 }
 324 |         updated[teamIndex] = team
 325 |         round.teams = updated
 326 | 
 327 |         if let event = round.eventGame?.event {
 328 |             touch(event)
 329 |         }
 330 |         try context.save()
 331 |     }
 332 | 
 333 |     func finalizeRound(_ round: Round, winnerTeamId: UUID?) throws {
 334 |     round.completedAt = Date()
 335 | 
 336 |     // Calculate placements for all participants
 337 |     var placements: [UUID: Int] = [:]
 338 |     
 339 |     if let winnerTeamId {
 340 |         // Winner case
 341 |         round.resultType = .win
 342 |         round.winningTeamId = winnerTeamId
 343 |         
 344 |         // Assign placements
 345 |         for team in round.teams {
 346 |             let placement = (team.id == winnerTeamId) ? 1 : 2
 347 |             for personId in team.memberPersonIds {
 348 |                 placements[personId] = placement
 349 |             }
 350 |         }
 351 |     } else {
 352 |         // Tie case - everyone gets 1st place
 353 |         round.resultType = .tie
 354 |         round.winningTeamId = nil
 355 |         
 356 |         for team in round.teams {
 357 |             for personId in team.memberPersonIds {
 358 |                 placements[personId] = 1
 359 |             }
 360 |         }
 361 |     }
 362 |     
 363 |     round.placements = placements
 364 | 
 365 |     if let event = round.eventGame?.event {
 366 |         touch(event)
 367 |     }
 368 |     try context.save()
 369 | }
 370 | 
 371 |     // MARK: - Helpers
 372 | 
 373 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 374 |         let descriptor = FetchDescriptor<GameTemplate>()
 375 |         let templates = try context.fetch(descriptor)
 376 |         return templates.first(where: { $0.id == id })
 377 |     }
 378 | 
 379 |     private func touch(_ event: Event) {
 380 |         event.lastModifiedAt = Date()
 381 |     }
 382 | 
 383 |     enum StartError: LocalizedError {
 384 |         case noParticipants
 385 |         case missingTemplate
 386 |         case invalidRoundCount
 387 | 
 388 |         var errorDescription: String? {
 389 |             switch self {
 390 |             case .noParticipants:
 391 |                 return "No players selected for this event. Add players before starting a game."
 392 |             case .missingTemplate:
 393 |                 return "The selected game template could not be found in the catalog."
 394 |             case .invalidRoundCount:
 395 |                 return "This game has an invalid number of rounds."
 396 |             }
 397 |         }
 398 |     }
 399 | }


END FILE: ./Christmas Games/EventEngine.swift


################################################################################
START FILE: ./Christmas Games/CurrentEventStatsSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | /// Shows live stats for a specific event in a dismissible sheet
   5 | struct CurrentEventStatsSheet: View {
   6 |     @Environment(\.dismiss) private var dismiss
   7 |     @Environment(\.modelContext) private var context
   8 |     @EnvironmentObject var themeManager: ThemeManager
   9 |     
  10 |     let event: Event
  11 |     
  12 |     @Query(sort: \Person.displayName)
  13 |     private var people: [Person]
  14 |     
  15 |     @State private var sortColumn: SortColumn = .rank
  16 |     @State private var sortAscending: Bool = true
  17 |     
  18 |     enum SortColumn {
  19 |         case name, games, first, second, third, rank
  20 |     }
  21 |     
  22 |     var body: some View {
  23 |         NavigationStack {
  24 |             ZStack {
  25 |                 themeManager.background
  26 |                     .ignoresSafeArea()
  27 |                 
  28 |                 if let stats = calculatedStats {
  29 |                     statsTable(stats: stats)
  30 |                         .scrollContentBackground(.hidden)
  31 |                 } else {
  32 |                     ContentUnavailableView(
  33 |                         "No Stats Yet",
  34 |                         systemImage: "chart.bar",
  35 |                         description: Text("Play some games to see statistics.")
  36 |                     )
  37 |                     .padding()
  38 |                 }
  39 |             }
  40 |             .navigationTitle("Current Leaderboard")
  41 |             .navigationBarTitleDisplayMode(.inline)
  42 |             .toolbar {
  43 |                 ToolbarItem(placement: .topBarTrailing) {
  44 |                     Button("Done") {
  45 |                         dismiss()
  46 |                     }
  47 |                     .foregroundColor(themeManager.primary)
  48 |                 }
  49 |             }
  50 |         }
  51 |     }
  52 |     
  53 |     private var calculatedStats: [PlayerStats]? {
  54 |         var statsDict: [UUID: PlayerStats] = [:]
  55 |         
  56 |         for eventGame in event.eventGames {
  57 |             for round in eventGame.rounds where round.completedAt != nil {
  58 |                 // Process placements
  59 |                 for (personId, placement) in round.placements {
  60 |                     var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  61 |                     stat.gamesPlayed += 1
  62 |                     
  63 |                     switch placement {
  64 |                     case 1: stat.firstPlace += 1
  65 |                     case 2: stat.secondPlace += 1
  66 |                     case 3: stat.thirdPlace += 1
  67 |                     default: break
  68 |                     }
  69 |                     
  70 |                     statsDict[personId] = stat
  71 |                 }
  72 |                 
  73 |                 // Handle ties (when resultType == .tie and winningTeamId == nil)
  74 |                 if round.resultType == .tie, round.winningTeamId == nil {
  75 |                     for team in round.teams {
  76 |                         for personId in team.memberPersonIds {
  77 |                             var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  78 |                             if round.placements[personId] == nil {
  79 |                                 stat.gamesPlayed += 1
  80 |                             }
  81 |                             stat.firstPlace += 1 // Tie counts as 1st place for all
  82 |                             statsDict[personId] = stat
  83 |                         }
  84 |                     }
  85 |                 }
  86 |             }
  87 |         }
  88 |         
  89 |         guard !statsDict.isEmpty else { return nil }
  90 |         
  91 |         let peopleById = Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
  92 |         
  93 |         var result = statsDict.values.map { stat -> PlayerStats in
  94 |             var s = stat
  95 |             s.displayName = peopleById[stat.personId]?.displayName ?? "Unknown"
  96 |             s.totalPoints = (s.firstPlace * 3) + (s.secondPlace * 2) + (s.thirdPlace * 1)
  97 |             return s
  98 |         }
  99 |         
 100 |         // Apply sorting based on selected column
 101 |         switch sortColumn {
 102 |         case .name:
 103 |             result.sort { lhs, rhs in
 104 |                 sortAscending 
 105 |                     ? lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedAscending
 106 |                     : lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedDescending
 107 |             }
 108 |         case .games:
 109 |             result.sort { sortAscending ? $0.gamesPlayed < $1.gamesPlayed : $0.gamesPlayed > $1.gamesPlayed }
 110 |         case .first:
 111 |             result.sort { sortAscending ? $0.firstPlace < $1.firstPlace : $0.firstPlace > $1.firstPlace }
 112 |         case .second:
 113 |             result.sort { sortAscending ? $0.secondPlace < $1.secondPlace : $0.secondPlace > $1.secondPlace }
 114 |         case .third:
 115 |             result.sort { sortAscending ? $0.thirdPlace < $1.thirdPlace : $0.thirdPlace > $1.thirdPlace }
 116 |         case .rank:
 117 |             result.sort { sortAscending ? $0.totalPoints < $1.totalPoints : $0.totalPoints > $1.totalPoints }
 118 |         }
 119 |         
 120 |         // Assign ranks based on points (for display)
 121 |         let rankedByPoints = result.sorted { $0.totalPoints > $1.totalPoints }
 122 |         var rankMap: [UUID: Int] = [:]
 123 |         for (index, stat) in rankedByPoints.enumerated() {
 124 |             rankMap[stat.personId] = index + 1
 125 |         }
 126 |         
 127 |         for i in 0..<result.count {
 128 |             result[i].rank = rankMap[result[i].personId] ?? 0
 129 |         }
 130 |         
 131 |         return result
 132 |     }
 133 |     
 134 |     private func toggleSort(column: SortColumn) {
 135 |         if sortColumn == column {
 136 |             sortAscending.toggle()
 137 |         } else {
 138 |             sortColumn = column
 139 |             sortAscending = column == .name ? true : false // Name defaults to A-Z, numbers default to high-to-low
 140 |         }
 141 |     }
 142 |     
 143 |     private func sortIndicator(for column: SortColumn) -> String {
 144 |         guard sortColumn == column else { return "" }
 145 |         return sortAscending ? " ↑" : " ↓"
 146 |     }
 147 |     
 148 |     private func statsTable(stats: [PlayerStats]) -> some View {
 149 |         List {
 150 |             Section {
 151 |                 HStack {
 152 |                     Button(action: { toggleSort(column: .name) }) {
 153 |                         Text("Name\(sortIndicator(for: .name))")
 154 |                             .frame(maxWidth: .infinity, alignment: .leading)
 155 |                     }
 156 |                     .buttonStyle(.plain)
 157 |                     
 158 |                     Button(action: { toggleSort(column: .games) }) {
 159 |                         Text("Games\(sortIndicator(for: .games))")
 160 |                             .frame(width: 50)
 161 |                     }
 162 |                     .buttonStyle(.plain)
 163 |                     
 164 |                     Button(action: { toggleSort(column: .first) }) {
 165 |                         Text("1st\(sortIndicator(for: .first))")
 166 |                             .frame(width: 40)
 167 |                     }
 168 |                     .buttonStyle(.plain)
 169 |                     
 170 |                     Button(action: { toggleSort(column: .second) }) {
 171 |                         Text("2nd\(sortIndicator(for: .second))")
 172 |                             .frame(width: 40)
 173 |                     }
 174 |                     .buttonStyle(.plain)
 175 |                     
 176 |                     Button(action: { toggleSort(column: .third) }) {
 177 |                         Text("3rd\(sortIndicator(for: .third))")
 178 |                             .frame(width: 40)
 179 |                     }
 180 |                     .buttonStyle(.plain)
 181 |                     
 182 |                     Button(action: { toggleSort(column: .rank) }) {
 183 |                         Text("Rank\(sortIndicator(for: .rank))")
 184 |                             .frame(width: 50)
 185 |                     }
 186 |                     .buttonStyle(.plain)
 187 |                 }
 188 |                 .font(.caption)
 189 |                 .bold()
 190 |             }
 191 |             
 192 |             ForEach(stats) { stat in
 193 |                 HStack {
 194 |                     Text(stat.displayName)
 195 |                         .frame(maxWidth: .infinity, alignment: .leading)
 196 |                     Text("\(stat.gamesPlayed)").frame(width: 50)
 197 |                     Text("\(stat.firstPlace)").frame(width: 40)
 198 |                     Text("\(stat.secondPlace)").frame(width: 40)
 199 |                     Text("\(stat.thirdPlace)").frame(width: 40)
 200 |                     Text("\(stat.rank)")
 201 |                         .frame(width: 50)
 202 |                         .bold()
 203 |                 }
 204 |                 .font(.body)
 205 |             }
 206 |         }
 207 |     }
 208 | }
 209 | 
 210 | // MARK: - Stats Model
 211 | 
 212 | private struct PlayerStats: Identifiable {
 213 |     let id = UUID()
 214 |     let personId: UUID
 215 |     var displayName: String = ""
 216 |     var gamesPlayed: Int = 0
 217 |     var firstPlace: Int = 0
 218 |     var secondPlace: Int = 0
 219 |     var thirdPlace: Int = 0
 220 |     var totalPoints: Int = 0
 221 |     var rank: Int = 0
 222 | }
 223 | 
 224 | #Preview {
 225 |     let config = ModelConfiguration(isStoredInMemoryOnly: true)
 226 |     let container = try! ModelContainer(for: Event.self, Person.self, configurations: config)
 227 |     
 228 |     let event = Event(name: "Test Event")
 229 |     container.mainContext.insert(event)
 230 |     
 231 |     return CurrentEventStatsSheet(event: event)
 232 |         .modelContainer(container)
 233 |         .environmentObject(ThemeManager())
 234 | }


END FILE: ./Christmas Games/CurrentEventStatsSheet.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogExporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogExporter {
   6 | 
   7 |     static func exportToDocuments(
   8 |         context: ModelContext,
   9 |         filename: String = "games",
  10 |         fileExtension: String = "json"
  11 |     ) throws -> URL {
  12 | 
  13 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  14 | 
  15 |         let games: [ExportGameCatalogGame] = templates
  16 |             .map { t in
  17 |                 ExportGameCatalogGame(
  18 |                     externalId: t.externalId,
  19 |                     name: t.name,
  20 |                     groupName: t.groupName,
  21 |                     defaultTeamCount: t.defaultTeamCount,
  22 |                     defaultPlayersPerTeam: t.defaultPlayersPerTeam,
  23 |                     defaultRoundsPerGame: t.defaultRoundsPerGame,
  24 |                     teamType: t.defaultTeamType,
  25 |                     playInstructions: t.playInstructions,
  26 |                     setupInstructions: t.setupInstructions
  27 |                 )
  28 |             }
  29 |             .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
  30 | 
  31 |         let catalog = ExportGameCatalog(games: games)
  32 | 
  33 |         let data = try JSONEncoder().encode(catalog)
  34 | 
  35 |         let url = try documentsURL(filename: filename, fileExtension: fileExtension)
  36 |         try data.write(to: url, options: [.atomic])
  37 | 
  38 |         return url
  39 |     }
  40 | 
  41 |     private static func documentsURL(filename: String, fileExtension: String) throws -> URL {
  42 |         let dir = try FileManager.default.url(
  43 |             for: .documentDirectory,
  44 |             in: .userDomainMask,
  45 |             appropriateFor: nil,
  46 |             create: true
  47 |         )
  48 |         return dir.appendingPathComponent("\(filename).\(fileExtension)")
  49 |     }
  50 | }
  51 | 
  52 | // MARK: - Private JSON DTOs (scoped to exporter)
  53 | 
  54 | private struct ExportGameCatalog: Codable {
  55 |     let games: [ExportGameCatalogGame]
  56 | }
  57 | 
  58 | private struct ExportGameCatalogGame: Codable {
  59 |     let externalId: String
  60 |     let name: String
  61 |     let groupName: String?
  62 |     let defaultTeamCount: Int
  63 |     let defaultPlayersPerTeam: Int
  64 |     let defaultRoundsPerGame: Int
  65 |     let teamType: TeamType
  66 |     let playInstructions: String?
  67 |     let setupInstructions: String?
  68 | }


END FILE: ./Christmas Games/GameCatalogExporter.swift


################################################################################
START FILE: ./Christmas Games/GameSettingsView.swift
################################################################################
   1 | import SwiftUI
   2 | 
   3 | struct GameSettingsView: View {
   4 |     @Environment(\.dismiss) private var dismiss
   5 |     @EnvironmentObject var themeManager: ThemeManager
   6 |     
   7 |     @AppStorage("gameTransitionSound") private var soundEnabled: Bool = true
   8 |     
   9 |     var body: some View {
  10 |         NavigationStack {
  11 |             List {
  12 |                 Section {
  13 |                     Toggle("Celebration Sound", isOn: $soundEnabled)
  14 |                 } header: {
  15 |                     Text("Game Transitions")
  16 |                 } footer: {
  17 |                     Text("Play a sound effect when transitioning between games")
  18 |                 }
  19 |             }
  20 |             .navigationTitle("Settings")
  21 |             .navigationBarTitleDisplayMode(.inline)
  22 |             .toolbar {
  23 |                 ToolbarItem(placement: .topBarTrailing) {
  24 |                     Button("Done") {
  25 |                         dismiss()
  26 |                     }
  27 |                     .foregroundColor(themeManager.primary)
  28 |                 }
  29 |             }
  30 |         }
  31 |     }
  32 | }
  33 | 
  34 | #Preview {
  35 |     GameSettingsView()
  36 |         .environmentObject(ThemeManager())
  37 | }


END FILE: ./Christmas Games/GameSettingsView.swift


################################################################################
START FILE: ./Christmas Games/Christmas_GamesApp.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | @main
   5 | struct Christmas_GamesApp: App {
   6 | 
   7 |     private var sharedModelContainer: ModelContainer = {
   8 |         let schema = Schema([
   9 |             Person.self,
  10 |             GameTemplate.self,
  11 |             Event.self,
  12 |             EventGame.self,
  13 |             Round.self
  14 |         ])
  15 | 
  16 |         let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
  17 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  18 |         try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  19 | 
  20 |         let storeURL = folder.appendingPathComponent("ChristmasGames_v2.store")
  21 | 
  22 |         let configuration = ModelConfiguration(schema: schema, url: storeURL)
  23 | 
  24 |         do {
  25 |             return try ModelContainer(for: schema, configurations: [configuration])
  26 |         } catch {
  27 |             fatalError("Failed to create ModelContainer: \(error)")
  28 |         }
  29 |     }()
  30 | 
  31 |     var body: some Scene {
  32 |         WindowGroup {
  33 |             MainMenuView()
  34 |         }
  35 |         .modelContainer(sharedModelContainer)
  36 |     }
  37 | }


END FILE: ./Christmas Games/Christmas_GamesApp.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct GameCatalogView: View {
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \GameTemplate.name)
   9 |     private var templates: [GameTemplate]
  10 | 
  11 |     @State private var showCreateTemplate = false
  12 |     @State private var showCSVImporter = false
  13 |     @State private var editingTemplate: GameTemplate?
  14 | 
  15 |     @State private var pendingCSVData: Data?
  16 |     @State private var pendingCSVFilename: String?
  17 |     @State private var showCSVPreview = false
  18 | 
  19 |     @State private var alertTitle = "Message"
  20 |     @State private var alertMessage: String?
  21 |     @State private var showAlert = false
  22 |     
  23 |     // Filter and sort state
  24 |     @AppStorage("gameCatalog_filterTeamSize") private var filterTeamSize: Int?
  25 |     @AppStorage("gameCatalog_filterTeamCount") private var filterTeamCount: Int?
  26 |     @AppStorage("gameCatalog_sortOption") private var sortOption: SortOption = .alphabetical
  27 |     @AppStorage("gameCatalog_teamTypeFilter") private var teamTypeFilter: TeamTypeFilter = .all
  28 |     
  29 |     enum SortOption: String, CaseIterable, Codable {
  30 |         case alphabetical = "A-Z"
  31 |         case reverseAlphabetical = "Z-A"
  32 |         case status = "Status"
  33 |     }
  34 |     
  35 |     enum TeamTypeFilter: String, CaseIterable, Codable {
  36 |         case all = "All"
  37 |         case any = "Any"
  38 |         case maleOnly = "Male Only"
  39 |         case femaleOnly = "Female Only"
  40 |         case couplesOnly = "Couples Only"
  41 |     }
  42 | 
  43 |     var body: some View {
  44 |         List {
  45 |             // Filters section
  46 |             Section {
  47 |                 HStack {
  48 |                     Picker("Team Size", selection: $filterTeamSize) {
  49 |                         Text("Any").tag(nil as Int?)
  50 |                         ForEach(availableTeamSizes, id: \.self) { size in
  51 |                             Text("\(size)").tag(size as Int?)
  52 |                         }
  53 |                     }
  54 |                     .pickerStyle(.menu)
  55 |                     
  56 |                     Picker("Teams", selection: $filterTeamCount) {
  57 |                         Text("Any").tag(nil as Int?)
  58 |                         ForEach(availableTeamCounts, id: \.self) { count in
  59 |                             Text("\(count)").tag(count as Int?)
  60 |                         }
  61 |                     }
  62 |                     .pickerStyle(.menu)
  63 |                 }
  64 |                 
  65 |                 HStack {
  66 |                     Picker("Sort", selection: $sortOption) {
  67 |                         ForEach(SortOption.allCases, id: \.self) { option in
  68 |                             Text(option.rawValue).tag(option)
  69 |                         }
  70 |                     }
  71 |                     .pickerStyle(.menu)
  72 |                     
  73 |                     Picker("Team Type", selection: $teamTypeFilter) {
  74 |                         ForEach(TeamTypeFilter.allCases, id: \.self) { filter in
  75 |                             Text(filter.rawValue).tag(filter)
  76 |                         }
  77 |                     }
  78 |                     .pickerStyle(.menu)
  79 |                 }
  80 |             } header: {
  81 |                 Text("Games (\(filteredAndSortedTemplates.count))")
  82 |             }
  83 |             
  84 |             // Games list
  85 |             Section {
  86 |                 ForEach(filteredAndSortedTemplates) { template in
  87 |                     Button {
  88 |                         editingTemplate = template
  89 |                     } label: {
  90 |                         gameRow(for: template)
  91 |                     }
  92 |                 }
  93 |                 .onDelete(perform: deleteTemplates)
  94 |             }
  95 |         }
  96 |         .navigationTitle("Game Catalog")
  97 |         .toolbar {
  98 |             ToolbarItemGroup(placement: .topBarTrailing) {
  99 |                 Button("Add") { showCreateTemplate = true }
 100 |                 Button("Import CSV") { showCSVImporter = true }
 101 |             }
 102 |         }
 103 |         .sheet(isPresented: $showCreateTemplate) {
 104 |             CreateGameTemplateSheet { _ in }
 105 |         }
 106 |         .sheet(item: $editingTemplate) { template in
 107 |             EditGameTemplateSheet(template: template)
 108 |         }
 109 |         .fileImporter(
 110 |             isPresented: $showCSVImporter,
 111 |             allowedContentTypes: [UTType.commaSeparatedText],
 112 |             allowsMultipleSelection: false
 113 |         ) { result in
 114 |             do {
 115 |                 let urls = try result.get()
 116 |                 guard let url = urls.first else { return }
 117 | 
 118 |                 let didStart = url.startAccessingSecurityScopedResource()
 119 |                 defer { if didStart { url.stopAccessingSecurityScopedResource() } }
 120 | 
 121 |                 let data = try Data(contentsOf: url)
 122 | 
 123 |                 pendingCSVData = data
 124 |                 pendingCSVFilename = url.lastPathComponent
 125 |                 showCSVPreview = true
 126 | 
 127 |             } catch {
 128 |                 alertTitle = "Import failed"
 129 |                 alertMessage = error.localizedDescription
 130 |                 showAlert = true
 131 |             }
 132 |         }
 133 |         .sheet(isPresented: $showCSVPreview) {
 134 |             if let data = pendingCSVData {
 135 |                 CSVImportPreviewSheet(csvData: data, filename: pendingCSVFilename)
 136 |             } else {
 137 |                 Text("No CSV loaded.")
 138 |                     .padding()
 139 |             }
 140 |         }
 141 |         .alert(alertTitle, isPresented: $showAlert) {
 142 |             Button("OK", role: .cancel) { }
 143 |         } message: {
 144 |             Text(alertMessage ?? "Unknown error")
 145 |         }
 146 |     }
 147 |     
 148 |     // MARK: - Computed Properties
 149 |     
 150 |     private var availableTeamSizes: [Int] {
 151 |         Set(templates.map { $0.defaultPlayersPerTeam }).sorted()
 152 |     }
 153 |     
 154 |     private var availableTeamCounts: [Int] {
 155 |         Set(templates.map { $0.defaultTeamCount }).sorted()
 156 |     }
 157 |     
 158 |     private var filteredAndSortedTemplates: [GameTemplate] {
 159 |         var result = templates
 160 |         
 161 |         // Apply team size filter
 162 |         if let filterTeamSize {
 163 |             result = result.filter { $0.defaultPlayersPerTeam == filterTeamSize }
 164 |         }
 165 |         
 166 |         // Apply team count filter
 167 |         if let filterTeamCount {
 168 |             result = result.filter { $0.defaultTeamCount == filterTeamCount }
 169 |         }
 170 |         
 171 |         // Apply team type filter
 172 |         switch teamTypeFilter {
 173 |         case .all:
 174 |             break
 175 |         case .any:
 176 |             result = result.filter { $0.defaultTeamType == .any }
 177 |         case .maleOnly:
 178 |             result = result.filter { $0.defaultTeamType == .maleOnly }
 179 |         case .femaleOnly:
 180 |             result = result.filter { $0.defaultTeamType == .femaleOnly }
 181 |         case .couplesOnly:
 182 |             result = result.filter { $0.defaultTeamType == .couplesOnly }
 183 |         }
 184 |         
 185 |         // Apply sort
 186 |         switch sortOption {
 187 |         case .alphabetical:
 188 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
 189 |         case .reverseAlphabetical:
 190 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedDescending }
 191 |         case .status:
 192 |             // For GameCatalog, we can sort by group name as a proxy for "status"
 193 |             result.sort { lhs, rhs in
 194 |                 let lGroup = lhs.groupName ?? ""
 195 |                 let rGroup = rhs.groupName ?? ""
 196 |                 if lGroup != rGroup {
 197 |                     return lGroup.localizedCaseInsensitiveCompare(rGroup) == .orderedAscending
 198 |                 }
 199 |                 return lhs.name.localizedCaseInsensitiveCompare(rhs.name) == .orderedAscending
 200 |             }
 201 |         }
 202 |         
 203 |         return result
 204 |     }
 205 |     
 206 |     private func gameRow(for template: GameTemplate) -> some View {
 207 |         VStack(alignment: .leading, spacing: 4) {
 208 |             Text(template.name)
 209 |                 .font(.body)
 210 |                 .foregroundStyle(.primary)
 211 |             
 212 |             HStack {
 213 |                 if let group = template.groupName?.trimmingCharacters(in: .whitespacesAndNewlines),
 214 |                    !group.isEmpty {
 215 |                     Text(group)
 216 |                         .font(.footnote)
 217 |                         .foregroundStyle(.secondary)
 218 |                     Text("•")
 219 |                         .font(.footnote)
 220 |                         .foregroundStyle(.secondary)
 221 |                 }
 222 |                 
 223 |                 Text("Teams: \(template.defaultTeamCount) × \(template.defaultPlayersPerTeam)")
 224 |                     .font(.footnote)
 225 |                     .foregroundStyle(.secondary)
 226 |                 
 227 |                 Text("•")
 228 |                     .font(.footnote)
 229 |                     .foregroundStyle(.secondary)
 230 |                 
 231 |                 Text("Rounds: \(template.defaultRoundsPerGame)")
 232 |                     .font(.footnote)
 233 |                     .foregroundStyle(.secondary)
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func deleteTemplates(at offsets: IndexSet) {
 239 |         for index in offsets {
 240 |             let template = filteredAndSortedTemplates[index]
 241 |             if let original = templates.first(where: { $0.id == template.id }) {
 242 |                 context.delete(original)
 243 |             }
 244 |         }
 245 |         try? context.save()
 246 |     }
 247 | }
 248 | 
 249 | // MARK: - Edit Game Template Sheet
 250 | 
 251 | private struct EditGameTemplateSheet: View {
 252 |     @Environment(\.dismiss) private var dismiss
 253 |     @Environment(\.modelContext) private var context
 254 | 
 255 |     let template: GameTemplate
 256 | 
 257 |     @State private var name = ""
 258 |     @State private var groupName = ""
 259 |     @State private var defaultTeamCount = 2
 260 |     @State private var defaultPlayersPerTeam = 2
 261 |     @State private var defaultRoundsPerGame = 1
 262 |     @State private var teamType: TeamType = .any
 263 |     @State private var playInstructions = ""
 264 |     @State private var setupInstructions = ""
 265 | 
 266 |     var body: some View {
 267 |         NavigationStack {
 268 |             Form {
 269 |                 Section("Basic") {
 270 |                     TextField("Name", text: $name)
 271 |                     TextField("Group (optional)", text: $groupName)
 272 |                 }
 273 | 
 274 |                 Section("Defaults") {
 275 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
 276 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
 277 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
 278 | 
 279 |                     Picker("Team Type", selection: $teamType) {
 280 |                         Text("Any").tag(TeamType.any)
 281 |                         Text("Male Only").tag(TeamType.maleOnly)
 282 |                         Text("Female Only").tag(TeamType.femaleOnly)
 283 |                         Text("Couples Only").tag(TeamType.couplesOnly)
 284 |                     }
 285 |                 }
 286 | 
 287 |                 Section("Instructions") {
 288 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
 289 |                         .lineLimit(3...8)
 290 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
 291 |                         .lineLimit(3...8)
 292 |                 }
 293 |             }
 294 |             .navigationTitle("Edit Game Template")
 295 |             .toolbar {
 296 |                 ToolbarItem(placement: .topBarLeading) {
 297 |                     Button("Cancel") { dismiss() }
 298 |                 }
 299 | 
 300 |                 ToolbarItem(placement: .topBarTrailing) {
 301 |                     Button("Save") { save() }
 302 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 303 |                 }
 304 |             }
 305 |             .onAppear {
 306 |                 name = template.name
 307 |                 groupName = template.groupName ?? ""
 308 |                 defaultTeamCount = template.defaultTeamCount
 309 |                 defaultPlayersPerTeam = template.defaultPlayersPerTeam
 310 |                 defaultRoundsPerGame = template.defaultRoundsPerGame
 311 |                 teamType = template.defaultTeamType
 312 |                 playInstructions = template.playInstructions ?? ""
 313 |                 setupInstructions = template.setupInstructions ?? ""
 314 |             }
 315 |         }
 316 |     }
 317 | 
 318 |     private func save() {
 319 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
 320 |         guard !trimmedName.isEmpty else { return }
 321 | 
 322 |         template.name = trimmedName
 323 |         template.groupName = groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName
 324 |         template.defaultTeamCount = defaultTeamCount
 325 |         template.defaultPlayersPerTeam = defaultPlayersPerTeam
 326 |         template.defaultRoundsPerGame = defaultRoundsPerGame
 327 |         template.defaultTeamType = teamType
 328 |         template.playInstructions = playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions
 329 |         template.setupInstructions = setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
 330 | 
 331 |         try? context.save()
 332 |         dismiss()
 333 |     }
 334 | }
 335 | 
 336 | #Preview {
 337 |     NavigationStack {
 338 |         GameCatalogView()
 339 |     }
 340 |     .modelContainer(for: [GameTemplate.self])
 341 | }


END FILE: ./Christmas Games/GameCatalogView.swift


################################################################################
START FILE: ./Christmas Games/SeedData.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum SeedData {
   5 | 
   6 |     @MainActor
   7 |     static func seedOrUpdateRoster(context: ModelContext) throws {
   8 | 
   9 |         let existing = try context.fetch(FetchDescriptor<Person>())
  10 |         var byName: [String: Person] =
  11 |             Dictionary(uniqueKeysWithValues: existing.map { ($0.displayName, $0) })
  12 | 
  13 |         let legacyNamesToDelete: Set<String> = ["Couple2-A", "Couple2-B"]
  14 |         for person in existing where legacyNamesToDelete.contains(person.displayName) {
  15 |             context.delete(person)
  16 |             byName[person.displayName] = nil
  17 |         }
  18 | 
  19 |         @discardableResult
  20 |         func upsert(
  21 |             _ name: String,
  22 |             sex: String,
  23 |             age: Int,
  24 |             weight: Int,
  25 |             athleticAbility: Int,
  26 |             height: String
  27 |         ) -> Person {
  28 | 
  29 |             if let p = byName[name] {
  30 |                 p.sex = sex
  31 |                 p.age = age
  32 |                 p.weight = weight
  33 |                 p.athleticAbility = athleticAbility
  34 |                 p.height = height
  35 |                 p.isActive = true
  36 |                 
  37 |                 // Set categories from detailed values
  38 |                 p.weightCategory = categoryForWeight(weight)
  39 |                 p.heightCategory = categoryForHeight(height)
  40 |                 
  41 |                 return p
  42 |             } else {
  43 |                 let p = Person(
  44 |                     displayName: name,
  45 |                     sex: sex,
  46 |                     age: age,
  47 |                     weight: weight,
  48 |                     athleticAbility: athleticAbility,
  49 |                     height: height,
  50 |                     weightCategory: categoryForWeight(weight),
  51 |                     heightCategory: categoryForHeight(height),
  52 |                     isActive: true
  53 |                 )
  54 |                 context.insert(p)
  55 |                 byName[name] = p
  56 |                 return p
  57 |             }
  58 |         }
  59 | 
  60 |         let dean     = upsert("Dean",     sex: "M", age: 60, weight: 250, athleticAbility: 3, height: #"6'3""#)
  61 |         let shannon  = upsert("Shannon",  sex: "F", age: 57, weight: 150, athleticAbility: 4, height: #"6'"#)
  62 | 
  63 |         let michael  = upsert("Michael",  sex: "M", age: 34, weight: 250, athleticAbility: 3, height: #"6'"#)
  64 |         let brittany = upsert("Brittany", sex: "F", age: 33, weight: 190, athleticAbility: 1, height: #"5'10""#)
  65 | 
  66 |         let blake    = upsert("Blake",    sex: "M", age: 30, weight: 250, athleticAbility: 5, height: #"6'2""#)
  67 |         let brooklin = upsert("Brooklin", sex: "F", age: 30, weight: 140, athleticAbility: 4, height: #"5'2""#)
  68 | 
  69 |         let brandon  = upsert("Brandon",  sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'6""#)
  70 |         let jenna    = upsert("Jenna",    sex: "F", age: 27, weight: 140, athleticAbility: 4, height: #"5'8""#)
  71 | 
  72 |         let hunter   = upsert("Hunter",   sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'5""#)
  73 |         let brooke   = upsert("Brooke",   sex: "F", age: 24, weight: 140, athleticAbility: 5, height: #"5'10""#)
  74 | 
  75 |         func linkSpouses(_ a: Person, _ b: Person) {
  76 |             a.spouseId = b.id
  77 |             b.spouseId = a.id
  78 |         }
  79 | 
  80 |         linkSpouses(dean, shannon)
  81 |         linkSpouses(michael, brittany)
  82 |         linkSpouses(blake, brooklin)
  83 |         linkSpouses(brandon, jenna)
  84 |         linkSpouses(hunter, brooke)
  85 | 
  86 |         try context.save()
  87 |     }
  88 |     
  89 |     // MARK: - Category Mapping
  90 |     
  91 |     private static func categoryForWeight(_ weight: Int) -> String {
  92 |         switch weight {
  93 |         case ..<160: return "S"
  94 |         case 160..<220: return "M"
  95 |         default: return "L"
  96 |         }
  97 |     }
  98 |     
  99 |     private static func categoryForHeight(_ height: String) -> String {
 100 |         // Parse height like "6'3"" → inches
 101 |         let components = height.replacingOccurrences(of: "\"", with: "").split(separator: "'")
 102 |         guard components.count == 2,
 103 |               let feet = Int(components[0]),
 104 |               let inches = Int(components[1]) else {
 105 |             return "M" // Default
 106 |         }
 107 |         
 108 |         let totalInches = (feet * 12) + inches
 109 |         
 110 |         switch totalInches {
 111 |         case ..<67: return "S"  // < 5'7"
 112 |         case 67..<73: return "M" // 5'7" - 6'0"
 113 |         default: return "L"      // > 6'0"
 114 |         }
 115 |     }
 116 | }


END FILE: ./Christmas Games/SeedData.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogCSVImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum GameCatalogCSVImporterError: LocalizedError {
   5 |     case invalidFormat(String)
   6 |     case missingRequiredColumn(String)
   7 | 
   8 |     var errorDescription: String? {
   9 |         switch self {
  10 |         case .invalidFormat(let msg): return msg
  11 |         case .missingRequiredColumn(let col): return "CSV is missing required column: \(col)"
  12 |         }
  13 |     }
  14 | }
  15 | 
  16 | @MainActor
  17 | enum GameCatalogCSVImporter {
  18 | 
  19 |     struct ImportResult {
  20 |         var insertedOrUpdated: Int
  21 |         var skipped: Int
  22 |         var removed: Int
  23 |     }
  24 | 
  25 |     /// Importer tailored for your "Minute to Win It - Head to Head" CSV:
  26 |     /// Required columns:
  27 |     /// - gameId
  28 |     /// - gameName
  29 |     /// - teamType
  30 |     ///
  31 |     /// Optional columns:
  32 |     /// - groupName
  33 |     /// - defaultTeamCount, defaultPlayersPerTeam, defaultRoundsPerGame
  34 |     /// - instructionText
  35 |     /// - Materials, Gather, Purchase, Url (ignored by default)
  36 |     /// - Check (if "x", row is skipped and counted as removed)
  37 |     static func importCSV(context: ModelContext, csvData: Data) throws -> ImportResult {
  38 | 
  39 |         guard let text = String(data: csvData, encoding: .utf8) else {
  40 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file could not be read as UTF-8 text.")
  41 |         }
  42 | 
  43 |         let rawLines = text
  44 |             .split(whereSeparator: \.isNewline)
  45 |             .map(String.init)
  46 |             .filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
  47 | 
  48 |         guard !rawLines.isEmpty else {
  49 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file is empty.")
  50 |         }
  51 | 
  52 |         // 1) Find the header row by detecting the expected columns.
  53 |         guard let headerIndex = rawLines.firstIndex(where: { line in
  54 |             let cols = parseCSVLine(line).map(normalizeHeaderKey)
  55 |             return cols.contains("gameid") && cols.contains("gamename") && cols.contains("teamtype")
  56 |         }) else {
  57 |             let firstLineCols = parseCSVLine(rawLines.first ?? "")
  58 |                 .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
  59 |                 .joined(separator: ", ")
  60 |             throw GameCatalogCSVImporterError.invalidFormat(
  61 |                 "Could not find a valid header row. Expected columns: gameId, gameName, teamType. " +
  62 |                 "First line columns were: \(firstLineCols)"
  63 |             )
  64 |         }
  65 | 
  66 |         let headerCols = parseCSVLine(rawLines[headerIndex])
  67 | 
  68 |         // Build header map; tolerate duplicate column names by keeping first occurrence.
  69 |         var headerMap: [String: Int] = [:]
  70 |         for (idx, name) in headerCols.enumerated() {
  71 |             let key = normalizeHeaderKey(name)
  72 |             if headerMap[key] == nil {
  73 |                 headerMap[key] = idx
  74 |             }
  75 |         }
  76 | 
  77 |         func colIndex(_ key: String, alternatives: [String] = []) -> Int? {
  78 |             if let i = headerMap[normalizeHeaderKey(key)] { return i }
  79 |             for alt in alternatives {
  80 |                 if let i = headerMap[normalizeHeaderKey(alt)] { return i }
  81 |             }
  82 |             return nil
  83 |         }
  84 | 
  85 |         // Required
  86 |         guard let iGameId = colIndex("gameId", alternatives: ["gameid", "id"]) else {
  87 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameId")
  88 |         }
  89 |         guard let iGameName = colIndex("gameName", alternatives: ["gamename", "name"]) else {
  90 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameName")
  91 |         }
  92 |         guard let iTeamType = colIndex("teamType", alternatives: ["teamtype"]) else {
  93 |             throw GameCatalogCSVImporterError.missingRequiredColumn("teamType")
  94 |         }
  95 | 
  96 |         // Optional
  97 |         let iGroupName = colIndex("groupName", alternatives: ["group", "groupname"])
  98 |         let iTeamCount = colIndex("defaultTeamCount", alternatives: ["defaultteamcount"])
  99 |         let iPlayersPerTeam = colIndex("defaultPlayersPerTeam", alternatives: ["defaultplayersperteam"])
 100 |         let iRounds = colIndex("defaultRoundsPerGame", alternatives: ["defaultroundspergame"])
 101 |         let iPlayInstructionText = colIndex("playInstructions", alternatives: ["playinstructions", "playinstructiontext"])
 102 |         let iSetupInstructionText = colIndex("setupInstructions", alternatives: ["setupinstructions", "setupinstructiontext"])
 103 |         let iCheck = colIndex("check", alternatives: ["Check"])
 104 | 
 105 |         var result = ImportResult(insertedOrUpdated: 0, skipped: 0, removed: 0)
 106 | 
 107 |         // 2) Process rows
 108 |         for line in rawLines.dropFirst(headerIndex + 1) {
 109 |             let cols = parseCSVLine(line)
 110 | 
 111 |             guard iGameId < cols.count, iGameName < cols.count, iTeamType < cols.count else {
 112 |                 result.skipped += 1
 113 |                 continue
 114 |             }
 115 | 
 116 |             // Check column: if "x" -> skip/remove
 117 |             if let iCheck, iCheck < cols.count {
 118 |                 let flag = cols[iCheck].trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
 119 |                 if flag == "x" {
 120 |                     result.removed += 1
 121 |                     continue
 122 |                 }
 123 |             }
 124 | 
 125 |             let gameIdRaw = cols[iGameId].trimmingCharacters(in: .whitespacesAndNewlines)
 126 |             let name = cols[iGameName].trimmingCharacters(in: .whitespacesAndNewlines)
 127 | 
 128 |             guard !gameIdRaw.isEmpty, !name.isEmpty else {
 129 |                 result.skipped += 1
 130 |                 continue
 131 |             }
 132 | 
 133 |             // Stable externalId derived from gameId
 134 |             let externalId = "mtwi_\(slug(gameIdRaw))"
 135 | 
 136 |             let groupName: String? = {
 137 |                 guard let iGroupName, iGroupName < cols.count else { return nil }
 138 |                 let g = cols[iGroupName].trimmingCharacters(in: .whitespacesAndNewlines)
 139 |                 return g.isEmpty ? nil : g
 140 |             }()
 141 | 
 142 |             let playInstructions: String? = {
 143 |                 guard let iPlayInstructionText, iPlayInstructionText < cols.count else { return nil }
 144 |                 let t = cols[iPlayInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 145 |                 return t.isEmpty ? nil : t
 146 |             }()
 147 | 
 148 |             let setupInstructions: String? = {
 149 |                 guard let iSetupInstructionText, iSetupInstructionText < cols.count else { return nil }
 150 |                 let t = cols[iSetupInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 151 |                 return t.isEmpty ? nil : t
 152 |             }()
 153 | 
 154 |             let teamType = mapTeamType(cols[iTeamType])
 155 | 
 156 |             let defaultTeamCount = parsePositiveInt(cols, iTeamCount, defaultValue: 2)
 157 |             let defaultPlayersPerTeam = parsePositiveInt(cols, iPlayersPerTeam, defaultValue: 2)
 158 |             let defaultRoundsPerGame = parsePositiveInt(cols, iRounds, defaultValue: 1)
 159 | 
 160 |             let existing = try fetchTemplateByExternalId(context: context, externalId: externalId)
 161 | 
 162 |             if let t = existing {
 163 |                 t.name = name
 164 |                 t.groupName = groupName
 165 |                 t.defaultTeamCount = defaultTeamCount
 166 |                 t.defaultPlayersPerTeam = defaultPlayersPerTeam
 167 |                 t.defaultRoundsPerGame = defaultRoundsPerGame
 168 |                 t.defaultTeamTypeRaw = teamType.rawValue
 169 |                 t.playInstructions = playInstructions
 170 |                 t.setupInstructions = setupInstructions
 171 |                 result.insertedOrUpdated += 1
 172 |             } else {
 173 |                 let t = GameTemplate(
 174 |                     externalId: externalId,
 175 |                     name: name,
 176 |                     groupName: groupName,
 177 |                     defaultTeamCount: defaultTeamCount,
 178 |                     defaultPlayersPerTeam: defaultPlayersPerTeam,
 179 |                     defaultRoundsPerGame: defaultRoundsPerGame,
 180 |                     defaultTeamType: teamType,
 181 |                     playInstructions: playInstructions,
 182 |                     setupInstructions: setupInstructions
 183 |                 )
 184 |                 context.insert(t)
 185 |                 result.insertedOrUpdated += 1
 186 |             }
 187 |         }
 188 | 
 189 |         try context.save()
 190 |         return result
 191 |     }
 192 | 
 193 |     // MARK: - Helpers
 194 | 
 195 |     private static func parsePositiveInt(_ cols: [String], _ index: Int?, defaultValue: Int) -> Int {
 196 |         guard let index, index < cols.count else { return defaultValue }
 197 |         let s = cols[index].trimmingCharacters(in: .whitespacesAndNewlines)
 198 |         if s.isEmpty { return defaultValue }
 199 |         if let v = Int(s), v > 0 { return v }
 200 |         return defaultValue
 201 |     }
 202 | 
 203 |     private static func mapTeamType(_ raw: String) -> TeamType {
 204 |         let n = raw
 205 |             .trimmingCharacters(in: .whitespacesAndNewlines)
 206 |             .lowercased()
 207 |             .replacingOccurrences(of: " ", with: "")
 208 |             .replacingOccurrences(of: "_", with: "")
 209 |             .replacingOccurrences(of: "-", with: "")
 210 | 
 211 |         if n.isEmpty { return .any }
 212 | 
 213 |         switch n {
 214 |         case "any", "anygender", "mixed", "coed", "all":
 215 |             return .any
 216 |         case "maleonly", "menonly", "boysonly", "male", "men":
 217 |             return .maleOnly
 218 |         case "femaleonly", "womenonly", "girlsonly", "female", "women":
 219 |             return .femaleOnly
 220 |         case "couplesonly", "couples", "couple", "spousesonly", "spouse":
 221 |             return .couplesOnly
 222 |         default:
 223 |             return .any
 224 |         }
 225 |     }
 226 | 
 227 |     private static func normalizeHeaderKey(_ s: String) -> String {
 228 |         let lowered = s.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
 229 |         let compact = lowered
 230 |             .replacingOccurrences(of: " ", with: "")
 231 |             .replacingOccurrences(of: "_", with: "")
 232 |         let allowed = compact.unicodeScalars.filter { CharacterSet.alphanumerics.contains($0) }
 233 |         return String(String.UnicodeScalarView(allowed))
 234 |     }
 235 | 
 236 |     private static func slug(_ s: String) -> String {
 237 |         let lowered = s.lowercased()
 238 |         let mapped = lowered.unicodeScalars.map { scalar -> Character in
 239 |             CharacterSet.alphanumerics.contains(scalar) ? Character(scalar) : "-"
 240 |         }
 241 |         let raw = String(mapped)
 242 |         let collapsed = raw
 243 |             .replacingOccurrences(of: "-+", with: "-", options: .regularExpression)
 244 |             .trimmingCharacters(in: CharacterSet(charactersIn: "-"))
 245 |         return collapsed.isEmpty ? UUID().uuidString.lowercased() : collapsed
 246 |     }
 247 | 
 248 |     /// CSV parser with quote handling (supports commas inside quoted fields)
 249 |     private static func parseCSVLine(_ line: String) -> [String] {
 250 |         var result: [String] = []
 251 |         var current = ""
 252 |         var inQuotes = false
 253 |         var i = line.startIndex
 254 | 
 255 |         while i < line.endIndex {
 256 |             let ch = line[i]
 257 | 
 258 |             if ch == "\"" {
 259 |                 let next = line.index(after: i)
 260 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 261 |                     current.append("\"")
 262 |                     i = line.index(after: next)
 263 |                     continue
 264 |                 }
 265 |                 inQuotes.toggle()
 266 |                 i = line.index(after: i)
 267 |                 continue
 268 |             }
 269 | 
 270 |             if ch == ",", !inQuotes {
 271 |                 result.append(current)
 272 |                 current = ""
 273 |                 i = line.index(after: i)
 274 |                 continue
 275 |             }
 276 | 
 277 |             current.append(ch)
 278 |             i = line.index(after: i)
 279 |         }
 280 | 
 281 |         result.append(current)
 282 |         return result
 283 |     }
 284 | 
 285 |     private static func fetchTemplateByExternalId(context: ModelContext, externalId: String) throws -> GameTemplate? {
 286 |         let descriptor = FetchDescriptor<GameTemplate>()
 287 |         let templates = try context.fetch(descriptor)
 288 |         return templates.first(where: { $0.externalId == externalId })
 289 |         }
 290 |     }
 291 | 


END FILE: ./Christmas Games/GameCatalogCSVImporter.swift


################################################################################
START FILE: ./Christmas Games/GameTransitionView.swift
################################################################################
   1 | import SwiftUI
   2 | import AVFoundation
   3 | import AudioToolbox
   4 | 
   5 | /// Animated transition view shown between games
   6 | struct GameTransitionView: View {
   7 |     @EnvironmentObject var themeManager: ThemeManager
   8 |     @AppStorage("gameTransitionSound") private var soundEnabled: Bool = true
   9 | 
  10 |     let onComplete: () -> Void
  11 | 
  12 |     @State private var showConfetti = true
  13 |     @State private var showLoading = false
  14 |     @State private var dotCount = 0
  15 | 
  16 |     @State private var audioPlayer: AVAudioPlayer?
  17 |     
  18 |     
  19 | 
  20 |     var body: some View {
  21 |         ZStack {
  22 |             themeManager.background
  23 |                 .ignoresSafeArea()
  24 | 
  25 |             VStack(spacing: 30) {
  26 |                 Image(systemName: "checkmark.circle.fill")
  27 |                     .font(.system(size: 80))
  28 |                     .foregroundColor(.green)
  29 |                     .scaleEffect(showConfetti ? 1.2 : 0.5)
  30 |                     .opacity(showConfetti ? 1 : 0)
  31 | 
  32 |                 if showLoading {
  33 |                     VStack(spacing: 16) {
  34 |                         Image(systemName: "gamecontroller.fill")
  35 |                             .font(.system(size: 60))
  36 |                             .foregroundColor(themeManager.primary)
  37 |                             .rotationEffect(.degrees(dotCount % 2 == 0 ? -10 : 10))
  38 | 
  39 |                         Text("Selecting next game\(String(repeating: ".", count: dotCount % 4))")
  40 |                             .font(.title2)
  41 |                             .foregroundColor(themeManager.text)
  42 |                     }
  43 |                     .transition(.opacity.combined(with: .scale))
  44 |                 }
  45 |             }
  46 | 
  47 |             if showConfetti {
  48 |                 ConfettiBurstView()
  49 |                     .transition(.opacity)
  50 |             }
  51 |         }
  52 |         .onAppear { performSequence() }
  53 |         .onDisappear {
  54 |             audioPlayer?.stop()
  55 |             audioPlayer = nil
  56 |         }
  57 |     }
  58 | 
  59 |     private func performSequence() {
  60 |         if soundEnabled { playSound() }
  61 | 
  62 |         withAnimation(.spring(response: 0.6, dampingFraction: 0.7)) {
  63 |             showConfetti = true
  64 |         }
  65 | 
  66 |         DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
  67 |             withAnimation(.easeOut(duration: 0.25)) {
  68 |                 showConfetti = false
  69 |             }
  70 |             withAnimation(.easeIn(duration: 0.25)) {
  71 |                 showLoading = true
  72 |             }
  73 |             startDotAnimation()
  74 |         }
  75 | 
  76 |         DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
  77 |             onComplete()
  78 |         }
  79 |     }
  80 | 
  81 |     private func playSound() {
  82 |         // Preferred: bundled file named transition.mp3 or transition.wav
  83 |         if let url = Bundle.main.url(forResource: "transition", withExtension: "mp3")
  84 |             ?? Bundle.main.url(forResource: "transition", withExtension: "wav") {
  85 |             do {
  86 |                 let player = try AVAudioPlayer(contentsOf: url)
  87 |                 player.volume = 1.0
  88 |                 player.prepareToPlay()
  89 |                 player.play()
  90 |                 audioPlayer = player
  91 |                 return
  92 |             } catch {
  93 |                 // fall through
  94 |             }
  95 |         }
  96 | 
  97 |         // Fallback: system sound (still better than silence)
  98 |         AudioServicesPlaySystemSound(1033)
  99 |     }
 100 | 
 101 |     private func startDotAnimation() {
 102 |         Timer.scheduledTimer(withTimeInterval: 0.35, repeats: true) { timer in
 103 |             if showLoading {
 104 |                 dotCount += 1
 105 |             } else {
 106 |                 timer.invalidate()
 107 |             }
 108 |         }
 109 |     }
 110 | }
 111 | 
 112 | // MARK: - Confetti (Canvas + Timer driven, no TimelineView)
 113 | 
 114 | struct ConfettiBurstView: View {
 115 |     @State private var particles: [ConfettiParticle] = []
 116 |     @State private var startDate = Date()
 117 |     @State private var tick = 0
 118 | 
 119 |     var body: some View {
 120 |         GeometryReader { geo in
 121 |             Canvas { context, size in
 122 |                 let t = Date().timeIntervalSince(startDate)
 123 | 
 124 |                 for p in particles {
 125 |                     let age = t - p.birthDelay
 126 |                     guard age >= 0, age <= p.lifeTime else { continue }
 127 | 
 128 |                     // Physics
 129 |                     let x = p.origin.x + (p.velocity.dx * age)
 130 |                     let y = p.origin.y + (p.velocity.dy * age) + (0.5 * p.gravity * age * age)
 131 | 
 132 |                     // Fade out near the end
 133 |                     let fade = max(0, min(1, (p.lifeTime - age) / 0.6))
 134 | 
 135 |                     // Spin
 136 |                     let rotation = p.rotation + (p.spin * age)
 137 | 
 138 |                     let rect = CGRect(
 139 |                         x: x - p.size.width / 2,
 140 |                         y: y - p.size.height / 2,
 141 |                         width: p.size.width,
 142 |                         height: p.size.height
 143 |                     )
 144 | 
 145 |                     var path = Path()
 146 |                     switch p.shape {
 147 |                     case .rect:
 148 |                         path.addRoundedRect(in: rect, cornerSize: CGSize(width: 3, height: 3))
 149 |                     case .circle:
 150 |                         path.addEllipse(in: rect)
 151 |                     case .diamond:
 152 |                         path.move(to: CGPoint(x: rect.midX, y: rect.minY))
 153 |                         path.addLine(to: CGPoint(x: rect.maxX, y: rect.midY))
 154 |                         path.addLine(to: CGPoint(x: rect.midX, y: rect.maxY))
 155 |                         path.addLine(to: CGPoint(x: rect.minX, y: rect.midY))
 156 |                         path.closeSubpath()
 157 |                     }
 158 | 
 159 |                     context.opacity = fade
 160 | 
 161 |                     let pivot = CGPoint(x: x, y: y)
 162 | 
 163 |                     // Rotate around pivot (manual transform)
 164 |                     context.translateBy(x: pivot.x, y: pivot.y)
 165 |                     context.rotate(by: .degrees(rotation))
 166 |                     context.translateBy(x: -pivot.x, y: -pivot.y)
 167 | 
 168 |                     context.fill(path, with: .color(p.color))
 169 | 
 170 |                     // Undo rotation
 171 |                     context.translateBy(x: pivot.x, y: pivot.y)
 172 |                     context.rotate(by: .degrees(-rotation))
 173 |                     context.translateBy(x: -pivot.x, y: -pivot.y)
 174 | 
 175 |                 }
 176 |             }
 177 |             .ignoresSafeArea()
 178 |             .allowsHitTesting(false)
 179 |             .onAppear {
 180 |                 startDate = Date()
 181 |                 particles = ConfettiParticle.makeBurst(in: geo.size, count: 260)
 182 |                 startRedrawTimer()
 183 |             }
 184 |             .onDisappear {
 185 |                 // Timer is tied to view lifetime via `tick`; no explicit storage needed.
 186 |             }
 187 |             // force Canvas to re-render
 188 |             .id(tick)
 189 |         }
 190 |     }
 191 | 
 192 |     private func startRedrawTimer() {
 193 |         // 60 FPS-ish redraw for ~2.5 seconds, then stop
 194 |         let start = Date()
 195 |         Timer.scheduledTimer(withTimeInterval: 1.0 / 60.0, repeats: true) { timer in
 196 |             if Date().timeIntervalSince(start) > 2.6 {
 197 |                 timer.invalidate()
 198 |             } else {
 199 |                 tick += 1
 200 |             }
 201 |         }
 202 |     }
 203 | }
 204 | 
 205 | private struct ConfettiParticle: Identifiable {
 206 |     enum ShapeType { case rect, circle, diamond }
 207 | 
 208 |     let id = UUID()
 209 |     let origin: CGPoint
 210 |     let velocity: CGVector
 211 |     let gravity: Double
 212 | 
 213 |     let size: CGSize
 214 |     let color: Color
 215 | 
 216 |     let rotation: Double
 217 |     let spin: Double
 218 | 
 219 |     let birthDelay: TimeInterval
 220 |     let lifeTime: TimeInterval
 221 |     let shape: ShapeType
 222 | 
 223 |     static func makeBurst(in size: CGSize, count: Int) -> [ConfettiParticle] {
 224 |         let colors: [Color] = [
 225 |             .red, .yellow, .blue, .green,
 226 |             .orange, .purple, .pink, .cyan
 227 |         ]
 228 |         let shapes: [ShapeType] = [.rect, .diamond]
 229 | 
 230 |         let center = CGPoint(x: size.width / 2, y: size.height / 2)
 231 | 
 232 |         return (0..<count).map { _ in
 233 |             let angle = Double.random(in: 0...(2 * .pi))
 234 |             let speed = Double.random(in: 320...620)
 235 | 
 236 |             let vx = cos(angle) * speed
 237 |             let vy = sin(angle) * speed - Double.random(in: 80...160) // slight upward bias
 238 | 
 239 |             let sizeVal = Double.random(in: 14...26)
 240 | 
 241 |             return ConfettiParticle(
 242 |                 origin: center,
 243 |                 velocity: CGVector(dx: vx, dy: vy),
 244 |                 gravity: Double.random(in: 900...1200),
 245 |                 size: CGSize(width: sizeVal, height: sizeVal),
 246 |                 color: colors.randomElement()!,
 247 |                 rotation: Double.random(in: 0...360),
 248 |                 spin: Double.random(in: -900...900),
 249 |                 birthDelay: Double.random(in: 0.0...0.12),
 250 |                 lifeTime: Double.random(in: 0.9...1.6),
 251 |                 shape: shapes.randomElement()!
 252 |             )
 253 |         }
 254 |     }
 255 | }
 256 | 
 257 | #Preview {
 258 |     GameTransitionView {
 259 |         print("Transition complete")
 260 |     }
 261 |     .environmentObject(ThemeManager())
 262 | }


END FILE: ./Christmas Games/GameTransitionView.swift


################################################################################
START FILE: ./Christmas Games/Models.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | // MARK: - Enums
   5 | 
   6 | enum EventStatus: String, Codable, CaseIterable {
   7 |     case available
   8 |     case active
   9 |     case paused
  10 |     case completed
  11 | }
  12 | 
  13 | enum GameStatus: String, Codable, CaseIterable {
  14 |     case notStarted
  15 |     case inProgress
  16 |     case completed
  17 | }
  18 | 
  19 | enum TeamType: String, Codable, CaseIterable {
  20 |     case any
  21 |     case maleOnly
  22 |     case femaleOnly
  23 |     case couplesOnly
  24 | }
  25 | 
  26 | enum RoundResultType: String, Codable, CaseIterable {
  27 |     case win
  28 |     case tie
  29 | }
  30 | 
  31 | // MARK: - People
  32 | 
  33 | @Model
  34 | final class Person {
  35 |     @Attribute(.unique) var id: UUID
  36 |     var displayName: String
  37 |     var sex: String?
  38 |     var spouseId: UUID?
  39 | 
  40 |     // Detailed (used by CSV import, FairnessEngine)
  41 |     var age: Int?
  42 |     var weight: Int?
  43 |     var athleticAbility: Int?
  44 |     var height: String?
  45 | 
  46 |     // Categories (used by simple UI)
  47 |     var weightCategory: String?   // "S", "M", "L"
  48 |     var heightCategory: String?   // "S", "M", "L"
  49 | 
  50 |     var isActive: Bool
  51 | 
  52 |     init(
  53 |         id: UUID = UUID(),
  54 |         displayName: String,
  55 |         sex: String? = nil,
  56 |         spouseId: UUID? = nil,
  57 |         age: Int? = nil,
  58 |         weight: Int? = nil,
  59 |         athleticAbility: Int? = nil,
  60 |         height: String? = nil,
  61 |         weightCategory: String? = nil,
  62 |         heightCategory: String? = nil,
  63 |         isActive: Bool = true
  64 |     ) {
  65 |         self.id = id
  66 |         self.displayName = displayName
  67 |         self.sex = sex
  68 |         self.spouseId = spouseId
  69 |         self.age = age
  70 |         self.weight = weight
  71 |         self.athleticAbility = athleticAbility
  72 |         self.height = height
  73 |         self.weightCategory = weightCategory
  74 |         self.heightCategory = heightCategory
  75 |         self.isActive = isActive
  76 |     }
  77 | }
  78 | 
  79 | // MARK: - Game Templates
  80 | 
  81 | @Model
  82 | final class GameTemplate {
  83 |     @Attribute(.unique) var id: UUID
  84 |     @Attribute(.unique) var externalId: String
  85 | 
  86 |     var name: String
  87 |     var groupName: String?
  88 | 
  89 |     var defaultTeamCount: Int
  90 |     var defaultPlayersPerTeam: Int
  91 |     var defaultRoundsPerGame: Int
  92 |     var defaultTeamTypeRaw: String
  93 | 
  94 |     var playInstructions: String?
  95 |     var setupInstructions: String?
  96 | 
  97 |     init(
  98 |         id: UUID = UUID(),
  99 |         externalId: String,
 100 |         name: String,
 101 |         groupName: String? = nil,
 102 |         defaultTeamCount: Int,
 103 |         defaultPlayersPerTeam: Int,
 104 |         defaultRoundsPerGame: Int,
 105 |         defaultTeamType: TeamType,
 106 |         playInstructions: String? = nil,
 107 |         setupInstructions: String? = nil
 108 |     ) {
 109 |         self.id = id
 110 |         self.externalId = externalId
 111 |         self.name = name
 112 |         self.groupName = groupName
 113 |         self.defaultTeamCount = defaultTeamCount
 114 |         self.defaultPlayersPerTeam = defaultPlayersPerTeam
 115 |         self.defaultRoundsPerGame = defaultRoundsPerGame
 116 |         self.defaultTeamTypeRaw = defaultTeamType.rawValue
 117 |         self.playInstructions = playInstructions
 118 |         self.setupInstructions = setupInstructions
 119 |     }
 120 | 
 121 |     @Transient
 122 |     var defaultTeamType: TeamType {
 123 |         get { TeamType(rawValue: defaultTeamTypeRaw) ?? .any }
 124 |         set { defaultTeamTypeRaw = newValue.rawValue }
 125 |     }
 126 | }
 127 | 
 128 | // MARK: - RoundTeam
 129 | 
 130 | struct RoundTeam: Codable, Equatable, Identifiable {
 131 |     var id: UUID
 132 |     var memberPersonIds: [UUID]
 133 | 
 134 |     init(id: UUID = UUID(), memberPersonIds: [UUID]) {
 135 |         self.id = id
 136 |         self.memberPersonIds = memberPersonIds
 137 |     }
 138 | }
 139 | 
 140 | // MARK: - Event
 141 | 
 142 | @Model
 143 | final class Event {
 144 |     @Attribute(.unique) var id: UUID
 145 |     var name: String
 146 | 
 147 |     var statusRaw: String
 148 |     var participantIds: [UUID]
 149 | 
 150 |     var createdAt: Date
 151 |     var lastModifiedAt: Date
 152 | 
 153 |     var currentEventGameId: UUID?
 154 | 
 155 |     @Relationship(deleteRule: .cascade, inverse: \EventGame.event)
 156 |     var eventGames: [EventGame]
 157 | 
 158 |     init(
 159 |         id: UUID = UUID(),
 160 |         name: String,
 161 |         status: EventStatus = .available,
 162 |         participantIds: [UUID] = [],
 163 |         createdAt: Date = Date(),
 164 |         lastModifiedAt: Date = Date(),
 165 |         currentEventGameId: UUID? = nil,
 166 |         eventGames: [EventGame] = []
 167 |     ) {
 168 |         self.id = id
 169 |         self.name = name
 170 |         self.statusRaw = status.rawValue
 171 |         self.participantIds = participantIds
 172 |         self.createdAt = createdAt
 173 |         self.lastModifiedAt = lastModifiedAt
 174 |         self.currentEventGameId = currentEventGameId
 175 |         self.eventGames = eventGames
 176 |     }
 177 | 
 178 |     @Transient
 179 |     var status: EventStatus {
 180 |         get { EventStatus(rawValue: statusRaw) ?? .available }
 181 |         set { statusRaw = newValue.rawValue }
 182 |     }
 183 | }
 184 | 
 185 | // MARK: - EventGame
 186 | 
 187 | @Model
 188 | final class EventGame {
 189 |     @Attribute(.unique) var id: UUID
 190 | 
 191 |     var event: Event?
 192 | 
 193 |     var gameTemplateId: UUID
 194 |     var orderIndex: Int
 195 |     var statusRaw: String
 196 | 
 197 |     var overrideTeamCount: Int?
 198 |     var overridePlayersPerTeam: Int?
 199 |     var overrideRoundsPerGame: Int?
 200 |     var overrideTeamTypeRaw: String?
 201 |     var overridePlayInstructions: String?
 202 |     var overrideSetupInstructions: String?
 203 | 
 204 |     var overrideTeamPlayersData: Data?
 205 | 
 206 |     @Relationship(deleteRule: .cascade, inverse: \Round.eventGame)
 207 |     var rounds: [Round]
 208 | 
 209 |     init(
 210 |         id: UUID = UUID(),
 211 |         event: Event? = nil,
 212 |         gameTemplateId: UUID,
 213 |         orderIndex: Int,
 214 |         status: GameStatus = .notStarted,
 215 |         overrideTeamCount: Int? = nil,
 216 |         overridePlayersPerTeam: Int? = nil,
 217 |         overrideRoundsPerGame: Int? = nil,
 218 |         overrideTeamType: TeamType? = nil,
 219 |         overrideTeamPlayers: [[UUID]]? = nil,
 220 |         overridePlayInstructions: String? = nil,
 221 |         overrideSetupInstructions: String? = nil,
 222 |         rounds: [Round] = []
 223 |     ) {
 224 |         self.id = id
 225 |         self.event = event
 226 |         self.gameTemplateId = gameTemplateId
 227 |         self.orderIndex = orderIndex
 228 |         self.statusRaw = status.rawValue
 229 |         self.overrideTeamCount = overrideTeamCount
 230 |         self.overridePlayersPerTeam = overridePlayersPerTeam
 231 |         self.overrideRoundsPerGame = overrideRoundsPerGame
 232 |         self.overrideTeamTypeRaw = overrideTeamType?.rawValue
 233 |         if let overrideTeamPlayers {
 234 |             self.overrideTeamPlayersData = try? JSONEncoder().encode(overrideTeamPlayers)
 235 |         } else {
 236 |             self.overrideTeamPlayersData = nil
 237 |         }
 238 |         self.overridePlayInstructions = overridePlayInstructions
 239 |         self.overrideSetupInstructions = overrideSetupInstructions
 240 |         self.rounds = rounds
 241 |     }
 242 | 
 243 |     @Transient
 244 |     var status: GameStatus {
 245 |         get { GameStatus(rawValue: statusRaw) ?? .notStarted }
 246 |         set { statusRaw = newValue.rawValue }
 247 |     }
 248 | 
 249 |     @Transient
 250 |     var overrideTeamType: TeamType? {
 251 |         get { overrideTeamTypeRaw.flatMap { TeamType(rawValue: $0) } }
 252 |         set { overrideTeamTypeRaw = newValue?.rawValue }
 253 |     }
 254 | 
 255 |     @Transient
 256 |     var overrideTeamPlayers: [[UUID]]? {
 257 |         get {
 258 |             guard let data = overrideTeamPlayersData else { return nil }
 259 |             return try? JSONDecoder().decode([[UUID]].self, from: data)
 260 |         }
 261 |         set {
 262 |             if let newValue {
 263 |                 overrideTeamPlayersData = try? JSONEncoder().encode(newValue)
 264 |             } else {
 265 |                 overrideTeamPlayersData = nil
 266 |             }
 267 |         }
 268 |     }
 269 | }
 270 | 
 271 | // MARK: - Round
 272 | 
 273 | @Model
 274 | final class Round {
 275 |     @Attribute(.unique) var id: UUID
 276 | 
 277 |     var eventGame: EventGame?
 278 | 
 279 |     var roundIndex: Int
 280 |     var createdAt: Date
 281 |     var completedAt: Date?
 282 | 
 283 |     var teamsData: Data
 284 |     var placementsData: Data
 285 | 
 286 |     var resultTypeRaw: String?
 287 |     var winningTeamId: UUID?
 288 | 
 289 |     init(
 290 |         id: UUID = UUID(),
 291 |         eventGame: EventGame? = nil,
 292 |         roundIndex: Int,
 293 |         createdAt: Date = Date(),
 294 |         completedAt: Date? = nil,
 295 |         teams: [RoundTeam] = [],
 296 |         placements: [UUID: Int] = [:],
 297 |         resultType: RoundResultType? = nil,
 298 |         winningTeamId: UUID? = nil
 299 |     ) {
 300 |         self.id = id
 301 |         self.eventGame = eventGame
 302 |         self.roundIndex = roundIndex
 303 |         self.createdAt = createdAt
 304 |         self.completedAt = completedAt
 305 |         self.teamsData = (try? JSONEncoder().encode(teams)) ?? Data()
 306 |         self.placementsData = (try? JSONEncoder().encode(placements)) ?? Data()
 307 |         self.resultTypeRaw = resultType?.rawValue
 308 |         self.winningTeamId = winningTeamId
 309 |     }
 310 | 
 311 |     @Transient
 312 |     var teams: [RoundTeam] {
 313 |         get { (try? JSONDecoder().decode([RoundTeam].self, from: teamsData)) ?? [] }
 314 |         set { teamsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 315 |     }
 316 | 
 317 |     @Transient
 318 |     var placements: [UUID: Int] {
 319 |         get { (try? JSONDecoder().decode([UUID: Int].self, from: placementsData)) ?? [:] }
 320 |         set { placementsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 321 |     }
 322 | 
 323 |     @Transient
 324 |     var resultType: RoundResultType? {
 325 |         get { resultTypeRaw.flatMap { RoundResultType(rawValue: $0) } }
 326 |         set { resultTypeRaw = newValue?.rawValue }
 327 |     }
 328 | 
 329 |     @Transient
 330 |     var isLocked: Bool {
 331 |         completedAt != nil
 332 |     }
 333 | }


END FILE: ./Christmas Games/Models.swift


################################################################################
START FILE: ./Christmas Games/Theme.swift
################################################################################
   1 | import SwiftUI
   2 | import Combine
   3 | 
   4 | // MARK: - Color Extension for Luminance
   5 | extension Color {
   6 |     // Initialize from Hex
   7 |     init(hex: String) {
   8 |         let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
   9 |         var int: UInt64 = 0
  10 |         Scanner(string: hex).scanHexInt64(&int)
  11 |         let a, r, g, b: UInt64
  12 |         switch hex.count {
  13 |         case 3: // RGB (12-bit)
  14 |             (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
  15 |         case 6: // RGB (24-bit)
  16 |             (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
  17 |         case 8: // ARGB (32-bit)
  18 |             (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
  19 |         default:
  20 |             (a, r, g, b) = (255, 0, 0, 0)
  21 |         }
  22 |         self.init(
  23 |             .sRGB,
  24 |             red: Double(r) / 255,
  25 |             green: Double(g) / 255,
  26 |             blue: Double(b) / 255,
  27 |             opacity: Double(a) / 255
  28 |         )
  29 |     }
  30 |     
  31 |     func toHex() -> String? {
  32 |         let uic = UIColor(self)
  33 |         guard let components = uic.cgColor.components, components.count >= 3 else {
  34 |             return nil
  35 |         }
  36 |         let r = Float(components[0])
  37 |         let g = Float(components[1])
  38 |         let b = Float(components[2])
  39 |         var a = Float(1.0)
  40 |         
  41 |         if components.count >= 4 { a = Float(components[3]) }
  42 |         
  43 |         if a != 1.0 {
  44 |             return String(format: "%02lX%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255), lroundf(a * 255))
  45 |         } else {
  46 |             return String(format: "%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255))
  47 |         }
  48 |     }
  49 | 
  50 |     var isLight: Bool {
  51 |         let uiColor = UIColor(self)
  52 |         var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
  53 |         
  54 |         if !uiColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha) {
  55 |             return true
  56 |         }
  57 |         
  58 |         let brightness = ((red * 299) + (green * 587) + (blue * 114)) / 1000
  59 |         return brightness > 0.5
  60 |     }
  61 | }
  62 | 
  63 | // MARK: - Dynamic Theme Model
  64 | struct Theme: Identifiable, Equatable {
  65 |     let id: String
  66 |     
  67 |     let primary: Color
  68 |     let secondary: Color
  69 |     let background: Color
  70 |     let card: Color
  71 |     let text: Color
  72 |     let divider: Color
  73 |     let onPrimary: Color
  74 |     
  75 |     /// Create a theme from a single base color and intensity
  76 |     init(hex: String, intensity: Double) {
  77 |         self.id = hex
  78 |         
  79 |         let base = Color(hex: hex)
  80 |         
  81 |         self.primary = base
  82 |         self.secondary = base.opacity(0.6)
  83 |         
  84 |         // Get base color RGB components
  85 |         let uiBase = UIColor(base)
  86 |         var baseR: CGFloat = 0, baseG: CGFloat = 0, baseB: CGFloat = 0, baseA: CGFloat = 0
  87 |         uiBase.getRed(&baseR, green: &baseG, blue: &baseB, alpha: &baseA)
  88 |         
  89 |         // Clamp intensity to valid range (allow full 0-1 range now)
  90 |         let clampedIntensity = max(0.0, min(1.0, intensity))
  91 |         
  92 |         // Calculate the EFFECTIVE color after alpha-blending with white background
  93 |         // Formula: effectiveColor = baseColor * alpha + white * (1 - alpha)
  94 |         let effectiveR = baseR * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  95 |         let effectiveG = baseG * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  96 |         let effectiveB = baseB * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  97 |         
  98 |         // Create the light mode background using the blended color (opaque)
  99 |         let lightModeBackground = UIColor(red: effectiveR, green: effectiveG, blue: effectiveB, alpha: 1.0)
 100 |         
 101 |         self.background = Color(UIColor { traitCollection in
 102 |             if traitCollection.userInterfaceStyle == .dark {
 103 |                 return .systemGroupedBackground
 104 |             } else {
 105 |                 return lightModeBackground
 106 |             }
 107 |         })
 108 |         
 109 |         self.card = Color(UIColor { traitCollection in
 110 |             return traitCollection.userInterfaceStyle == .dark ? .secondarySystemGroupedBackground : .white
 111 |         })
 112 |         
 113 |         self.divider = Color.gray.opacity(0.2)
 114 |         
 115 |         // Text on Primary: High contrast
 116 |         self.onPrimary = base.isLight ? Color.black : Color.white
 117 |         
 118 |         // Calculate luminance of the effective blended background
 119 |         let effectiveLuminance = (effectiveR * 0.299) + (effectiveG * 0.587) + (effectiveB * 0.114)
 120 |         // Raised threshold from 0.5 to 0.75 so text flips to white earlier
 121 |         let effectiveBgIsLight = effectiveLuminance > 0.75
 122 |         
 123 |         // For dynamic text that adapts to light/dark mode
 124 |         self.text = Color(UIColor { traitCollection in
 125 |             if traitCollection.userInterfaceStyle == .dark {
 126 |                 return .label
 127 |             } else {
 128 |                 // Light mode: flip based on effective background luminance
 129 |                 return effectiveBgIsLight ? .label : .white
 130 |             }
 131 |         })
 132 |     }
 133 | }
 134 | 
 135 | // MARK: - Theme Manager
 136 | @MainActor
 137 | final class ThemeManager: ObservableObject {
 138 |     private let storageKeyHex = "selectedThemeHex"
 139 |     private let storageKeyIntensity = "selectedThemeIntensity"
 140 |     private let defaultHex = "B22222" // Christmas red as default
 141 |     
 142 |     @Published var selectedThemeId: String {
 143 |         didSet { updateTheme() }
 144 |     }
 145 |     
 146 |     @Published var currentIntensity: Double {
 147 |         didSet { updateTheme() }
 148 |     }
 149 |     
 150 |     @Published private(set) var currentTheme: Theme
 151 |     
 152 |     init() {
 153 |         let savedHex = UserDefaults.standard.string(forKey: storageKeyHex) ?? defaultHex
 154 |         let savedIntensityDouble = UserDefaults.standard.double(forKey: storageKeyIntensity)
 155 |         let resolvedIntensity = savedIntensityDouble == 0 ? 0.15 : savedIntensityDouble
 156 |         
 157 |         self.selectedThemeId = savedHex
 158 |         self.currentIntensity = resolvedIntensity
 159 |         self.currentTheme = Theme(hex: savedHex, intensity: resolvedIntensity)
 160 |     }
 161 |     
 162 |     private func updateTheme() {
 163 |         UserDefaults.standard.set(selectedThemeId, forKey: storageKeyHex)
 164 |         UserDefaults.standard.set(currentIntensity, forKey: storageKeyIntensity)
 165 |         self.currentTheme = Theme(hex: selectedThemeId, intensity: currentIntensity)
 166 |     }
 167 |     
 168 |     // Convenience Proxies
 169 |     var primary: Color { currentTheme.primary }
 170 |     var secondary: Color { currentTheme.secondary }
 171 |     var background: Color { currentTheme.background }
 172 |     var card: Color { currentTheme.card }
 173 |     var text: Color { currentTheme.text }
 174 |     var divider: Color { currentTheme.divider }
 175 |     var onPrimary: Color { currentTheme.onPrimary }
 176 | }
 177 | 
 178 | // MARK: - Team Colors for Gameplay
 179 | extension ThemeManager {
 180 |     /// Get team colors that work well with the current theme
 181 |     /// Returns a set of 6 distinct colors suitable for team identification
 182 |     var teamColors: [Color] {
 183 |         // Use classic, high-contrast team colors that work with any theme
 184 |         return [
 185 |             .red,
 186 |             .blue,
 187 |             .green,
 188 |             .orange,
 189 |             .purple,
 190 |             Color(red: 0.0, green: 0.7, blue: 0.7)  // Teal
 191 |         ]
 192 |     }
 193 |     
 194 |     /// Get status color for events
 195 |     func statusColor(_ status: EventStatus) -> Color {
 196 |         switch status {
 197 |         case .available: return .gray
 198 |         case .active: return primary
 199 |         case .paused: return .orange
 200 |         case .completed: return .blue
 201 |         }
 202 |     }
 203 | }


END FILE: ./Christmas Games/Theme.swift


################################################################################
START FILE: ./Christmas Games/ParticipantCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct ParticipantCatalogView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var people: [Person]
  10 | 
  11 |     @State private var showCreatePerson = false
  12 |     @State private var editingPerson: Person?
  13 | 
  14 |     @State private var alertTitle = "Message"
  15 |     @State private var alertMessage: String?
  16 |     @State private var showAlert = false
  17 | 
  18 |     var body: some View {
  19 |         ZStack {
  20 |             // Solid background
  21 |             themeManager.background
  22 |                 .ignoresSafeArea()
  23 | 
  24 |             // Your existing List
  25 |             List {
  26 |                 ForEach(people) { person in
  27 |                     Button {
  28 |                         editingPerson = person
  29 |                     } label: {
  30 |                         HStack {
  31 |                             VStack(alignment: .leading, spacing: 4) {
  32 |                                 Text(person.displayName)
  33 |                                     .font(.body)
  34 |                                     .foregroundStyle(.primary)
  35 | 
  36 |                                 if let sex = person.sex {
  37 |                                     Text("Gender: \(sex)")
  38 |                                         .font(.footnote)
  39 |                                         .foregroundStyle(.secondary)
  40 |                                 }
  41 |                             }
  42 | 
  43 |                             Spacer()
  44 | 
  45 |                             if !person.isActive {
  46 |                                 Text("Inactive")
  47 |                                     .font(.footnote)
  48 |                                     .foregroundStyle(.secondary)
  49 |                             }
  50 |                         }
  51 |                     }
  52 |                 }
  53 |                 .onDelete(perform: deletePeople)
  54 |             }
  55 |             .scrollContentBackground(.hidden)
  56 |         }
  57 |         .navigationTitle("Participant Catalog")
  58 |         .toolbarBackground(.hidden, for: .navigationBar)
  59 |         .toolbar {
  60 |             ToolbarItem(placement: .topBarTrailing) {
  61 |                 Button("Add") { showCreatePerson = true }
  62 |                     .foregroundColor(themeManager.text)
  63 |             }
  64 |         }
  65 |         .sheet(isPresented: $showCreatePerson) {
  66 |             CreatePersonSheet()
  67 |                 .environmentObject(themeManager)
  68 |         }
  69 |         .sheet(item: $editingPerson) { person in
  70 |             EditPersonSheet(person: person)
  71 |                 .environmentObject(themeManager)
  72 |         }
  73 |         .alert(alertTitle, isPresented: $showAlert) {
  74 |             Button("OK", role: .cancel) { }
  75 |         } message: {
  76 |             Text(alertMessage ?? "Unknown error")
  77 |         }
  78 |     }
  79 | 
  80 |     private func deletePeople(at offsets: IndexSet) {
  81 |         for index in offsets {
  82 |             context.delete(people[index])
  83 |         }
  84 |         try? context.save()
  85 |     }
  86 | }
  87 | 
  88 | #Preview {
  89 |     NavigationStack {
  90 |         ParticipantCatalogView()
  91 |     }
  92 |     .modelContainer(for: [Person.self])
  93 |     .environmentObject(ThemeManager())
  94 | }


END FILE: ./Christmas Games/ParticipantCatalogView.swift


################################################################################
START FILE: ./Christmas Games/WinnerCelebrationOverlay.swift
################################################################################
   1 | import SwiftUI
   2 | import AVFoundation
   3 | import AudioToolbox
   4 | 
   5 | struct WinnerCelebrationOverlay: View {
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     let title: String
   9 |     let lines: [String]
  10 |     let useGifs: Bool
  11 | 
  12 |     // Lightweight “reaction” placeholder.
  13 |     // Once you wire your GIFs, we’ll replace this with your random GIF view.
  14 |     @State private var emoji = ["🎉", "🏆", "✨", "👏"].randomElement() ?? "🎉"
  15 | 
  16 |     var body: some View {
  17 |         ZStack {
  18 |             Color.black.opacity(0.65).ignoresSafeArea()
  19 | 
  20 |             VStack(spacing: 14) {
  21 |                 Text(useGifs ? emoji : "🏆")
  22 |                     .font(.system(size: 56))
  23 | 
  24 |                 Text(title)
  25 |                     .font(.title)
  26 |                     .fontWeight(.bold)
  27 |                     .foregroundColor(.white)
  28 | 
  29 |                 ForEach(lines, id: \.self) { line in
  30 |                     Text(line)
  31 |                         .font(.headline)
  32 |                         .foregroundColor(.white.opacity(0.95))
  33 |                         .multilineTextAlignment(.center)
  34 |                         .padding(.horizontal, 20)
  35 |                 }
  36 |             }
  37 |             .padding(.vertical, 26)
  38 |             .padding(.horizontal, 18)
  39 |             .background(
  40 |                 RoundedRectangle(cornerRadius: 22, style: .continuous)
  41 |                     .fill(Color.white.opacity(0.10))
  42 |             )
  43 |             .overlay(
  44 |                 RoundedRectangle(cornerRadius: 22, style: .continuous)
  45 |                     .stroke(Color.white.opacity(0.15), lineWidth: 1)
  46 |             )
  47 |             .padding(24)
  48 |         }
  49 |     }
  50 | }


END FILE: ./Christmas Games/WinnerCelebrationOverlay.swift


################################################################################
START FILE: ./Christmas Games/EventsListView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct EventsListView: View {
   6 |     @Environment(\.modelContext) private var context
   7 |     @EnvironmentObject var themeManager: ThemeManager
   8 | 
   9 |     @Query(sort: \Event.createdAt, order: .reverse)
  10 |     private var events: [Event]
  11 | 
  12 |     @State private var showAddEvent = false
  13 | 
  14 |     var body: some View {
  15 |         ZStack {
  16 |             themeManager.background
  17 |                 .ignoresSafeArea()
  18 | 
  19 |             List {
  20 |                 ForEach(events) { event in
  21 |                     NavigationLink {
  22 |                         EventDetailView(event: event)
  23 |                             .environmentObject(themeManager)
  24 |                     } label: {
  25 |                         VStack(alignment: .leading, spacing: 4) {
  26 |                             Text(event.name).font(.headline)
  27 |                             Text(event.statusRaw.capitalized)
  28 |                                 .font(.subheadline)
  29 |                                 .foregroundStyle(.secondary)
  30 |                         }
  31 |                     }
  32 |                 }
  33 |                 .onDelete(perform: deleteEvents)
  34 |             }
  35 |             .scrollContentBackground(.hidden)
  36 |         }
  37 |         .navigationTitle("Events")
  38 |         .toolbarBackground(.hidden, for: .navigationBar)
  39 |         .toolbar {
  40 |             ToolbarItem(placement: .topBarTrailing) {
  41 |                 Button("Add Event") { showAddEvent = true }
  42 |                     .foregroundColor(themeManager.text)
  43 |             }
  44 |         }
  45 |         .sheet(isPresented: $showAddEvent) {
  46 |             AddEventSheet()
  47 |                 .environmentObject(themeManager)
  48 |         }
  49 |     }
  50 | 
  51 |     private func deleteEvents(at offsets: IndexSet) {
  52 |         for index in offsets { context.delete(events[index]) }
  53 |         try? context.save()
  54 |     }
  55 | }
  56 | 
  57 | // MARK: - Event Detail
  58 | 
  59 | private struct EventDetailView: View {
  60 |     @Environment(\.modelContext) private var context
  61 |     @EnvironmentObject var themeManager: ThemeManager
  62 | 
  63 |     let event: Event
  64 | 
  65 |     @Query(sort: \GameTemplate.name)
  66 |     private var templates: [GameTemplate]
  67 | 
  68 |     @State private var showAddGame = false
  69 |     @State private var showPlayers = false
  70 |     @State private var showResetConfirm = false
  71 |     @State private var showEventStats = false
  72 | 
  73 |     @State private var message: String?
  74 |     @State private var showMessage = false
  75 | 
  76 |     // Filter and sort state
  77 |     @State private var filterTeamSize: Int? = nil
  78 |     @State private var filterTeamCount: Int? = nil
  79 |     @State private var sortOption: SortOption = .orderIndex
  80 |     @State private var statusFilter: StatusFilter = .all
  81 | 
  82 |     enum SortOption: String, CaseIterable {
  83 |         case orderIndex = "Order"
  84 |         case alphabetical = "A-Z"
  85 |         case reverseAlphabetical = "Z-A"
  86 |         case status = "Status"
  87 |     }
  88 | 
  89 |     enum StatusFilter: String, CaseIterable {
  90 |         case all = "All"
  91 |         case notStarted = "Not Started"
  92 |         case inProgress = "In Progress"
  93 |         case completed = "Completed"
  94 |         
  95 |         var gameStatus: GameStatus? {
  96 |             switch self {
  97 |             case .all: return nil
  98 |             case .notStarted: return .notStarted
  99 |             case .inProgress: return .inProgress
 100 |             case .completed: return .completed
 101 |             }
 102 |         }
 103 |     }
 104 | 
 105 |     var body: some View {
 106 |         ZStack {
 107 |             themeManager.background
 108 |                 .ignoresSafeArea()
 109 | 
 110 |             List {
 111 |                 // Compact stats section
 112 |                 Section {
 113 |                     HStack {
 114 |                         Label("\(event.participantIds.count)", systemImage: "person.2")
 115 |                         Spacer()
 116 |                         Label("\(completedGamesCount)/\(event.eventGames.count)", systemImage: "gamecontroller")
 117 |                         Spacer()
 118 |                         Label(event.statusRaw.capitalized, systemImage: statusIcon)
 119 |                             .foregroundStyle(statusColor)
 120 |                     }
 121 |                     .font(.subheadline)
 122 |                 }
 123 | 
 124 |                 Section {
 125 |                     NavigationLink("Run Event") {
 126 |                         RunGameView(event: event)
 127 |                             .environmentObject(themeManager)
 128 |                     }
 129 |                     .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty)
 130 |                 } header: {
 131 |                     Text("Host")
 132 |                 }
 133 | 
 134 |                 Section {
 135 |                     // Filters
 136 |                     HStack {
 137 |                         Picker("Team Size", selection: $filterTeamSize) {
 138 |                             Text("Any").tag(Int?.none)
 139 |                             ForEach(allTeamSizes, id: \.self) { size in
 140 |                                 Text("\(size)").tag(Int?.some(size))
 141 |                             }
 142 |                         }
 143 |                         .pickerStyle(.menu)
 144 | 
 145 |                         Picker("Team Count", selection: $filterTeamCount) {
 146 |                             Text("Any").tag(Int?.none)
 147 |                             ForEach(allTeamCounts, id: \.self) { count in
 148 |                                 Text("\(count)").tag(Int?.some(count))
 149 |                             }
 150 |                         }
 151 |                         .pickerStyle(.menu)
 152 |                     }
 153 | 
 154 |                     Picker("Status", selection: $statusFilter) {
 155 |                         ForEach(StatusFilter.allCases, id: \.self) { s in
 156 |                             Text(s.rawValue).tag(s)
 157 |                         }
 158 |                     }
 159 |                     .pickerStyle(.segmented)
 160 | 
 161 |                     Picker("Sort", selection: $sortOption) {
 162 |                         ForEach(SortOption.allCases, id: \.self) { s in
 163 |                             Text(s.rawValue).tag(s)
 164 |                         }
 165 |                     }
 166 |                     .pickerStyle(.segmented)
 167 |                 } header: {
 168 |                     Text("Filters & Sort")
 169 |                 }
 170 | 
 171 |                 Section {
 172 |                     Button("Participants") { showPlayers = true }
 173 |                         .disabled(event.participantIds.isEmpty)
 174 |                 } header: {
 175 |                     Text("Manage")
 176 |                 }
 177 | 
 178 |                 Section {
 179 |                     Button("Add Games") { showAddGame = true }
 180 |                     Button("Reset Event", role: .destructive) { showResetConfirm = true }
 181 |                 } header: {
 182 |                     Text("Actions")
 183 |                 }
 184 | 
 185 |                 Section {
 186 |                     ForEach(filteredAndSortedGames) { eg in
 187 |                         NavigationLink {
 188 |                             EventGameDetailView(event: event, eventGame: eg)
 189 |                                 .environmentObject(themeManager)
 190 |                         } label: {
 191 |                             gameRow(for: eg)
 192 |                         }
 193 |                     }
 194 |                     .onDelete(perform: deleteEventGames)
 195 |                     .onMove(perform: moveEventGames)
 196 |                 } header: {
 197 |                     Text("Games")
 198 |                 }
 199 |             }
 200 |             .scrollContentBackground(.hidden)
 201 |         }
 202 |         .navigationBarTitleDisplayMode(.inline)
 203 |         .toolbarBackground(.hidden, for: .navigationBar)
 204 |         .toolbar {
 205 |             ToolbarItem(placement: .principal) {
 206 |                 Text(event.name)
 207 |                     .font(.title2.bold())
 208 |                     .lineLimit(1)
 209 |                     .minimumScaleFactor(0.5)
 210 |                     .foregroundColor(themeManager.text)
 211 |             }
 212 |             
 213 |             ToolbarItem(placement: .topBarLeading) {
 214 |                 lifecycleButton
 215 |             }
 216 |             ToolbarItem(placement: .topBarTrailing) {
 217 |                 EditButton()
 218 |                     .foregroundColor(themeManager.text)
 219 |             }
 220 |         }
 221 |         .sheet(isPresented: $showPlayers) {
 222 |             ParticipantPickerSheet(event: event)
 223 |                 .environmentObject(themeManager)
 224 |         }
 225 |         .sheet(isPresented: $showAddGame) {
 226 |             AddGamesSheet(event: event, templates: templates)
 227 |                 .environmentObject(themeManager)
 228 |         }
 229 |         .sheet(isPresented: $showEventStats) {
 230 |             CurrentEventStatsSheet(event: event)
 231 |                 .environmentObject(themeManager)
 232 |         }
 233 |         .alert("Message", isPresented: $showMessage) {
 234 |             Button("OK", role: .cancel) { }
 235 |         } message: {
 236 |             Text(message ?? "Unknown error")
 237 |         }
 238 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
 239 |             Button("Reset Event", role: .destructive) {
 240 |                 do {
 241 |                     try EventEngine(context: context).resetEvent(event)
 242 |                 } catch {
 243 |                     message = error.localizedDescription
 244 |                     showMessage = true
 245 |                 }
 246 |             }
 247 |             Button("Cancel", role: .cancel) { }
 248 |         } message: {
 249 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 250 |         }
 251 |     }
 252 | 
 253 |     // MARK: - Derived data
 254 | 
 255 |     private var engine: EventEngine { EventEngine(context: context) }
 256 | 
 257 |     private var completedGamesCount: Int {
 258 |         event.eventGames.filter { $0.status == .completed }.count
 259 |     }
 260 | 
 261 |     private var statusIcon: String {
 262 |         switch event.status {
 263 |         case .available: return "circle"
 264 |         case .active: return "play.circle.fill"
 265 |         case .paused: return "pause.circle.fill"
 266 |         case .completed: return "checkmark.circle.fill"
 267 |         }
 268 |     }
 269 | 
 270 |     private var statusColor: Color {
 271 |         themeManager.statusColor(event.status)
 272 |     }
 273 | 
 274 |     private var allTeamSizes: [Int] {
 275 |         let arr = Array(Set(event.eventGames.compactMap { eg -> Int? in
 276 |             let t = templates.first(where: { $0.id == eg.gameTemplateId })
 277 |             return eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam
 278 |         }))
 279 |         return arr.sorted()
 280 |     }
 281 | 
 282 |     private var allTeamCounts: [Int] {
 283 |         let arr = Array(Set(event.eventGames.compactMap { eg -> Int? in
 284 |             let t = templates.first(where: { $0.id == eg.gameTemplateId })
 285 |             return eg.overrideTeamCount ?? t?.defaultTeamCount
 286 |         }))
 287 |         return arr.sorted()
 288 |     }
 289 | 
 290 |     private var filteredAndSortedGames: [EventGame] {
 291 |         var games = event.eventGames
 292 | 
 293 |         // Apply team size filter
 294 |         if let size = filterTeamSize {
 295 |             games = games.filter { eg in
 296 |                 let t = templates.first(where: { $0.id == eg.gameTemplateId })
 297 |                 let ppt = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 0
 298 |                 return ppt == size
 299 |             }
 300 |         }
 301 | 
 302 |         // Apply team count filter
 303 |         if let count = filterTeamCount {
 304 |             games = games.filter { eg in
 305 |                 let t = templates.first(where: { $0.id == eg.gameTemplateId })
 306 |                 let tc = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 0
 307 |                 return tc == count
 308 |             }
 309 |         }
 310 | 
 311 |         // Apply status filter
 312 |         if let targetStatus = statusFilter.gameStatus {
 313 |             games = games.filter { $0.status == targetStatus }
 314 |         }
 315 | 
 316 |         // Apply sorting
 317 |         switch sortOption {
 318 |         case .orderIndex:
 319 |             games.sort { $0.orderIndex < $1.orderIndex }
 320 |         case .alphabetical:
 321 |             games.sort { eg1, eg2 in
 322 |                 let n1 = templates.first(where: { $0.id == eg1.gameTemplateId })?.name ?? ""
 323 |                 let n2 = templates.first(where: { $0.id == eg2.gameTemplateId })?.name ?? ""
 324 |                 return n1 < n2
 325 |             }
 326 |         case .reverseAlphabetical:
 327 |             games.sort { eg1, eg2 in
 328 |                 let n1 = templates.first(where: { $0.id == eg1.gameTemplateId })?.name ?? ""
 329 |                 let n2 = templates.first(where: { $0.id == eg2.gameTemplateId })?.name ?? ""
 330 |                 return n1 > n2
 331 |             }
 332 |         case .status:
 333 |             games.sort { $0.statusRaw < $1.statusRaw }
 334 |         }
 335 | 
 336 |         return games
 337 |     }
 338 | 
 339 |     // MARK: - Lifecycle UI
 340 | 
 341 |     private var lifecycleButton: some View {
 342 |         Menu {
 343 |             Button("Start") {
 344 |                 do { try engine.startEvent(event) } catch { present(error) }
 345 |             }
 346 |             Button("Pause") {
 347 |                 do { try engine.pauseEvent(event) } catch { present(error) }
 348 |             }
 349 |             Button("Resume") {
 350 |                 do { try engine.resumeEvent(event) } catch { present(error) }
 351 |             }
 352 |             Button("Complete") {
 353 |                 do {
 354 |                     event.status = .completed
 355 |                     event.currentEventGameId = nil
 356 |                     try context.save()
 357 |                 } catch {
 358 |                     present(error)
 359 |                 }
 360 |             }
 361 |             
 362 |             Divider()
 363 |             
 364 |             Button {
 365 |                 showEventStats = true
 366 |             } label: {
 367 |                 Label("View Stats", systemImage: "chart.bar.fill")
 368 |             }
 369 |         } label: {
 370 |             Text("Event")
 371 |                 .foregroundColor(themeManager.text)
 372 |         }
 373 |     }
 374 | 
 375 |     private func gameName(for eg: EventGame) -> String {
 376 |         templates.first(where: { $0.id == eg.gameTemplateId })?.name ?? "Unknown"
 377 |     }
 378 | 
 379 |     private func gameRow(for eg: EventGame) -> some View {
 380 |         let t = templates.first(where: { $0.id == eg.gameTemplateId })
 381 |         let name = t?.name ?? "Unknown Game"
 382 | 
 383 |         let teamCount = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 384 |         let playersPerTeam = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 385 | 
 386 |         let group = t?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 387 |         let groupText = (group?.isEmpty == false) ? group! : nil
 388 | 
 389 |         let subtitleBits = [
 390 |             groupText,
 391 |             "Teams: \(teamCount) × \(playersPerTeam)",
 392 |             "Status: \(eg.statusRaw.capitalized)"
 393 |         ].compactMap { $0 }
 394 | 
 395 |         return VStack(alignment: .leading, spacing: 3) {
 396 |             Text(name).font(.body)
 397 |             Text(subtitleBits.joined(separator: " • "))
 398 |                 .font(.footnote)
 399 |                 .foregroundStyle(.secondary)
 400 |         }
 401 |     }
 402 | 
 403 |     // MARK: - Mutations
 404 | 
 405 |     private func deleteEventGames(at offsets: IndexSet) {
 406 |         for index in offsets {
 407 |             let eg = filteredAndSortedGames[index]
 408 |             context.delete(eg)
 409 |             if let i = event.eventGames.firstIndex(where: { $0.id == eg.id }) {
 410 |                 event.eventGames.remove(at: i)
 411 |             }
 412 |         }
 413 |         try? context.save()
 414 |     }
 415 | 
 416 |     private func moveEventGames(from source: IndexSet, to destination: Int) {
 417 |         // Move within the underlying array using the view's ordering
 418 |         var underlying = filteredAndSortedGames
 419 |         underlying.move(fromOffsets: source, toOffset: destination)
 420 | 
 421 |         // Re-apply orderIndex according to new ordering
 422 |         for (i, eg) in underlying.enumerated() {
 423 |             eg.orderIndex = i
 424 |         }
 425 | 
 426 |         // Also update event.eventGames to keep a consistent ordering
 427 |         event.eventGames = underlying
 428 | 
 429 |         try? context.save()
 430 |     }
 431 | 
 432 |     private func present(_ error: Error) {
 433 |         message = error.localizedDescription
 434 |         showMessage = true
 435 |     }
 436 | }
 437 | 
 438 | // MARK: - Missing Screens (Minimal Implementations)
 439 | // These are intentionally simple so the app compiles.
 440 | // You can enhance them later without blocking builds.
 441 | 
 442 | private struct AddEventSheet: View {
 443 |     @Environment(\.dismiss) private var dismiss
 444 |     @Environment(\.modelContext) private var context
 445 |     @EnvironmentObject var themeManager: ThemeManager
 446 | 
 447 |     @State private var name: String = ""
 448 | 
 449 |     var body: some View {
 450 |         NavigationStack {
 451 |             Form {
 452 |                 Section("Event name") {
 453 |                     TextField("Christmas Party", text: $name)
 454 |                 }
 455 |             }
 456 |             .navigationTitle("New Event")
 457 |             .toolbar {
 458 |                 ToolbarItem(placement: .topBarLeading) {
 459 |                     Button("Cancel") { dismiss() }
 460 |                         .foregroundColor(themeManager.primary)
 461 |                 }
 462 |                 ToolbarItem(placement: .topBarTrailing) {
 463 |                     Button("Save") { save() }
 464 |                         .foregroundColor(themeManager.primary)
 465 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 466 |                 }
 467 |             }
 468 |         }
 469 |     }
 470 | 
 471 |     private func save() {
 472 |         let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
 473 |         guard !trimmed.isEmpty else { return }
 474 | 
 475 |         // Your RunGameView preview proves Event(name:) exists.
 476 |         let event = Event(name: trimmed)
 477 |         context.insert(event)
 478 |         try? context.save()
 479 |         dismiss()
 480 |     }
 481 | }
 482 | 
 483 | private struct ParticipantPickerSheet: View {
 484 |     @Environment(\.dismiss) private var dismiss
 485 |     @Environment(\.modelContext) private var context
 486 |     @EnvironmentObject var themeManager: ThemeManager
 487 | 
 488 |     let event: Event
 489 | 
 490 |     @Query(sort: \Person.displayName)
 491 |     private var people: [Person]
 492 | 
 493 |     @State private var selected: Set<UUID> = []
 494 | 
 495 |     var body: some View {
 496 |         NavigationStack {
 497 |             List {
 498 |                 ForEach(people.filter { $0.isActive }) { person in
 499 |                     Button {
 500 |                         toggle(person.id)
 501 |                     } label: {
 502 |                         HStack {
 503 |                             Text(person.displayName)
 504 |                             Spacer()
 505 |                             if selected.contains(person.id) {
 506 |                                 Image(systemName: "checkmark")
 507 |                                     .foregroundColor(themeManager.primary)
 508 |                             }
 509 |                         }
 510 |                     }
 511 |                 }
 512 |             }
 513 |             .navigationTitle("Participants")
 514 |             .toolbar {
 515 |                 ToolbarItem(placement: .topBarLeading) {
 516 |                     Button("Cancel") { dismiss() }
 517 |                         .foregroundColor(themeManager.primary)
 518 |                 }
 519 |                 ToolbarItem(placement: .topBarTrailing) {
 520 |                     Button("Done") { commit() }
 521 |                         .foregroundColor(themeManager.primary)
 522 |                 }
 523 |             }
 524 |             .onAppear {
 525 |                 selected = Set(event.participantIds)
 526 |             }
 527 |         }
 528 |     }
 529 | 
 530 |     private func toggle(_ id: UUID) {
 531 |         if selected.contains(id) {
 532 |             selected.remove(id)
 533 |         } else {
 534 |             selected.insert(id)
 535 |         }
 536 |     }
 537 | 
 538 |     private func commit() {
 539 |         event.participantIds = Array(selected)
 540 |         try? context.save()
 541 |         dismiss()
 542 |     }
 543 | }
 544 | 
 545 | private struct AddGamesSheet: View {
 546 |     @Environment(\.dismiss) private var dismiss
 547 |     @EnvironmentObject var themeManager: ThemeManager
 548 | 
 549 |     let event: Event
 550 |     let templates: [GameTemplate]
 551 | 
 552 |     var body: some View {
 553 |         NavigationStack {
 554 |             List {
 555 |                 Section {
 556 |                     Text("This screen is a minimal placeholder so the project builds.")
 557 |                         .foregroundStyle(.secondary)
 558 |                     Text("Next step is wiring this to create EventGame records from selected GameTemplates.")
 559 |                         .foregroundStyle(.secondary)
 560 |                 }
 561 | 
 562 |                 Section("Templates in catalog") {
 563 |                     ForEach(templates) { t in
 564 |                         VStack(alignment: .leading, spacing: 3) {
 565 |                             Text(t.name).font(.headline)
 566 |                             if let group = t.groupName, !group.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
 567 |                                 Text(group).font(.footnote).foregroundStyle(.secondary)
 568 |                             }
 569 |                         }
 570 |                     }
 571 |                 }
 572 |             }
 573 |             .navigationTitle("Add Games")
 574 |             .toolbar {
 575 |                 ToolbarItem(placement: .topBarLeading) {
 576 |                     Button("Close") { dismiss() }
 577 |                         .foregroundColor(themeManager.primary)
 578 |                 }
 579 |             }
 580 |         }
 581 |     }
 582 | }
 583 | 
 584 | private struct EventGameDetailView: View {
 585 |     @EnvironmentObject var themeManager: ThemeManager
 586 |     
 587 |     let event: Event
 588 |     let eventGame: EventGame
 589 | 
 590 |     var body: some View {
 591 |         Form {
 592 |             Section("Game") {
 593 |                 Text("This is a placeholder detail view.")
 594 |                     .foregroundStyle(.secondary)
 595 |             }
 596 |             Section("IDs") {
 597 |                 Text("EventGame ID: \(eventGame.id.uuidString)")
 598 |             }
 599 |         }
 600 |         .navigationTitle("Game Detail")
 601 |     }
 602 | }
 603 | 
 604 | 
 605 | #Preview {
 606 |     EventsListView()
 607 |         .modelContainer(for: [Event.self, Person.self, GameTemplate.self])
 608 |         .environmentObject(ThemeManager())
 609 | }


END FILE: ./Christmas Games/EventsListView.swift


