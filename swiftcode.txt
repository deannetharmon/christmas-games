################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift
################################################################################
   1 | //
   2 | //  Christmas_GamesUITestsLaunchTests.swift
   3 | //  Christmas GamesUITests
   4 | //
   5 | //  Created by Dean Roger Harmon on 12/16/25.
   6 | //
   7 | 
   8 | import XCTest
   9 | 
  10 | final class Christmas_GamesUITestsLaunchTests: XCTestCase {
  11 | 
  12 |     override class var runsForEachTargetApplicationUIConfiguration: Bool {
  13 |         true
  14 |     }
  15 | 
  16 |     override func setUpWithError() throws {
  17 |         continueAfterFailure = false
  18 |     }
  19 | 
  20 |     @MainActor
  21 |     func testLaunch() throws {
  22 |         let app = XCUIApplication()
  23 |         app.launch()
  24 | 
  25 |         // Insert steps here to perform after app launch but before taking a screenshot,
  26 |         // such as logging into a test account or navigating somewhere in the app
  27 | 
  28 |         let attachment = XCTAttachment(screenshot: app.screenshot())
  29 |         attachment.name = "Launch Screen"
  30 |         attachment.lifetime = .keepAlways
  31 |         add(attachment)
  32 |     }
  33 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift


################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift
################################################################################
   1 | import XCTest
   2 | 
   3 | final class MainMenuUITests: XCTestCase {
   4 |     
   5 |     func testNavigateToGameCatalog() throws {
   6 |         let app = XCUIApplication()
   7 |         app.launch()
   8 |         
   9 |         // Tap Game Catalog button
  10 |         app.buttons["Game Catalog"].tap()
  11 |         
  12 |         // Verify we're on the Game Catalog screen
  13 |         XCTAssertTrue(app.navigationBars["Game Catalog"].exists)
  14 |     }
  15 |     
  16 |     func testCreateNewEvent() throws {
  17 |         let app = XCUIApplication()
  18 |         app.launch()
  19 |         
  20 |         // Navigate to Events
  21 |         let eventsButton = app.buttons["Events"]
  22 |         XCTAssertTrue(eventsButton.exists)
  23 |         eventsButton.tap()
  24 |         
  25 |         // Tap Add Event
  26 |         app.buttons["Add Event"].tap()
  27 |         
  28 |         // Enter event name
  29 |         let eventNameField = app.textFields["Event Name"]
  30 |         eventNameField.tap()
  31 |         eventNameField.typeText("Test Event 2025")
  32 |         
  33 |         // Save
  34 |         app.buttons["Save"].tap()
  35 |         
  36 |         // Verify event appears in list
  37 |         XCTAssertTrue(app.staticTexts["Test Event 2025"].exists)
  38 |     }
  39 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift


################################################################################
START FILE: ./Christmas GamesTests/Christmas_GamesTests.swift
################################################################################
   1 | import XCTest
   2 | import SwiftData
   3 | @testable import Christmas_Games
   4 | 
   5 | final class EventEngineTests: XCTestCase {
   6 |     var context: ModelContext!
   7 |     var engine: EventEngine!
   8 |     
   9 |     @MainActor
  10 |     override func setUp() {
  11 |         super.setUp()
  12 |         // Create in-memory database for testing
  13 |         let config = ModelConfiguration(isStoredInMemoryOnly: true)
  14 |         let container = try! ModelContainer(
  15 |             for: Event.self, Person.self, GameTemplate.self, EventGame.self, Round.self,
  16 |             configurations: config
  17 |         )
  18 |         context = container.mainContext
  19 |         engine = EventEngine(context: context)
  20 |     }
  21 |     
  22 |     @MainActor
  23 |     func testStartEvent_WithNoParticipants_ThrowsError() throws {
  24 |         // Given: an event with no participants
  25 |         let event = Event(name: "Test Event")
  26 |         let template = GameTemplate(
  27 |             externalId: "test",
  28 |             name: "Test Game",
  29 |             defaultTeamCount: 2,
  30 |             defaultPlayersPerTeam: 2,
  31 |             defaultRoundsPerGame: 1,
  32 |             defaultTeamType: .any
  33 |         )
  34 |         context.insert(event)
  35 |         context.insert(template)
  36 |         
  37 |         let eventGame = EventGame(
  38 |             event: event,
  39 |             gameTemplateId: template.id,
  40 |             orderIndex: 0
  41 |         )
  42 |         context.insert(eventGame)
  43 |         event.eventGames.append(eventGame)
  44 |         
  45 |         // When/Then: starting should throw noParticipants error
  46 |         XCTAssertThrowsError(try engine.startEvent(event)) { error in
  47 |             XCTAssertEqual(error as? EventEngine.StartError, .noParticipants)
  48 |         }
  49 |     }
  50 |     
  51 |     @MainActor
  52 |     func testStartEvent_CreatesActiveRound() throws {
  53 |         // Given: an event with participants and a game
  54 |         let event = Event(name: "Test Event")
  55 |         let person1 = Person(displayName: "Test Person 1")
  56 |         let person2 = Person(displayName: "Test Person 2")
  57 |         
  58 |         context.insert(event)
  59 |         context.insert(person1)
  60 |         context.insert(person2)
  61 |         
  62 |         event.participantIds = [person1.id, person2.id]
  63 |         
  64 |         let template = GameTemplate(
  65 |             externalId: "test",
  66 |             name: "Test Game",
  67 |             defaultTeamCount: 2,
  68 |             defaultPlayersPerTeam: 1,
  69 |             defaultRoundsPerGame: 1,
  70 |             defaultTeamType: .any
  71 |         )
  72 |         context.insert(template)
  73 |         
  74 |         let eventGame = EventGame(
  75 |             event: event,
  76 |             gameTemplateId: template.id,
  77 |             orderIndex: 0
  78 |         )
  79 |         context.insert(eventGame)
  80 |         event.eventGames.append(eventGame)
  81 |         
  82 |         // When: starting the event
  83 |         try engine.startEvent(event)
  84 |         
  85 |         // Then: event should be active with a current game and an active round
  86 |         XCTAssertEqual(event.status, .active)
  87 |         XCTAssertNotNil(event.currentEventGameId)
  88 |         XCTAssertEqual(eventGame.status, .inProgress)
  89 |         XCTAssertEqual(eventGame.rounds.count, 1)
  90 |         
  91 |         let round = eventGame.rounds.first!
  92 |         XCTAssertNil(round.completedAt, "Round should not be completed")
  93 |     }
  94 |     
  95 |     @MainActor
  96 |     func testFinalizeRound_AssignsCorrectPlacements() throws {
  97 |         // Given: a round with teams
  98 |         let event = Event(name: "Test Event")
  99 |         let person1 = Person(displayName: "Person 1")
 100 |         let person2 = Person(displayName: "Person 2")
 101 |         
 102 |         context.insert(event)
 103 |         context.insert(person1)
 104 |         context.insert(person2)
 105 |         
 106 |         let template = GameTemplate(
 107 |             externalId: "test",
 108 |             name: "Test Game",
 109 |             defaultTeamCount: 2,
 110 |             defaultPlayersPerTeam: 1,
 111 |             defaultRoundsPerGame: 1,
 112 |             defaultTeamType: .any
 113 |         )
 114 |         context.insert(template)
 115 |         
 116 |         let eventGame = EventGame(
 117 |             event: event,
 118 |             gameTemplateId: template.id,
 119 |             orderIndex: 0
 120 |         )
 121 |         context.insert(eventGame)
 122 |         
 123 |         let round = Round(eventGame: eventGame, roundIndex: 0)
 124 |         context.insert(round)
 125 |         eventGame.rounds.append(round)
 126 |         
 127 |         let team1 = RoundTeam(memberPersonIds: [person1.id])
 128 |         let team2 = RoundTeam(memberPersonIds: [person2.id])
 129 |         round.teams = [team1, team2]
 130 |         
 131 |         // When: finalizing round with team1 as winner
 132 |         try engine.finalizeRound(round, winnerTeamId: team1.id)
 133 |         
 134 |         // Then: placements should be assigned correctly
 135 |         XCTAssertNotNil(round.completedAt)
 136 |         XCTAssertEqual(round.placements[person1.id], 1, "Winner should get 1st place")
 137 |         XCTAssertEqual(round.placements[person2.id], 2, "Loser should get 2nd place")
 138 |     }
 139 |     
 140 |     @MainActor
 141 |     func testResetEvent_ClearsAllGamesAndRounds() throws {
 142 |         // Given: an event with completed games and rounds
 143 |         let event = Event(name: "Test Event", status: .completed)
 144 |         context.insert(event)
 145 |         
 146 |         let template = GameTemplate(
 147 |             externalId: "test",
 148 |             name: "Test Game",
 149 |             defaultTeamCount: 2,
 150 |             defaultPlayersPerTeam: 1,
 151 |             defaultRoundsPerGame: 1,
 152 |             defaultTeamType: .any
 153 |         )
 154 |         context.insert(template)
 155 |         
 156 |         let eventGame = EventGame(
 157 |             event: event,
 158 |             gameTemplateId: template.id,
 159 |             orderIndex: 0,
 160 |             status: .completed
 161 |         )
 162 |         context.insert(eventGame)
 163 |         event.eventGames.append(eventGame)
 164 |         
 165 |         let round = Round(eventGame: eventGame, roundIndex: 0, completedAt: Date())
 166 |         context.insert(round)
 167 |         eventGame.rounds.append(round)
 168 |         
 169 |         // When: resetting the event
 170 |         try engine.resetEvent(event)
 171 |         
 172 |         // Then: event should be reset
 173 |         XCTAssertEqual(event.status, .available)
 174 |         XCTAssertNil(event.currentEventGameId)
 175 |         XCTAssertEqual(eventGame.status, .notStarted)
 176 |         XCTAssertTrue(eventGame.rounds.isEmpty, "All rounds should be deleted")
 177 |     }
 178 | }


END FILE: ./Christmas GamesTests/Christmas_GamesTests.swift


################################################################################
START FILE: ./Christmas Games/RunGameView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct RunGameView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     let event: Event
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var templates: [GameTemplate]
  15 | 
  16 |     @State private var message: String?
  17 |     @State private var showMessage = false
  18 | 
  19 |     @State private var showPickNextGame = false
  20 |     @State private var showResetConfirm = false
  21 | 
  22 |     @State private var showSwap = false
  23 |     @State private var swapOutgoing: UUID?
  24 | 
  25 |     @State private var showAfterRoundDialog = false
  26 |     @State private var isInPostRoundDecision = false
  27 | 
  28 |     @State private var showWinnerPicker = false
  29 |     @State private var showSkipConfirmation = false
  30 |     @State private var showEventStats = false
  31 | 
  32 |     @State private var showTransition = false
  33 |     @State private var pendingNextGame: EventGame?
  34 |     @State private var pendingShowAfterRoundDialog = false
  35 | 
  36 |     @State private var selectedWinnerTeamId: UUID?
  37 |     @State private var selectedSecondTeamId: UUID?
  38 |     @State private var showSecondPlacePicker = false
  39 |     @State private var showThirdPlacePicker = false
  40 | 
  41 |     // Winner celebration settings
  42 |     @AppStorage("winnerCelebration_enabled") private var winnerCelebrationEnabled: Bool = true
  43 |     @AppStorage("winnerCelebration_showForMultiRound") private var showCelebrationForMultiRound: Bool = false
  44 |     @AppStorage("winnerCelebration_useGifs") private var winnerCelebrationUseGifs: Bool = true
  45 | 
  46 |     // Winner celebration state
  47 |     @State private var showWinnerCelebrationOverlay = false
  48 |     @State private var celebrationTitle: String = ""
  49 |     @State private var celebrationLines: [String] = []
  50 | 
  51 |     @ViewBuilder
  52 |     private var winnerCelebrationLayer: some View {
  53 |         if showWinnerCelebrationOverlay {
  54 |             WinnerCelebrationOverlay(
  55 |                 title: celebrationTitle,
  56 |                 lines: celebrationLines,
  57 |                 useGifs: winnerCelebrationUseGifs,
  58 |                 onNext: {
  59 |                     withAnimation(.easeOut(duration: 0.2)) {
  60 |                         showWinnerCelebrationOverlay = false
  61 |                     }
  62 | 
  63 |                     // Always go to post-round menu after celebration
  64 |                     pendingShowAfterRoundDialog = false
  65 |                     isInPostRoundDecision = true
  66 |                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
  67 |                         showAfterRoundDialog = true
  68 |                     }
  69 |                 },
  70 |                 onClose: {
  71 |                     withAnimation(.easeOut(duration: 0.2)) {
  72 |                         showWinnerCelebrationOverlay = false
  73 |                     }
  74 | 
  75 |                     // Always go to post-round menu after celebration, even on Close
  76 |                     pendingShowAfterRoundDialog = false
  77 |                     isInPostRoundDecision = true
  78 |                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
  79 |                         showAfterRoundDialog = true
  80 |                     }
  81 |                 }
  82 |             )
  83 |             .transition(.opacity.combined(with: .scale))
  84 |             .zIndex(200)
  85 |         }
  86 |     }
  87 | 
  88 |     var body: some View {
  89 |         ZStack {
  90 |             themeManager.background
  91 |                 .ignoresSafeArea()
  92 | 
  93 |             // Scroll ONLY the main content (teams list gets tall)
  94 |             ScrollView {
  95 |                 VStack(spacing: 12) {
  96 |                     content
  97 |                 }
  98 |                 .padding(.horizontal)
  99 |                 .padding(.top, 12)
 100 |                 .padding(.bottom, 16)
 101 |             }
 102 |             .safeAreaPadding(.top)
 103 |             .safeAreaPadding(.bottom)
 104 | 
 105 |             // Overlays stay above scroll content
 106 |             if event.status == .paused {
 107 |                 pausedOverlay
 108 |             }
 109 | 
 110 |             winnerCelebrationLayer
 111 | 
 112 |             if showTransition {
 113 |                 GameTransitionView {
 114 |                     completeTransition()
 115 |                 }
 116 |                 .transition(.opacity)
 117 |                 .zIndex(100)
 118 |             }
 119 |         }
 120 |         .navigationTitle("Run Game")
 121 |         .toolbarBackground(.hidden, for: .navigationBar)
 122 |         .toolbar {
 123 |             ToolbarItem(placement: .topBarLeading) {
 124 |                 Menu {
 125 |                     Button {
 126 |                         showEventStats = true
 127 |                     } label: {
 128 |                         Label("View Stats", systemImage: "chart.bar.fill")
 129 |                     }
 130 |                 } label: {
 131 |                     Text("Event")
 132 |                         .foregroundColor(themeManager.text)
 133 |                 }
 134 |             }
 135 | 
 136 |             ToolbarItemGroup(placement: .topBarTrailing) {
 137 |                 // Pause/Resume button
 138 |                 if event.status == .active {
 139 |                     Button("Pause") {
 140 |                         do { try engine.pauseEvent(event) }
 141 |                         catch { show(error) }
 142 |                     }
 143 |                     .foregroundColor(themeManager.text)
 144 |                 } else if event.status == .paused {
 145 |                     Button("Resume") {
 146 |                         do { try engine.resumeEvent(event) }
 147 |                         catch { show(error) }
 148 |                     }
 149 |                     .foregroundColor(themeManager.text)
 150 |                 }
 151 | 
 152 |                 // Skip Game button (only when game is active and not paused)
 153 |                 if currentGame != nil && event.status == .active {
 154 |                     Button("Skip Game") { showSkipConfirmation = true }
 155 |                         .foregroundColor(themeManager.text)
 156 |                 }
 157 | 
 158 |                 // Pick Game button
 159 |                 Button("Pick Game") { showPickNextGame = true }
 160 |                     .foregroundColor(themeManager.text)
 161 |                     .disabled(event.status == .paused)
 162 |             }
 163 |         }
 164 |         .sheet(isPresented: $showPickNextGame) {
 165 |             PickNextGameSheet(event: event) { selection, skipMode in
 166 |                 handlePick(selection: selection, skipMode: skipMode)
 167 |             }
 168 |             .environmentObject(themeManager)
 169 |         }
 170 |         .sheet(isPresented: $showEventStats) {
 171 |             CurrentEventStatsSheet(event: event)
 172 |                 .environmentObject(themeManager)
 173 |                 .onDisappear {
 174 |                     // Reshow dialog if we were in post-round decision mode
 175 |                     if isInPostRoundDecision {
 176 |                         DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
 177 |                             showAfterRoundDialog = true
 178 |                         }
 179 |                     }
 180 |                 }
 181 |         }
 182 | 
 183 |         // ✅ UPDATED: Differentiated primary action using iconography + weight (Option 4)
 184 |         .confirmationDialog(
 185 |             "What would you like to do next?",
 186 |             isPresented: $showAfterRoundDialog,
 187 |             titleVisibility: .visible
 188 |         ) {
 189 |             if let eg = currentGame {
 190 |                 Button {
 191 |                     do {
 192 |                         _ = try engine.createNextRound(for: eg)
 193 |                         isInPostRoundDecision = false
 194 |                         showAfterRoundDialog = false
 195 |                     } catch {
 196 |                         show(error)
 197 |                     }
 198 |                 } label: {
 199 |                     Label("Play Another Round", systemImage: "arrow.triangle.2.circlepath")
 200 |                 }
 201 | 
 202 |                 Button {
 203 |                     isInPostRoundDecision = false
 204 |                     showAfterRoundDialog = false
 205 |                     handlePickNextGameRandom(currentGame: eg)
 206 |                 } label: {
 207 |                     Label("Continue to Next Game", systemImage: "arrow.right.circle.fill")
 208 |                 }
 209 |                 .fontWeight(.semibold)
 210 | 
 211 |                 Button {
 212 |                     isInPostRoundDecision = false
 213 |                     showAfterRoundDialog = false
 214 |                     showPickNextGame = true
 215 |                 } label: {
 216 |                     Label("Manually Choose Next Game", systemImage: "list.bullet.rectangle")
 217 |                 }
 218 | 
 219 |                 Button {
 220 |                     showEventStats = true
 221 |                     // Don't clear isInPostRoundDecision - we want to come back
 222 |                 } label: {
 223 |                     Label("View Event Stats", systemImage: "chart.bar.fill")
 224 |                 }
 225 | 
 226 |                 Button(role: .cancel) { } label: {
 227 |                     Label("Cancel", systemImage: "xmark")
 228 |                 }
 229 |             } else {
 230 |                 Button(role: .cancel) { } label: {
 231 |                     Label("Cancel", systemImage: "xmark")
 232 |                 }
 233 |             }
 234 |         }
 235 | 
 236 |         .confirmationDialog(
 237 |             "Select 2nd place",
 238 |             isPresented: $showSecondPlacePicker,
 239 |             titleVisibility: .visible
 240 |         ) {
 241 |             if let round = currentRound, let winnerId = selectedWinnerTeamId {
 242 |                 ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, t in
 243 |                     if t.id != winnerId {
 244 |                         Button("2nd: Team \(teamLabel(index)) – \(teamNames(t))") {
 245 |                             showSecondPlacePicker = false
 246 |                             DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
 247 |                                 completeSecondPlace(for: round, secondId: t.id)
 248 |                             }
 249 |                         }
 250 |                     }
 251 |                 }
 252 |             }
 253 |             Button("Cancel", role: .cancel) { }
 254 |         }
 255 | 
 256 |         .confirmationDialog(
 257 |             "Select 3rd place",
 258 |             isPresented: $showThirdPlacePicker,
 259 |             titleVisibility: .visible
 260 |         ) {
 261 |             if let round = currentRound, let winnerId = selectedWinnerTeamId, let secondId = selectedSecondTeamId {
 262 |                 ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, t in
 263 |                     if t.id != winnerId && t.id != secondId {
 264 |                         Button("3rd: Team \(teamLabel(index)) – \(teamNames(t))") {
 265 |                             showThirdPlacePicker = false
 266 |                             DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
 267 |                                 completeThirdPlace(for: round, thirdId: t.id)
 268 |                             }
 269 |                         }
 270 |                     }
 271 |                 }
 272 |             }
 273 |             Button("Cancel", role: .cancel) { }
 274 |         }
 275 | 
 276 |         .alert("Message", isPresented: $showMessage) {
 277 |             Button("OK", role: .cancel) { }
 278 |         } message: {
 279 |             Text(message ?? "Unknown error")
 280 |         }
 281 | 
 282 |         .confirmationDialog(
 283 |             "Reset Event",
 284 |             isPresented: $showResetConfirm,
 285 |             titleVisibility: .visible
 286 |         ) {
 287 |             Button("Reset Event", role: .destructive) {
 288 |                 do {
 289 |                     try EventEngine(context: context).resetEvent(event)
 290 |                 } catch {
 291 |                     show(error)
 292 |                 }
 293 |             }
 294 |             Button("Cancel", role: .cancel) { }
 295 |         } message: {
 296 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 297 |         }
 298 | 
 299 |         .confirmationDialog(
 300 |             "Skip Current Game",
 301 |             isPresented: $showSkipConfirmation,
 302 |             titleVisibility: .visible
 303 |         ) {
 304 |             Button("Skip to Next Game", role: .destructive) {
 305 |                 handleSkipGame()
 306 |             }
 307 |             Button("Cancel", role: .cancel) { }
 308 |         } message: {
 309 |             Text("This will skip the current game and move to the next available game. Current players will be carried over if possible.")
 310 |         }
 311 |     }
 312 | 
 313 |     private var pausedOverlay: some View {
 314 |         ZStack {
 315 |             Color.black.opacity(0.7)
 316 |                 .ignoresSafeArea()
 317 | 
 318 |             VStack(spacing: 20) {
 319 |                 Image(systemName: "pause.circle.fill")
 320 |                     .font(.system(size: 80))
 321 |                     .foregroundStyle(.white)
 322 | 
 323 |                 Text("Event Paused")
 324 |                     .font(.title)
 325 |                     .fontWeight(.bold)
 326 |                     .foregroundStyle(.white)
 327 | 
 328 |                 Button("Resume") {
 329 |                     do { try engine.resumeEvent(event) }
 330 |                     catch { show(error) }
 331 |                 }
 332 |                 .buttonStyle(.borderedProminent)
 333 |                 .controlSize(.large)
 334 |             }
 335 |         }
 336 |     }
 337 | 
 338 |     private var engine: EventEngine { EventEngine(context: context) }
 339 | 
 340 |     private var peopleById: [UUID: Person] {
 341 |         Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 342 |     }
 343 | 
 344 |     private var currentGame: EventGame? {
 345 |         guard let id = event.currentEventGameId else { return nil }
 346 |         return event.eventGames.first(where: { $0.id == id })
 347 |     }
 348 | 
 349 |     private var currentTemplate: GameTemplate? {
 350 |         guard let eg = currentGame else { return nil }
 351 |         return templates.first(where: { $0.id == eg.gameTemplateId })
 352 |     }
 353 | 
 354 |     private var currentRound: Round? {
 355 |         guard let eg = currentGame else { return nil }
 356 |         return eg.rounds
 357 |             .sorted(by: { $0.roundIndex > $1.roundIndex })
 358 |             .first(where: { $0.completedAt == nil })
 359 |     }
 360 | 
 361 |     private func teamLabel(_ index: Int) -> String {
 362 |         let scalar = UnicodeScalar(65 + index)!
 363 |         return String(Character(scalar))
 364 |     }
 365 | 
 366 |     private func teamNames(_ team: RoundTeam) -> String {
 367 |         team.memberPersonIds
 368 |             .compactMap { peopleById[$0]?.displayName }
 369 |             .joined(separator: ", ")
 370 |     }
 371 | 
 372 |     @ViewBuilder
 373 |     private var content: some View {
 374 |         if let eg = currentGame, let template = currentTemplate {
 375 |             header(template: template, eventGame: eg)
 376 |             if let round = currentRound {
 377 |                 roundCard(template: template, eventGame: eg, round: round)
 378 |             } else {
 379 |                 // No active round - either all rounds complete or none created yet
 380 |                 VStack(spacing: 16) {
 381 |                     if eg.rounds.isEmpty {
 382 |                         Text("No rounds created yet.")
 383 |                             .foregroundStyle(.secondary)
 384 | 
 385 |                         Button("Start First Round") {
 386 |                             do {
 387 |                                 _ = try engine.createNextRound(for: eg)
 388 |                             } catch {
 389 |                                 show(error)
 390 |                             }
 391 |                         }
 392 |                         .buttonStyle(.borderedProminent)
 393 |                         .disabled(event.status == .paused)
 394 |                     } else {
 395 |                         // All rounds are complete - ready for next game
 396 |                         Text("All rounds complete!")
 397 |                             .font(.title3)
 398 |                             .foregroundStyle(.secondary)
 399 | 
 400 |                         Button("Choose Next Game") {
 401 |                             isInPostRoundDecision = true
 402 |                             showAfterRoundDialog = true
 403 |                         }
 404 |                         .buttonStyle(.borderedProminent)
 405 |                         .disabled(event.status == .paused)
 406 |                     }
 407 |                 }
 408 |                 .padding()
 409 |             }
 410 |         } else {
 411 |             emptyState
 412 |         }
 413 |     }
 414 | 
 415 |     private var emptyState: some View {
 416 |         VStack(spacing: 12) {
 417 |             Text("No game is currently running.")
 418 |                 .foregroundStyle(.secondary)
 419 | 
 420 |             Button("Start Event") {
 421 |                 do { try engine.startEvent(event) }
 422 |                 catch { show(error) }
 423 |             }
 424 |             .buttonStyle(.borderedProminent)
 425 |             .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty || event.status == .paused)
 426 |         }
 427 |     }
 428 | 
 429 |     private func header(template: GameTemplate, eventGame: EventGame) -> some View {
 430 |         VStack(alignment: .leading, spacing: 8) {
 431 |             Text(template.name).font(.title2).bold()
 432 | 
 433 |             if let playInstructions = (eventGame.overridePlayInstructions ?? template.playInstructions),
 434 |                !playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
 435 |                 Text(playInstructions)
 436 |                     .foregroundStyle(.secondary)
 437 |             }
 438 | 
 439 |             HStack {
 440 |                 Text("Status: \(eventGame.statusRaw.capitalized)")
 441 |                     .foregroundStyle(.secondary)
 442 |                 Spacer()
 443 |                 Text("Players: \(event.participantIds.count)")
 444 |                     .foregroundStyle(.secondary)
 445 |             }
 446 |         }
 447 |     }
 448 | 
 449 |     private func roundCard(template: GameTemplate, eventGame: EventGame, round: Round) -> some View {
 450 |         VStack(alignment: .leading, spacing: 12) {
 451 |             HStack {
 452 |                 Text("Round \(round.roundIndex + 1)").font(.headline)
 453 |                 Spacer()
 454 |                 if round.isLocked { Text("Locked").foregroundStyle(.secondary) }
 455 |             }
 456 | 
 457 |             if round.teams.isEmpty {
 458 |                 Button("Generate Teams") {
 459 |                     do { try engine.generateTeams(for: round) }
 460 |                     catch { show(error) }
 461 |                 }
 462 |                 .buttonStyle(.borderedProminent)
 463 |                 .disabled(event.status == .paused)
 464 |             } else {
 465 |                 teamsList(round: round)
 466 | 
 467 |                 if !round.isLocked {
 468 |                     actionRowUnlocked(round: round)
 469 |                 } else {
 470 |                     Button("Continue") { showAfterRoundDialog = true }
 471 |                         .buttonStyle(.borderedProminent)
 472 |                         .disabled(event.status == .paused)
 473 |                 }
 474 | 
 475 |                 previousRoundsCompact(eventGame: eventGame)
 476 |             }
 477 |         }
 478 |         .sheet(isPresented: $showSwap) {
 479 |             SwapPlayerSheet(
 480 |                 event: event,
 481 |                 currentRound: round,
 482 |                 people: people,
 483 |                 outgoing: swapOutgoing
 484 |             ) { incoming in
 485 |                 do {
 486 |                     if let out = swapOutgoing {
 487 |                         try engine.swapPlayer(in: round, from: out, to: incoming)
 488 |                     }
 489 |                 } catch { show(error) }
 490 |             }
 491 |             .environmentObject(themeManager)
 492 |         }
 493 |     }
 494 | 
 495 |     private func teamsList(round: Round) -> some View {
 496 |         VStack(alignment: .leading, spacing: 10) {
 497 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, team in
 498 |                 VStack(alignment: .leading, spacing: 6) {
 499 |                     Text("Team \(teamLabel(index))")
 500 |                         .font(.subheadline)
 501 |                         .bold()
 502 |                         .foregroundColor(teamColor(for: index))
 503 | 
 504 |                     ForEach(team.memberPersonIds, id: \.self) { pid in
 505 |                         HStack {
 506 |                             Text(peopleById[pid]?.displayName ?? "Unknown")
 507 |                             Spacer()
 508 |                             if !round.isLocked && event.status != .paused {
 509 |                                 Button("Swap") {
 510 |                                     swapOutgoing = pid
 511 |                                     showSwap = true
 512 |                                 }
 513 |                                 .buttonStyle(.bordered)
 514 |                             }
 515 |                         }
 516 |                     }
 517 |                 }
 518 |                 .padding(.vertical, 6)
 519 |             }
 520 |         }
 521 |     }
 522 | 
 523 |     private func teamColor(for index: Int) -> Color {
 524 |         let colors: [Color] = [.red, .green, .yellow, .blue, .orange, .purple]
 525 |         return index < colors.count ? colors[index] : .primary
 526 |     }
 527 | 
 528 |     private func actionRowUnlocked(round: Round) -> some View {
 529 |         HStack {
 530 |             Button("Regenerate") {
 531 |                 do { try engine.generateTeams(for: round) }
 532 |                 catch { show(error) }
 533 |             }
 534 |             .buttonStyle(.bordered)
 535 |             .disabled(event.status == .paused)
 536 | 
 537 |             Spacer()
 538 | 
 539 |             Button("Select Winner") {
 540 |                 showWinnerPicker = true
 541 |             }
 542 |             .buttonStyle(.borderedProminent)
 543 |             .disabled(round.teams.isEmpty || event.status == .paused)
 544 |         }
 545 |         .confirmationDialog("Select winner", isPresented: $showWinnerPicker, titleVisibility: .visible) {
 546 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, t in
 547 |                 Button("Team \(teamLabel(index)) – \(teamNames(t))") {
 548 |                     do {
 549 |                         selectedWinnerTeamId = t.id
 550 |                         showWinnerPicker = false
 551 | 
 552 |                         DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
 553 |                             beginPlacementFlow(for: round)
 554 |                         }
 555 |                     } catch {
 556 |                         show(error)
 557 |                     }
 558 |                 }
 559 |             }
 560 | 
 561 |             Button("Tie") {
 562 |                 do {
 563 |                     try engine.finalizeRound(round, winnerTeamId: nil)
 564 |                     showWinnerPicker = false
 565 | 
 566 |                     DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
 567 |                         handleRoundFinalized(round: round, winnerTeamId: nil)
 568 |                     }
 569 |                 } catch {
 570 |                     show(error)
 571 |                 }
 572 |             }
 573 | 
 574 |             Button("Cancel", role: .cancel) { }
 575 |         }
 576 |     }
 577 | 
 578 |     // MARK: - Placement Flow (1st / 2nd / 3rd)
 579 | 
 580 |     private func beginPlacementFlow(for round: Round) {
 581 |         guard let winnerId = selectedWinnerTeamId else { return }
 582 |         let teamCount = round.teams.count
 583 | 
 584 |         // 2 teams: auto-assign 2nd as the other team
 585 |         if teamCount <= 2 {
 586 |             let second = round.teams.first(where: { $0.id != winnerId })?.id
 587 |             do {
 588 |                 try engine.finalizeRound(round, winnerTeamId: winnerId, secondTeamId: second, thirdTeamId: nil)
 589 |                 handleRoundFinalized(round: round, winnerTeamId: winnerId)
 590 |             } catch {
 591 |                 show(error)
 592 |             }
 593 |             return
 594 |         }
 595 | 
 596 |         // 3+ teams: ask for 2nd place
 597 |         selectedSecondTeamId = nil
 598 |         showSecondPlacePicker = true
 599 |     }
 600 | 
 601 |     private func completeSecondPlace(for round: Round, secondId: UUID) {
 602 |         selectedSecondTeamId = secondId
 603 |         guard let winnerId = selectedWinnerTeamId else { return }
 604 | 
 605 |         let teamCount = round.teams.count
 606 | 
 607 |         // 3 teams: auto-assign 3rd as the remaining team
 608 |         if teamCount == 3 {
 609 |             let third = round.teams.map(\.id).first(where: { $0 != winnerId && $0 != secondId })
 610 |             do {
 611 |                 try engine.finalizeRound(round, winnerTeamId: winnerId, secondTeamId: secondId, thirdTeamId: third)
 612 |                 handleRoundFinalized(round: round, winnerTeamId: winnerId)
 613 |             } catch {
 614 |                 show(error)
 615 |             }
 616 |             return
 617 |         }
 618 | 
 619 |         // 4+ teams: ask for 3rd place
 620 |         showThirdPlacePicker = true
 621 |     }
 622 | 
 623 |     private func completeThirdPlace(for round: Round, thirdId: UUID) {
 624 |         guard let winnerId = selectedWinnerTeamId, let secondId = selectedSecondTeamId else { return }
 625 |         do {
 626 |             try engine.finalizeRound(round, winnerTeamId: winnerId, secondTeamId: secondId, thirdTeamId: thirdId)
 627 |             handleRoundFinalized(round: round, winnerTeamId: winnerId)
 628 |         } catch {
 629 |             show(error)
 630 |         }
 631 |     }
 632 | 
 633 |     private func previousRoundsCompact(eventGame: EventGame) -> some View {
 634 |         let completed = eventGame.rounds
 635 |             .sorted { $0.roundIndex > $1.roundIndex }
 636 |             .filter { $0.completedAt != nil }
 637 | 
 638 |         return Group {
 639 |             if !completed.isEmpty {
 640 |                 Divider()
 641 |                 Text("Previous Rounds").font(.subheadline).bold()
 642 |                 ForEach(completed.prefix(3)) { r in
 643 |                     Text(historyLine(r))
 644 |                         .font(.footnote)
 645 |                         .foregroundStyle(.secondary)
 646 |                 }
 647 |             }
 648 |         }
 649 |     }
 650 | 
 651 |     private func historyLine(_ round: Round) -> String {
 652 |         if round.resultType == .tie {
 653 |             return "Round \(round.roundIndex + 1): Tie"
 654 |         }
 655 |         if let winTeam = round.winningTeamId,
 656 |            let team = round.teams.first(where: { $0.id == winTeam }) {
 657 |             let names = team.memberPersonIds
 658 |                 .compactMap { peopleById[$0]?.displayName }
 659 |                 .joined(separator: ", ")
 660 |             return "Round \(round.roundIndex + 1): Winner – \(names)"
 661 |         }
 662 |         return "Round \(round.roundIndex + 1): Completed"
 663 |     }
 664 | 
 665 |     private func handleRoundFinalized(round: Round, winnerTeamId: UUID?) {
 666 |         showTransition = false
 667 |         pendingNextGame = nil
 668 | 
 669 |         let shouldCelebrate = shouldShowWinnerCelebration(for: round)
 670 | 
 671 |         if winnerCelebrationEnabled && shouldCelebrate {
 672 |             buildCelebrationPayload(round: round, winnerTeamId: winnerTeamId)
 673 | 
 674 |             pendingShowAfterRoundDialog = true
 675 |             withAnimation(.spring(response: 0.35, dampingFraction: 0.8)) {
 676 |                 showWinnerCelebrationOverlay = true
 677 |             }
 678 |         } else {
 679 |             isInPostRoundDecision = true
 680 |             showAfterRoundDialog = true
 681 |         }
 682 |     }
 683 | 
 684 |     private func shouldShowWinnerCelebration(for round: Round) -> Bool {
 685 |         guard let eg = round.eventGame else { return true }
 686 |         let completedRoundCount = eg.rounds.filter { $0.completedAt != nil }.count
 687 | 
 688 |         if completedRoundCount > 1 {
 689 |             return showCelebrationForMultiRound
 690 |         }
 691 |         return true
 692 |     }
 693 | 
 694 |     private func buildCelebrationPayload(round: Round, winnerTeamId: UUID?) {
 695 |         if round.resultType == .tie || winnerTeamId == nil {
 696 |             celebrationTitle = "It’s a Tie!"
 697 |             celebrationLines = ["Everyone takes 1st place"]
 698 |             return
 699 |         }
 700 | 
 701 |         let placements = round.placements
 702 | 
 703 |         let first = placements
 704 |             .filter { $0.value == 1 }
 705 |             .compactMap { peopleById[$0.key]?.displayName }
 706 |             .sorted()
 707 | 
 708 |         let second = placements
 709 |             .filter { $0.value == 2 }
 710 |             .compactMap { peopleById[$0.key]?.displayName }
 711 |             .sorted()
 712 | 
 713 |         let third = placements
 714 |             .filter { $0.value == 3 }
 715 |             .compactMap { peopleById[$0.key]?.displayName }
 716 |             .sorted()
 717 | 
 718 |         celebrationTitle = "Congratulations!"
 719 |         var lines: [String] = []
 720 | 
 721 |         if !first.isEmpty { lines.append("1st Place: " + first.joined(separator: ", ")) }
 722 |         if !second.isEmpty { lines.append("2nd Place: " + second.joined(separator: ", ")) }
 723 |         if !third.isEmpty { lines.append("3rd Place: " + third.joined(separator: ", ")) }
 724 | 
 725 |         if lines.isEmpty { lines = ["Winners recorded"] }
 726 | 
 727 |         celebrationLines = lines
 728 |     }
 729 | 
 730 |     private func handlePickNextGameRandom(currentGame: EventGame) {
 731 |         do {
 732 |             try engine.completeGame(currentGame)
 733 | 
 734 |             if let next = try engine.pickNextGameRandom(event: event) {
 735 |                 pendingNextGame = next
 736 |                 withAnimation {
 737 |                     showTransition = true
 738 |                 }
 739 |             } else {
 740 |                 event.status = .completed
 741 |                 try context.save()
 742 |             }
 743 |         } catch {
 744 |             show(error)
 745 |         }
 746 |     }
 747 | 
 748 |     private func handlePick(selection: EventGame, skipMode: PickNextGameSheet.SkipMode?) {
 749 |         do {
 750 |             if let skipMode {
 751 |                 if skipMode == .pushLater { try engine.pushGameToLater(selection) }
 752 |                 if skipMode == .remove { try engine.removeGameFromEvent(selection) }
 753 |                 return
 754 |             }
 755 | 
 756 |             if let cg = currentGame {
 757 |                 try engine.completeGame(cg)
 758 |             }
 759 | 
 760 |             pendingNextGame = selection
 761 |             withAnimation {
 762 |                 showTransition = true
 763 |             }
 764 |         } catch {
 765 |             show(error)
 766 |         }
 767 |     }
 768 | 
 769 |     private func completeTransition() {
 770 |         do {
 771 |             if let nextGame = pendingNextGame {
 772 |                 try engine.start(event: event, eventGame: nextGame)
 773 |                 try context.save()
 774 |             }
 775 | 
 776 |             withAnimation {
 777 |                 showTransition = false
 778 |             }
 779 |             pendingNextGame = nil
 780 |         } catch {
 781 |             show(error)
 782 |             withAnimation {
 783 |                 showTransition = false
 784 |             }
 785 |             pendingNextGame = nil
 786 |         }
 787 |     }
 788 | 
 789 |     private func handleSkipGame() {
 790 |         guard let game = currentGame else { return }
 791 | 
 792 |         let playerIds: [UUID]
 793 |         if let round = currentRound, !round.teams.isEmpty {
 794 |             playerIds = round.teams.flatMap { $0.memberPersonIds }
 795 |         } else {
 796 |             playerIds = []
 797 |         }
 798 | 
 799 |         do {
 800 |             try engine.skipToNextGame(game, keepingPlayers: playerIds)
 801 |             try context.save()
 802 |         } catch {
 803 |             show(error)
 804 |         }
 805 |     }
 806 | 
 807 |     private func show(_ error: Error) {
 808 |         message = error.localizedDescription
 809 |         showMessage = true
 810 |     }
 811 | }
 812 | 
 813 | // MARK: - Pick Next Game
 814 | 
 815 | struct PickNextGameSheet: View {
 816 |     enum SkipMode { case pushLater, remove }
 817 | 
 818 |     @Environment(\.dismiss) private var dismiss
 819 | 
 820 |     let event: Event
 821 |     let onPick: (EventGame, SkipMode?) -> Void
 822 | 
 823 |     @Query(sort: \GameTemplate.name)
 824 |     private var templates: [GameTemplate]
 825 | 
 826 |     // Filter and sort state
 827 |     @State private var searchText = ""
 828 |     @AppStorage("pickNextGame_filterTeamSize") private var filterTeamSize: Int?
 829 |     @AppStorage("pickNextGame_filterTeamCount") private var filterTeamCount: Int?
 830 |     @AppStorage("pickNextGame_sortOption") private var sortOption: SortOption = .orderIndex
 831 |     @AppStorage("pickNextGame_teamTypeFilter") private var teamTypeFilter: TeamTypeFilter = .all
 832 |     @AppStorage("pickNextGame_statusFilter") private var statusFilter: StatusFilter = .active
 833 | 
 834 |     enum SortOption: String, CaseIterable, Codable {
 835 |         case orderIndex = "Order"
 836 |         case alphabetical = "A-Z"
 837 |         case reverseAlphabetical = "Z-A"
 838 |     }
 839 | 
 840 |     enum TeamTypeFilter: String, CaseIterable, Codable {
 841 |         case all = "All"
 842 |         case any = "Any"
 843 |         case maleOnly = "Male Only"
 844 |         case femaleOnly = "Female Only"
 845 |         case couplesOnly = "Couples Only"
 846 |     }
 847 | 
 848 |     enum StatusFilter: String, CaseIterable, Codable {
 849 |         case active = "Active"
 850 |         case notStarted = "Not Started"
 851 |         case allGames = "All Games"
 852 |     }
 853 | 
 854 |     var body: some View {
 855 |         NavigationStack {
 856 |             List {
 857 |                 Section {
 858 |                     HStack {
 859 |                         Image(systemName: "magnifyingglass")
 860 |                             .foregroundStyle(.secondary)
 861 |                         TextField("Search games...", text: $searchText)
 862 |                             .textFieldStyle(.plain)
 863 |                         if !searchText.isEmpty {
 864 |                             Button {
 865 |                                 searchText = ""
 866 |                             } label: {
 867 |                                 Image(systemName: "xmark.circle.fill")
 868 |                                     .foregroundStyle(.secondary)
 869 |                             }
 870 |                         }
 871 |                     }
 872 |                     .padding(.vertical, 4)
 873 | 
 874 |                     HStack {
 875 |                         Picker("Team Size", selection: $filterTeamSize) {
 876 |                             Text("Any").tag(nil as Int?)
 877 |                             ForEach(availableTeamSizes, id: \.self) { size in
 878 |                                 Text("\(size)").tag(size as Int?)
 879 |                             }
 880 |                         }
 881 |                         .pickerStyle(.menu)
 882 | 
 883 |                         Picker("Teams", selection: $filterTeamCount) {
 884 |                             Text("Any").tag(nil as Int?)
 885 |                             ForEach(availableTeamCounts, id: \.self) { count in
 886 |                                 Text("\(count)").tag(count as Int?)
 887 |                             }
 888 |                         }
 889 |                         .pickerStyle(.menu)
 890 |                     }
 891 | 
 892 |                     HStack {
 893 |                         Picker("Sort", selection: $sortOption) {
 894 |                             ForEach(SortOption.allCases, id: \.self) { option in
 895 |                                 Text(option.rawValue).tag(option)
 896 |                             }
 897 |                         }
 898 |                         .pickerStyle(.menu)
 899 | 
 900 |                         Picker("Team Type", selection: $teamTypeFilter) {
 901 |                             ForEach(TeamTypeFilter.allCases, id: \.self) { filter in
 902 |                                 Text(filter.rawValue).tag(filter)
 903 |                             }
 904 |                         }
 905 |                         .pickerStyle(.menu)
 906 |                     }
 907 | 
 908 |                     Picker("Status", selection: $statusFilter) {
 909 |                         ForEach(StatusFilter.allCases, id: \.self) { filter in
 910 |                             Text(filter.rawValue).tag(filter)
 911 |                         }
 912 |                     }
 913 |                     .pickerStyle(.segmented)
 914 |                 } header: {
 915 |                     Text("\(statusFilter.rawValue) Games (\(filteredAndSortedGames.count))")
 916 |                 }
 917 | 
 918 |                 Section("Select Game") {
 919 |                     ForEach(filteredAndSortedGames) { eg in
 920 |                         Button {
 921 |                             onPick(eg, nil)
 922 |                             dismiss()
 923 |                         } label: {
 924 |                             gameRow(for: eg)
 925 |                         }
 926 |                     }
 927 |                 }
 928 | 
 929 |                 if !filteredAndSortedGames.isEmpty {
 930 |                     Section("Skip Options") {
 931 |                         ForEach(filteredAndSortedGames) { eg in
 932 |                             Menu {
 933 |                                 Button("Push to later") {
 934 |                                     onPick(eg, .pushLater)
 935 |                                     dismiss()
 936 |                                 }
 937 |                                 Button("Remove from event", role: .destructive) {
 938 |                                     onPick(eg, .remove)
 939 |                                     dismiss()
 940 |                                 }
 941 |                             } label: {
 942 |                                 Text("Skip \(gameName(for: eg))")
 943 |                             }
 944 |                         }
 945 |                     }
 946 |                 }
 947 |             }
 948 |             .navigationTitle("Choose Next Game")
 949 |             .toolbar {
 950 |                 ToolbarItem(placement: .topBarLeading) {
 951 |                     Button("Close") { dismiss() }
 952 |                 }
 953 |             }
 954 |         }
 955 |     }
 956 | 
 957 |     private var availableTeamSizes: [Int] {
 958 |         let sizes = eligibleGames.compactMap { eg -> Int? in
 959 |             let t = template(for: eg)
 960 |             return eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam
 961 |         }
 962 |         return Array(Set(sizes)).sorted()
 963 |     }
 964 | 
 965 |     private var availableTeamCounts: [Int] {
 966 |         let counts = eligibleGames.compactMap { eg -> Int? in
 967 |             let t = template(for: eg)
 968 |             return eg.overrideTeamCount ?? t?.defaultTeamCount
 969 |         }
 970 |         return Array(Set(counts)).sorted()
 971 |     }
 972 | 
 973 |     private var eligibleGames: [EventGame] {
 974 |         let games = event.eventGames
 975 | 
 976 |         switch statusFilter {
 977 |         case .notStarted:
 978 |             return games.filter { $0.status == .notStarted }
 979 | 
 980 |         case .active:
 981 |             return games.filter { eg in
 982 |                 if eg.status == .notStarted { return true }
 983 | 
 984 |                 if eg.status == .inProgress {
 985 |                     let hasCompletedRoundWithWinner = eg.rounds.contains { round in
 986 |                         round.completedAt != nil &&
 987 |                         (round.winningTeamId != nil || round.resultType == .tie)
 988 |                     }
 989 |                     return !hasCompletedRoundWithWinner
 990 |                 }
 991 |                 return false
 992 |             }
 993 | 
 994 |         case .allGames:
 995 |             return games
 996 |         }
 997 |     }
 998 | 
 999 |     private var filteredAndSortedGames: [EventGame] {
1000 |         var result = eligibleGames
1001 | 
1002 |         if !searchText.isEmpty {
1003 |             result = result.filter { eg in
1004 |                 let t = template(for: eg)
1005 |                 let name = t?.name ?? ""
1006 |                 let group = t?.groupName ?? ""
1007 |                 return name.localizedCaseInsensitiveContains(searchText) ||
1008 |                 group.localizedCaseInsensitiveContains(searchText)
1009 |             }
1010 |         }
1011 | 
1012 |         if let filterTeamSize {
1013 |             result = result.filter { eg in
1014 |                 let t = template(for: eg)
1015 |                 let size = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 0
1016 |                 return size == filterTeamSize
1017 |             }
1018 |         }
1019 | 
1020 |         if let filterTeamCount {
1021 |             result = result.filter { eg in
1022 |                 let t = template(for: eg)
1023 |                 let count = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 0
1024 |                 return count == filterTeamCount
1025 |             }
1026 |         }
1027 | 
1028 |         if teamTypeFilter != .all {
1029 |             result = result.filter { eg in
1030 |                 let t = template(for: eg)
1031 |                 let teamType = eg.overrideTeamType ?? t?.defaultTeamType ?? .any
1032 | 
1033 |                 switch teamTypeFilter {
1034 |                 case .all:
1035 |                     return true
1036 |                 case .any:
1037 |                     return teamType == .any
1038 |                 case .maleOnly:
1039 |                     return teamType == .maleOnly
1040 |                 case .femaleOnly:
1041 |                     return teamType == .femaleOnly
1042 |                 case .couplesOnly:
1043 |                     return teamType == .couplesOnly
1044 |                 }
1045 |             }
1046 |         }
1047 | 
1048 |         switch sortOption {
1049 |         case .orderIndex:
1050 |             result.sort { $0.orderIndex < $1.orderIndex }
1051 |         case .alphabetical:
1052 |             result.sort { eg1, eg2 in
1053 |                 let n1 = gameName(for: eg1)
1054 |                 let n2 = gameName(for: eg2)
1055 |                 return n1.localizedCaseInsensitiveCompare(n2) == .orderedAscending
1056 |             }
1057 |         case .reverseAlphabetical:
1058 |             result.sort { eg1, eg2 in
1059 |                 let n1 = gameName(for: eg1)
1060 |                 let n2 = gameName(for: eg2)
1061 |                 return n1.localizedCaseInsensitiveCompare(n2) == .orderedDescending
1062 |             }
1063 |         }
1064 | 
1065 |         return result
1066 |     }
1067 | 
1068 |     private func template(for eg: EventGame) -> GameTemplate? {
1069 |         templates.first(where: { $0.id == eg.gameTemplateId })
1070 |     }
1071 | 
1072 |     private func gameName(for eg: EventGame) -> String {
1073 |         template(for: eg)?.name ?? "Unknown Game"
1074 |     }
1075 | 
1076 |     private func gameRow(for eg: EventGame) -> some View {
1077 |         let t = template(for: eg)
1078 | 
1079 |         let name = t?.name ?? "Unknown Game"
1080 |         let group = t?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
1081 |         let groupText = (group?.isEmpty == false) ? group! : nil
1082 | 
1083 |         let teamCount = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 2
1084 |         let playersPerTeam = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
1085 | 
1086 |         let teamSizeText = "Teams: \(teamCount) × \(playersPerTeam)"
1087 |         let subtitle = groupText != nil ? "\(groupText!) • \(teamSizeText)" : teamSizeText
1088 | 
1089 |         return VStack(alignment: .leading, spacing: 3) {
1090 |             Text(name)
1091 |                 .font(.body)
1092 | 
1093 |             Text(subtitle)
1094 |                 .font(.footnote)
1095 |                 .foregroundStyle(.secondary)
1096 |         }
1097 |     }
1098 | }
1099 | 
1100 | // MARK: - Swap Player
1101 | 
1102 | struct SwapPlayerSheet: View {
1103 |     @Environment(\.dismiss) private var dismiss
1104 | 
1105 |     let event: Event
1106 |     let currentRound: Round
1107 |     let people: [Person]
1108 |     let outgoing: UUID?
1109 | 
1110 |     let onSwap: (UUID) -> Void
1111 | 
1112 |     var body: some View {
1113 |         let inRound = Set(currentRound.teams.flatMap { $0.memberPersonIds })
1114 |         let bench = people.filter { event.participantIds.contains($0.id) && !inRound.contains($0.id) && $0.isActive }
1115 | 
1116 |         NavigationStack {
1117 |             List {
1118 |                 Section {
1119 |                     Text("Outgoing: \(name(outgoing))")
1120 |                         .foregroundStyle(.secondary)
1121 |                 }
1122 | 
1123 |                 Section("Choose replacement") {
1124 |                     ForEach(bench) { p in
1125 |                         Button(p.displayName) {
1126 |                             onSwap(p.id)
1127 |                             dismiss()
1128 |                         }
1129 |                     }
1130 |                 }
1131 |             }
1132 |             .navigationTitle("Swap Player")
1133 |             .toolbar {
1134 |                 ToolbarItem(placement: .topBarLeading) {
1135 |                     Button("Cancel") { dismiss() }
1136 |                 }
1137 |             }
1138 |         }
1139 |     }
1140 | 
1141 |     private func name(_ id: UUID?) -> String {
1142 |         guard let id else { return "None" }
1143 |         return people.first(where: { $0.id == id })?.displayName ?? "Unknown"
1144 |     }
1145 | }
1146 | 
1147 | #Preview {
1148 |     let config = ModelConfiguration(isStoredInMemoryOnly: true)
1149 |     let container = try! ModelContainer(for: Event.self, Person.self, GameTemplate.self, configurations: config)
1150 | 
1151 |     let event = Event(name: "Test Event")
1152 |     container.mainContext.insert(event)
1153 | 
1154 |     return NavigationStack {
1155 |         RunGameView(event: event)
1156 |     }
1157 |     .modelContainer(container)
1158 |     .environmentObject(ThemeManager())
1159 | }


END FILE: ./Christmas Games/RunGameView.swift


################################################################################
START FILE: ./Christmas Games/CreatePersonSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreatePersonSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var allPeople: [Person]
  10 | 
  11 |     @State private var displayName = ""
  12 |     @State private var sex = "M"
  13 |     @State private var weightCategory = "M"
  14 |     @State private var heightCategory = "M"
  15 |     @State private var spouseId: UUID?
  16 |     @State private var isActive = true
  17 | 
  18 |     var body: some View {
  19 |         NavigationStack {
  20 |             Form {
  21 |                 Section("Basic") {
  22 |                     TextField("Name", text: $displayName)
  23 |                 }
  24 | 
  25 |                 Section("Details") {
  26 |                     HStack {
  27 |                         Text("Gender:")
  28 |                         Spacer()
  29 |                         Picker("Gender", selection: $sex) {
  30 |                             Text("M").tag("M")
  31 |                             Text("F").tag("F")
  32 |                         }
  33 |                         .pickerStyle(.segmented)
  34 |                         .labelsHidden()
  35 |                         .frame(width: 120)
  36 |                     }
  37 | 
  38 |                     HStack {
  39 |                         Text("Weight:")
  40 |                         Spacer()
  41 |                         Picker("Weight", selection: $weightCategory) {
  42 |                             Text("S").tag("S")
  43 |                             Text("M").tag("M")
  44 |                             Text("L").tag("L")
  45 |                         }
  46 |                         .pickerStyle(.segmented)
  47 |                         .labelsHidden()
  48 |                         .frame(width: 120)
  49 |                     }
  50 | 
  51 |                     HStack {
  52 |                         Text("Height:")
  53 |                         Spacer()
  54 |                         Picker("Height", selection: $heightCategory) {
  55 |                             Text("S").tag("S")
  56 |                             Text("M").tag("M")
  57 |                             Text("L").tag("L")
  58 |                         }
  59 |                         .pickerStyle(.segmented)
  60 |                         .labelsHidden()
  61 |                         .frame(width: 120)
  62 |                     }
  63 |                 }
  64 | 
  65 |                 Section("Spouse (Optional)") {
  66 |                     Picker("Spouse", selection: $spouseId) {
  67 |                         Text("None").tag(nil as UUID?)
  68 |                         ForEach(allPeople.filter { $0.isActive }) { person in
  69 |                             Text(person.displayName).tag(person.id as UUID?)
  70 |                         }
  71 |                     }
  72 |                 }
  73 | 
  74 |                 Section {
  75 |                     Toggle("Active", isOn: $isActive)
  76 |                 }
  77 |             }
  78 |             .navigationTitle("Add Participant")
  79 |             .toolbar {
  80 |                 ToolbarItem(placement: .topBarLeading) {
  81 |                     Button("Cancel") { dismiss() }
  82 |                 }
  83 | 
  84 |                 ToolbarItemGroup(placement: .topBarTrailing) {
  85 |                     Button("Save & Add Another") { saveAndContinue() }
  86 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  87 |                     
  88 |                     Button("Done") { saveAndDismiss() }
  89 |                 }
  90 |             }
  91 |         }
  92 |     }
  93 | 
  94 |     private func saveAndContinue() {
  95 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
  96 |         guard !trimmedName.isEmpty else { return }
  97 | 
  98 |         let person = Person(
  99 |             displayName: trimmedName,
 100 |             sex: sex,
 101 |             spouseId: spouseId,
 102 |             isActive: isActive
 103 |         )
 104 |         person.weightCategory = weightCategory
 105 |         person.heightCategory = heightCategory
 106 | 
 107 |         context.insert(person)
 108 |         try? context.save()
 109 |         
 110 |         // Reset form for next entry
 111 |         displayName = ""
 112 |         sex = "M"
 113 |         weightCategory = "M"
 114 |         heightCategory = "M"
 115 |         spouseId = nil
 116 |         isActive = true
 117 |     }
 118 |     
 119 |     private func saveAndDismiss() {
 120 |         // Only save if there's a name entered
 121 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 122 |         if !trimmedName.isEmpty {
 123 |             let person = Person(
 124 |                 displayName: trimmedName,
 125 |                 sex: sex,
 126 |                 spouseId: spouseId,
 127 |                 isActive: isActive
 128 |             )
 129 |             person.weightCategory = weightCategory
 130 |             person.heightCategory = heightCategory
 131 | 
 132 |             context.insert(person)
 133 |             try? context.save()
 134 |         }
 135 |         
 136 |         dismiss()
 137 |     }
 138 | }
 139 | 
 140 | struct EditPersonSheet: View {
 141 |     @Environment(\.dismiss) private var dismiss
 142 |     @Environment(\.modelContext) private var context
 143 | 
 144 |     @Query(sort: \Person.displayName)
 145 |     private var allPeople: [Person]
 146 | 
 147 |     let person: Person
 148 | 
 149 |     @State private var displayName = ""
 150 |     @State private var sex = "M"
 151 |     @State private var weightCategory = "M"
 152 |     @State private var heightCategory = "M"
 153 |     @State private var spouseId: UUID?
 154 |     @State private var isActive = true
 155 | 
 156 |     var body: some View {
 157 |         NavigationStack {
 158 |             Form {
 159 |                 Section("Basic") {
 160 |                     TextField("Name", text: $displayName)
 161 |                 }
 162 | 
 163 |                 Section("Details") {
 164 |                     HStack {
 165 |                         Text("Gender:")
 166 |                         Spacer()
 167 |                         Picker("Gender", selection: $sex) {
 168 |                             Text("M").tag("M")
 169 |                             Text("F").tag("F")
 170 |                         }
 171 |                         .pickerStyle(.segmented)
 172 |                         .labelsHidden()
 173 |                         .frame(width: 120)
 174 |                     }
 175 | 
 176 |                     HStack {
 177 |                         Text("Weight:")
 178 |                         Spacer()
 179 |                         Picker("Weight", selection: $weightCategory) {
 180 |                             Text("S").tag("S")
 181 |                             Text("M").tag("M")
 182 |                             Text("L").tag("L")
 183 |                         }
 184 |                         .pickerStyle(.segmented)
 185 |                         .labelsHidden()
 186 |                         .frame(width: 120)
 187 |                     }
 188 | 
 189 |                     HStack {
 190 |                         Text("Height:")
 191 |                         Spacer()
 192 |                         Picker("Height", selection: $heightCategory) {
 193 |                             Text("S").tag("S")
 194 |                             Text("M").tag("M")
 195 |                             Text("L").tag("L")
 196 |                         }
 197 |                         .pickerStyle(.segmented)
 198 |                         .labelsHidden()
 199 |                         .frame(width: 120)
 200 |                     }
 201 |                 }
 202 | 
 203 |                 Section("Spouse (Optional)") {
 204 |                     Picker("Spouse", selection: $spouseId) {
 205 |                         Text("None").tag(nil as UUID?)
 206 |                         ForEach(allPeople.filter { $0.id != person.id && $0.isActive }) { p in
 207 |                             Text(p.displayName).tag(p.id as UUID?)
 208 |                         }
 209 |                     }
 210 |                 }
 211 | 
 212 |                 Section {
 213 |                     Toggle("Active", isOn: $isActive)
 214 |                 }
 215 |             }
 216 |             .navigationTitle("Edit Participant")
 217 |             .toolbar {
 218 |                 ToolbarItem(placement: .topBarLeading) {
 219 |                     Button("Cancel") { dismiss() }
 220 |                 }
 221 | 
 222 |                 ToolbarItem(placement: .topBarTrailing) {
 223 |                     Button("Save") { save() }
 224 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 225 |                 }
 226 |             }
 227 |             .onAppear {
 228 |                 displayName = person.displayName
 229 |                 sex = person.sex ?? "M"
 230 |                 weightCategory = person.weightCategory ?? "M"
 231 |                 heightCategory = person.heightCategory ?? "M"
 232 |                 spouseId = person.spouseId
 233 |                 isActive = person.isActive
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func save() {
 239 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 240 |         guard !trimmedName.isEmpty else { return }
 241 | 
 242 |         person.displayName = trimmedName
 243 |         person.sex = sex
 244 |         person.weightCategory = weightCategory
 245 |         person.heightCategory = heightCategory
 246 |         person.spouseId = spouseId
 247 |         person.isActive = isActive
 248 | 
 249 |         try? context.save()
 250 |         dismiss()
 251 |     }
 252 | }
 253 | 
 254 | #Preview {
 255 |     CreatePersonSheet()
 256 |         .modelContainer(for: [Person.self])
 257 | }


END FILE: ./Christmas Games/CreatePersonSheet.swift


################################################################################
START FILE: ./Christmas Games/MainMenuView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | /// Main Menu matching the PDF wireframe (vertical menu buttons).
   5 | /// Order (per wireframe): Events → Game Catalog → Participant Catalog → Start/Resume Event → Event Stats
   6 | struct MainMenuView: View {
   7 |     @Query(sort: \Event.createdAt, order: .reverse)
   8 |     private var events: [Event]
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var games: [GameTemplate]
  15 |     
  16 |     @StateObject private var themeManager = ThemeManager()
  17 |     @State private var showThemeSettings = false
  18 |     @State private var showGameSettings = false
  19 | 
  20 |     var body: some View {
  21 |         NavigationStack {
  22 |             ZStack {
  23 |                 // Solid color background based on theme
  24 |                 themeManager.background
  25 |                     .ignoresSafeArea()
  26 |                 
  27 |                 VStack(spacing: 0) {
  28 |                     header
  29 | 
  30 |                     ScrollView {
  31 |                         VStack(spacing: 14) {
  32 |                             NavigationLink {
  33 |                                 EventsListView()
  34 |                                     .environmentObject(themeManager)
  35 |                             } label: {
  36 |                                 MenuRow(
  37 |                                     title: "Events",
  38 |                                     subtitle: "\(events.count) total",
  39 |                                     systemImage: "calendar"
  40 |                                 )
  41 |                             }
  42 | 
  43 |                             NavigationLink {
  44 |                                 GameCatalogView()
  45 |                                     .environmentObject(themeManager)
  46 |                             } label: {
  47 |                                 MenuRow(
  48 |                                     title: "Game Catalog",
  49 |                                     subtitle: "\(games.count) games",
  50 |                                     systemImage: "list.bullet.rectangle"
  51 |                                 )
  52 |                             }
  53 | 
  54 |                             NavigationLink {
  55 |                                 ParticipantCatalogView()
  56 |                                     .environmentObject(themeManager)
  57 |                             } label: {
  58 |                                 MenuRow(
  59 |                                     title: "Participant Catalog",
  60 |                                     subtitle: "\(people.count) participants",
  61 |                                     systemImage: "person.3"
  62 |                                 )
  63 |                             }
  64 | 
  65 |                             NavigationLink {
  66 |                                 EventStatsView()
  67 |                                     .environmentObject(themeManager)
  68 |                             } label: {
  69 |                                 MenuRow(
  70 |                                     title: "Event Stats",
  71 |                                     subtitle: "Results grid",
  72 |                                     systemImage: "chart.bar"
  73 |                                 )
  74 |                             }
  75 |                         }
  76 |                         .padding(16)
  77 |                     }
  78 |                 }
  79 |             }
  80 |             .toolbar {
  81 |                 ToolbarItemGroup(placement: .topBarTrailing) {
  82 |                     Button {
  83 |                         showGameSettings = true
  84 |                     } label: {
  85 |                         Image(systemName: "gear")
  86 |                             .foregroundColor(themeManager.text)
  87 |                             .font(.title3)
  88 |                     }
  89 |                     
  90 |                     Button {
  91 |                         showThemeSettings = true
  92 |                     } label: {
  93 |                         Image(systemName: "paintpalette.fill")
  94 |                             .foregroundColor(themeManager.text)
  95 |                             .font(.title3)
  96 |                     }
  97 |                 }
  98 |             }
  99 |             .toolbarBackground(.hidden, for: .navigationBar)
 100 |             .sheet(isPresented: $showThemeSettings) {
 101 |                 ThemeSettingsView()
 102 |                     .environmentObject(themeManager)
 103 |             }
 104 |             .sheet(isPresented: $showGameSettings) {
 105 |                 GameSettingsView()
 106 |                     .environmentObject(themeManager)
 107 |             }
 108 |         }
 109 |         .environmentObject(themeManager)
 110 |     }
 111 | 
 112 |     private var header: some View {
 113 |         VStack(spacing: 6) {
 114 |             Text("Harmon Family Games")
 115 |                 .font(.title2)
 116 |                 .fontWeight(.semibold)
 117 |                 .foregroundColor(themeManager.text)
 118 |         }
 119 |         .frame(maxWidth: .infinity)
 120 |         .padding(.top, 18)
 121 |         .padding(.bottom, 12)
 122 |     }
 123 | }
 124 | 
 125 | private struct MenuRow: View {
 126 |     let title: String
 127 |     let subtitle: String
 128 |     let systemImage: String
 129 | 
 130 |     var body: some View {
 131 |         HStack(spacing: 14) {
 132 |             Image(systemName: systemImage)
 133 |                 .font(.title3)
 134 |                 .frame(width: 28)
 135 |                 .foregroundColor(.primary)
 136 | 
 137 |             VStack(alignment: .leading, spacing: 2) {
 138 |                 Text(title)
 139 |                     .font(.headline)
 140 |                     .foregroundColor(.primary)
 141 |                 Text(subtitle)
 142 |                     .font(.footnote)
 143 |                     .foregroundStyle(.secondary)
 144 |             }
 145 | 
 146 |             Spacer()
 147 | 
 148 |             Image(systemName: "chevron.right")
 149 |                 .font(.footnote)
 150 |                 .foregroundStyle(.secondary)
 151 |         }
 152 |         .padding(.vertical, 14)
 153 |         .padding(.horizontal, 14)
 154 |         .frame(maxWidth: .infinity)
 155 |         .background(
 156 |             RoundedRectangle(cornerRadius: 14, style: .continuous)
 157 |                 .fill(Color(UIColor.systemBackground))
 158 |                 .shadow(color: .black.opacity(0.15), radius: 5, x: 0, y: 2)
 159 |         )
 160 |         .contentShape(Rectangle())
 161 |     }
 162 | }
 163 | 
 164 | // MARK: - Theme Settings View
 165 | 
 166 | struct ThemeSettingsView: View {
 167 |     @Environment(\.dismiss) private var dismiss
 168 |     @EnvironmentObject var themeManager: ThemeManager
 169 |     
 170 |     @State private var selectedColor: Color = .red
 171 |     @State private var themeIntensity: Double = 0.15
 172 |     
 173 |     var body: some View {
 174 |         NavigationStack {
 175 |             ZStack {
 176 |                 themeManager.background
 177 |                     .ignoresSafeArea()
 178 |                 
 179 |                 ScrollView {
 180 |                     VStack(alignment: .leading, spacing: 24) {
 181 |                         // Preview Section
 182 |                         VStack(alignment: .leading, spacing: 12) {
 183 |                             Text("Preview")
 184 |                                 .font(.title2)
 185 |                                 .bold()
 186 |                                 .foregroundColor(themeManager.primary)
 187 |                             
 188 |                             VStack(spacing: 16) {
 189 |                                 // Sample card showing how the theme looks
 190 |                                 VStack(alignment: .leading, spacing: 8) {
 191 |                                     HStack {
 192 |                                         Image(systemName: "star.fill")
 193 |                                             .foregroundColor(themeManager.primary)
 194 |                                         Text("Sample Item")
 195 |                                             .font(.headline)
 196 |                                             .foregroundColor(.primary)
 197 |                                     }
 198 |                                     Text("This is how text will appear with your theme")
 199 |                                         .font(.subheadline)
 200 |                                         .foregroundStyle(.secondary)
 201 |                                 }
 202 |                                 .padding()
 203 |                                 .background(themeManager.card)
 204 |                                 .cornerRadius(12)
 205 |                                 
 206 |                                 // Sample button
 207 |                                 Button(action: {}) {
 208 |                                     Text("Sample Button")
 209 |                                         .font(.headline)
 210 |                                         .foregroundColor(themeManager.onPrimary)
 211 |                                         .frame(maxWidth: .infinity)
 212 |                                         .padding()
 213 |                                         .background(themeManager.primary)
 214 |                                         .cornerRadius(12)
 215 |                                 }
 216 |                             }
 217 |                         }
 218 |                         .padding()
 219 |                         .background(themeManager.card)
 220 |                         .cornerRadius(12)
 221 |                         
 222 |                         // Color Picker Section
 223 |                         VStack(alignment: .leading, spacing: 12) {
 224 |                             Text("Theme & Background")
 225 |                                 .font(.title2)
 226 |                                 .bold()
 227 |                                 .foregroundColor(themeManager.primary)
 228 |                             
 229 |                             ColorPicker(selection: $selectedColor, supportsOpacity: false) {
 230 |                                 Text("Pick your primary color")
 231 |                                     .foregroundColor(.primary)
 232 |                             }
 233 |                             .padding()
 234 |                             .background(themeManager.card)
 235 |                             .cornerRadius(8)
 236 |                             .onChange(of: selectedColor) { _, newValue in
 237 |                                 if let hex = newValue.toHex() {
 238 |                                     themeManager.selectedThemeId = hex
 239 |                                 }
 240 |                             }
 241 |                             
 242 |                             // Intensity Slider
 243 |                             VStack(alignment: .leading, spacing: 4) {
 244 |                                 HStack {
 245 |                                     Text("Background Intensity")
 246 |                                     Spacer()
 247 |                                     Text("\(Int(themeIntensity * 100))%")
 248 |                                         .font(.caption)
 249 |                                         .bold()
 250 |                                         .foregroundColor(themeManager.secondary)
 251 |                                 }
 252 |                                 
 253 |                                 Slider(value: $themeIntensity, in: 0.05...1.0, step: 0.05)
 254 |                                     .tint(themeManager.primary)
 255 |                                     .onChange(of: themeIntensity) { _, newValue in
 256 |                                         themeManager.currentIntensity = newValue
 257 |                                     }
 258 |                             }
 259 |                             .padding()
 260 |                             .background(themeManager.card)
 261 |                             .cornerRadius(8)
 262 |                         }
 263 |                         .padding()
 264 |                         .background(themeManager.card)
 265 |                         .cornerRadius(12)
 266 |                         
 267 |                         // Quick Color Presets
 268 |                         VStack(alignment: .leading, spacing: 12) {
 269 |                             Text("Quick Presets")
 270 |                                 .font(.title2)
 271 |                                 .bold()
 272 |                                 .foregroundColor(themeManager.primary)
 273 |                             
 274 |                             LazyVGrid(columns: [
 275 |                                 GridItem(.flexible()),
 276 |                                 GridItem(.flexible()),
 277 |                                 GridItem(.flexible())
 278 |                             ], spacing: 12) {
 279 |                                 ColorPresetButton(name: "Christmas", color: Color(hex: "B22222"), selectedColor: $selectedColor)
 280 |                                 ColorPresetButton(name: "Ocean", color: Color(hex: "1A5490"), selectedColor: $selectedColor)
 281 |                                 ColorPresetButton(name: "Forest", color: Color(hex: "228B22"), selectedColor: $selectedColor)
 282 |                                 ColorPresetButton(name: "Sunset", color: Color(hex: "CC5500"), selectedColor: $selectedColor)
 283 |                                 ColorPresetButton(name: "Purple", color: Color(hex: "6A0DAD"), selectedColor: $selectedColor)
 284 |                                 ColorPresetButton(name: "Classic", color: Color(hex: "007AFF"), selectedColor: $selectedColor)
 285 |                             }
 286 |                         }
 287 |                         .padding()
 288 |                         .background(themeManager.card)
 289 |                         .cornerRadius(12)
 290 |                     }
 291 |                     .padding()
 292 |                 }
 293 |             }
 294 |             .navigationTitle("Theme Settings")
 295 |             .navigationBarTitleDisplayMode(.inline)
 296 |             .toolbar {
 297 |                 ToolbarItem(placement: .topBarTrailing) {
 298 |                     Button("Done") {
 299 |                         dismiss()
 300 |                     }
 301 |                     .foregroundColor(themeManager.primary)
 302 |                 }
 303 |             }
 304 |         }
 305 |         .onAppear {
 306 |             selectedColor = Color(hex: themeManager.selectedThemeId)
 307 |             themeIntensity = themeManager.currentIntensity
 308 |         }
 309 |     }
 310 | }
 311 | 
 312 | // MARK: - Color Preset Button
 313 | 
 314 | private struct ColorPresetButton: View {
 315 |     let name: String
 316 |     let color: Color
 317 |     @Binding var selectedColor: Color
 318 |     
 319 |     var body: some View {
 320 |         Button {
 321 |             selectedColor = color
 322 |         } label: {
 323 |             VStack(spacing: 8) {
 324 |                 Circle()
 325 |                     .fill(color)
 326 |                     .frame(width: 50, height: 50)
 327 |                     .overlay(
 328 |                         Circle()
 329 |                             .stroke(Color.gray.opacity(0.3), lineWidth: 2)
 330 |                     )
 331 |                 
 332 |                 Text(name)
 333 |                     .font(.caption)
 334 |                     .foregroundColor(.primary)
 335 |             }
 336 |             .frame(maxWidth: .infinity)
 337 |             .padding(.vertical, 8)
 338 |         }
 339 |     }
 340 | }


END FILE: ./Christmas Games/MainMenuView.swift


################################################################################
START FILE: ./Christmas Games/CSVImportPreviewSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CSVImportPreviewSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let csvData: Data
   9 |     let filename: String?
  10 | 
  11 |     private let maxPreviewRows = 25
  12 |     private let maxPreviewColumns = 12
  13 | 
  14 |     @State private var parseResult: ParseResult = .empty
  15 |     @State private var isImporting = false
  16 | 
  17 |     @State private var alertTitle = "Message"
  18 |     @State private var alertMessage: String?
  19 |     @State private var showAlert = false
  20 | 
  21 |     var body: some View {
  22 |         NavigationStack {
  23 |             Group {
  24 |                 if parseResult.rows.isEmpty {
  25 |                     ContentUnavailableView("No preview available", systemImage: "doc.text")
  26 |                 } else {
  27 |                     previewBody
  28 |                 }
  29 |             }
  30 |             .navigationTitle("CSV Preview")
  31 |             .navigationBarTitleDisplayMode(.inline)
  32 |             .toolbar {
  33 |                 ToolbarItem(placement: .topBarLeading) {
  34 |                     Button("Cancel") { dismiss() }
  35 |                         .disabled(isImporting)
  36 |                 }
  37 |                 ToolbarItem(placement: .topBarTrailing) {
  38 |                     Button(isImporting ? "Importing…" : "Import") {
  39 |                         importNow()
  40 |                     }
  41 |                     .disabled(isImporting)
  42 |                 }
  43 |             }
  44 |             .onAppear {
  45 |                 parseResult = CSVParser.parse(data: csvData, maxRows: maxPreviewRows, maxColumns: maxPreviewColumns)
  46 |                 if let w = parseResult.warning {
  47 |                     alertTitle = "Preview warning"
  48 |                     alertMessage = w
  49 |                     showAlert = true
  50 |                 }
  51 |             }
  52 |             .alert(alertTitle, isPresented: $showAlert) {
  53 |                 Button("OK", role: .cancel) { }
  54 |             } message: {
  55 |                 Text(alertMessage ?? "Unknown error")
  56 |             }
  57 |         }
  58 |     }
  59 | 
  60 |     private var previewBody: some View {
  61 |         List {
  62 |             Section("File") {
  63 |                 HStack {
  64 |                     Text("Name")
  65 |                     Spacer()
  66 |                     Text(filename ?? "CSV")
  67 |                         .foregroundStyle(.secondary)
  68 |                 }
  69 |                 HStack {
  70 |                     Text("Rows shown")
  71 |                     Spacer()
  72 |                     Text("\(max(0, parseResult.rows.count - (parseResult.hasHeader ? 1 : 0)))")
  73 |                         .foregroundStyle(.secondary)
  74 |                 }
  75 |                 HStack {
  76 |                     Text("Columns shown")
  77 |                     Spacer()
  78 |                     Text("\(parseResult.columnCount)")
  79 |                         .foregroundStyle(.secondary)
  80 |                 }
  81 |                 HStack {
  82 |                     Text("Header row")
  83 |                     Spacer()
  84 |                     Text(parseResult.hasHeader ? "Yes" : "No")
  85 |                         .foregroundStyle(.secondary)
  86 |                 }
  87 |             }
  88 | 
  89 |             if parseResult.hasHeader, let header = parseResult.rows.first {
  90 |                 Section("Headers") {
  91 |                     ForEach(Array(header.prefix(parseResult.columnCount)).indices, id: \.self) { idx in
  92 |                         Text(header[idx].isEmpty ? "(blank)" : header[idx])
  93 |                     }
  94 |                 }
  95 |             }
  96 | 
  97 |             Section("Preview") {
  98 |                 let startIndex = parseResult.hasHeader ? 1 : 0
  99 |                 let displayRows = Array(parseResult.rows.dropFirst(startIndex))
 100 | 
 101 |                 ForEach(displayRows.indices, id: \.self) { r in
 102 |                     VStack(alignment: .leading, spacing: 6) {
 103 |                         Text("Row \(r + 1)")
 104 |                             .font(.subheadline)
 105 |                             .bold()
 106 | 
 107 |                         let row = displayRows[r]
 108 |                         ForEach(0..<parseResult.columnCount, id: \.self) { c in
 109 |                             let value = c < row.count ? row[c] : ""
 110 |                             let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)
 111 |                             if !trimmed.isEmpty {
 112 |                                 Text(trimmed)
 113 |                                     .font(.footnote)
 114 |                                     .foregroundStyle(.secondary)
 115 |                                     .lineLimit(2)
 116 |                             }
 117 |                         }
 118 |                     }
 119 |                     .padding(.vertical, 4)
 120 |                 }
 121 |             }
 122 |         }
 123 |     }
 124 | 
 125 |     private func importNow() {
 126 |         isImporting = true
 127 |         defer { isImporting = false }
 128 | 
 129 |         do {
 130 |             let r = try GameCatalogCSVImporter.importCSV(context: context, csvData: csvData)
 131 |             alertTitle = "Import complete"
 132 |             alertMessage = "Imported/updated \(r.insertedOrUpdated). Skipped \(r.skipped). Removed \(r.removed)."
 133 |             showAlert = true
 134 |         } catch {
 135 |             alertTitle = "Import failed"
 136 |             alertMessage = error.localizedDescription
 137 |             showAlert = true
 138 |         }
 139 |     }
 140 | }
 141 | 
 142 | // MARK: - Lightweight CSV Parser (preview only)
 143 | 
 144 | private enum CSVParser {
 145 |     static func parse(data: Data, maxRows: Int, maxColumns: Int) -> ParseResult {
 146 |         guard let s = String(data: data, encoding: .utf8) ?? String(data: data, encoding: .isoLatin1) else {
 147 |             return .init(rows: [], columnCount: 0, hasHeader: false, warning: "Could not decode file as UTF-8/Latin1.")
 148 |         }
 149 | 
 150 |         let normalized = s.replacingOccurrences(of: "\r\n", with: "\n").replacingOccurrences(of: "\r", with: "\n")
 151 |         let lines = normalized.split(separator: "\n", omittingEmptySubsequences: true)
 152 | 
 153 |         var rows: [[String]] = []
 154 |         rows.reserveCapacity(min(lines.count, maxRows + 1))
 155 | 
 156 |         for line in lines.prefix(maxRows + 1) {
 157 |             rows.append(parseLine(String(line)))
 158 |         }
 159 | 
 160 |         let columnCount = min(maxColumns, rows.map { $0.count }.max() ?? 0)
 161 |         let hasHeader = inferHeader(rows.first)
 162 | 
 163 |         var warning: String? = nil
 164 |         if columnCount == 0 {
 165 |             warning = "No columns detected. Check delimiter/format."
 166 |         } else if lines.count > maxRows + 1 {
 167 |             warning = "Preview is limited to the first \(maxRows) data rows."
 168 |         }
 169 | 
 170 |         return .init(rows: rows, columnCount: columnCount, hasHeader: hasHeader, warning: warning)
 171 |     }
 172 | 
 173 |     private static func parseLine(_ line: String) -> [String] {
 174 |         var result: [String] = []
 175 |         var current = ""
 176 |         var inQuotes = false
 177 |         var i = line.startIndex
 178 | 
 179 |         while i < line.endIndex {
 180 |             let ch = line[i]
 181 | 
 182 |             if ch == "\"" {
 183 |                 let next = line.index(after: i)
 184 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 185 |                     current.append("\"")
 186 |                     i = line.index(after: next)
 187 |                     continue
 188 |                 } else {
 189 |                     inQuotes.toggle()
 190 |                     i = line.index(after: i)
 191 |                     continue
 192 |                 }
 193 |             }
 194 | 
 195 |             if ch == "," && !inQuotes {
 196 |                 result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 197 |                 current = ""
 198 |                 i = line.index(after: i)
 199 |                 continue
 200 |             }
 201 | 
 202 |             current.append(ch)
 203 |             i = line.index(after: i)
 204 |         }
 205 | 
 206 |         result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 207 |         return result
 208 |     }
 209 | 
 210 |     private static func inferHeader(_ firstRow: [String]?) -> Bool {
 211 |         guard let row = firstRow, !row.isEmpty else { return false }
 212 |         let sample = row.prefix(10)
 213 |         let nonEmpty = sample.filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
 214 |         guard !nonEmpty.isEmpty else { return false }
 215 | 
 216 |         let nonNumericCount = nonEmpty.filter { Double($0) == nil }.count
 217 |         return Double(nonNumericCount) / Double(nonEmpty.count) >= 0.7
 218 |     }
 219 | }
 220 | 
 221 | private struct ParseResult {
 222 |     let rows: [[String]]
 223 |     let columnCount: Int
 224 |     let hasHeader: Bool
 225 |     let warning: String?
 226 | 
 227 |     static let empty = ParseResult(rows: [], columnCount: 0, hasHeader: false, warning: nil)
 228 | }


END FILE: ./Christmas Games/CSVImportPreviewSheet.swift


################################################################################
START FILE: ./Christmas Games/FairnessEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | final class FairnessEngine {
   5 | 
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     func generateTeams(for round: Round, in event: Event) throws -> [RoundTeam] {
  13 | 
  14 |         guard let eventGame = round.eventGame else {
  15 |             throw FairnessError.missingEventGame
  16 |         }
  17 | 
  18 |         let settings = try effectiveSettings(for: eventGame)
  19 | 
  20 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  21 |         let required = settings.teamCount * settings.playersPerTeam
  22 | 
  23 |         guard eligiblePeople.count >= required else {
  24 |             throw FairnessError.notEnoughPlayers(required: required, available: eligiblePeople.count)
  25 |         }
  26 | 
  27 |         // Detect if this is a regeneration (teams already exist)
  28 |         let currentPlayerIds = Set(round.teams.flatMap { $0.memberPersonIds })
  29 |         let isRegeneration = !currentPlayerIds.isEmpty
  30 | 
  31 |         // Choose participants for this round based on "equal playing time"
  32 |         // If regenerating, try to exclude current players to force rotation
  33 |         let chosen = chooseParticipants(
  34 |             eligible: eligiblePeople,
  35 |             required: required,
  36 |             event: event,
  37 |             excluding: isRegeneration ? currentPlayerIds : []
  38 |         )
  39 | 
  40 |         if settings.teamType == .couplesOnly {
  41 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
  42 |         }
  43 | 
  44 |         // Generate candidate partitions and pick best by score
  45 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
  46 | 
  47 |         let candidates = 600
  48 |         var best: [RoundTeam] = []
  49 |         var bestScore = Double.greatestFiniteMagnitude
  50 | 
  51 |         for _ in 0..<candidates {
  52 |             let shuffled = chosen.shuffled().map { $0.id }
  53 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
  54 | 
  55 |             let score = scoreTeams(
  56 |                 teams: teams,
  57 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
  58 |                 historySignatures: historySignatures,
  59 |                 allowSpousesSameTeam: false
  60 |             )
  61 | 
  62 |             if score < bestScore {
  63 |                 bestScore = score
  64 |                 best = teams
  65 |                 if score == 0 { break }
  66 |             }
  67 |         }
  68 | 
  69 |         return best
  70 |     }
  71 | 
  72 |     /// Generate teams with a preferred set of players (used for skipping games)
  73 |     func generateTeamsWithPreferredPlayers(
  74 |         for round: Round,
  75 |         in event: Event,
  76 |         preferredPlayers: [UUID]
  77 |     ) throws -> [RoundTeam] {
  78 | 
  79 |         guard let eventGame = round.eventGame else {
  80 |             throw FairnessError.missingEventGame
  81 |         }
  82 | 
  83 |         let settings = try effectiveSettings(for: eventGame)
  84 |         let required = settings.teamCount * settings.playersPerTeam
  85 | 
  86 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  87 |         let eligibleIds = Set(eligiblePeople.map { $0.id })
  88 | 
  89 |         // Filter preferred players to only those who are eligible
  90 |         let validPreferred = preferredPlayers.filter { eligibleIds.contains($0) }
  91 | 
  92 |         // Adjust player count if needed
  93 |         let chosen: [Person]
  94 |         if validPreferred.count == required {
  95 |             // Perfect match - use as-is
  96 |             chosen = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
  97 |         } else if validPreferred.count < required {
  98 |             // Need more players - add from bench by fairness
  99 |             let playedCounts = roundsPlayedCounts(event: event)
 100 |             let benchPlayers = eligiblePeople.filter { !validPreferred.contains($0.id) }
 101 |             let additionalNeeded = required - validPreferred.count
 102 | 
 103 |             let additional = benchPlayers
 104 |                 .sorted {
 105 |                     let a = playedCounts[$0.id, default: 0]
 106 |                     let b = playedCounts[$1.id, default: 0]
 107 |                     if a != b { return a < b }
 108 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 109 |                 }
 110 |                 .prefix(additionalNeeded)
 111 | 
 112 |             let preferredPeople = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 113 |             chosen = preferredPeople + additional
 114 |         } else {
 115 |             // Too many players - remove by most playing time
 116 |             let playedCounts = roundsPlayedCounts(event: event)
 117 |             chosen = validPreferred
 118 |                 .compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 119 |                 .sorted {
 120 |                     let a = playedCounts[$0.id, default: 0]
 121 |                     let b = playedCounts[$1.id, default: 0]
 122 |                     if a != b { return a < b } // Keep those with LESS playing time
 123 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 124 |                 }
 125 |                 .prefix(required)
 126 |                 .map { $0 }
 127 |         }
 128 | 
 129 |         guard chosen.count == required else {
 130 |             throw FairnessError.notEnoughPlayers(required: required, available: chosen.count)
 131 |         }
 132 | 
 133 |         if settings.teamType == .couplesOnly {
 134 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
 135 |         }
 136 | 
 137 |         // Generate candidate partitions and pick best by score
 138 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
 139 | 
 140 |         let candidates = 600
 141 |         var best: [RoundTeam] = []
 142 |         var bestScore = Double.greatestFiniteMagnitude
 143 | 
 144 |         for _ in 0..<candidates {
 145 |             let shuffled = chosen.shuffled().map { $0.id }
 146 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
 147 | 
 148 |             let score = scoreTeams(
 149 |                 teams: teams,
 150 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
 151 |                 historySignatures: historySignatures,
 152 |                 allowSpousesSameTeam: false
 153 |             )
 154 | 
 155 |             if score < bestScore {
 156 |                 bestScore = score
 157 |                 best = teams
 158 |                 if score == 0 { break }
 159 |             }
 160 |         }
 161 | 
 162 |         return best
 163 |     }
 164 | 
 165 |     // MARK: - Settings
 166 | 
 167 |     private struct Settings {
 168 |         let teamCount: Int
 169 |         let playersPerTeam: Int
 170 |         let teamType: TeamType
 171 |     }
 172 | 
 173 |     private func effectiveSettings(for eventGame: EventGame) throws -> Settings {
 174 |         let t = try fetchTemplate(id: eventGame.gameTemplateId)
 175 | 
 176 |         let teamCount = eventGame.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 177 |         let playersPerTeam = eventGame.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 178 |         let teamType = eventGame.overrideTeamType ?? t?.defaultTeamType ?? .any
 179 | 
 180 |         return Settings(teamCount: max(1, teamCount), playersPerTeam: max(1, playersPerTeam), teamType: teamType)
 181 |     }
 182 | 
 183 |     // MARK: - Participant choice (equal playing time by rounds played)
 184 | 
 185 |     private func chooseParticipants(
 186 |         eligible: [Person],
 187 |         required: Int,
 188 |         event: Event,
 189 |         excluding: Set<UUID> = []
 190 |     ) -> [Person] {
 191 |         let playedCounts = roundsPlayedCounts(event: event)
 192 | 
 193 |         // Try to exclude current players if there are enough non-excluded players
 194 |         let nonExcluded = eligible.filter { !excluding.contains($0.id) }
 195 | 
 196 |         let pool = nonExcluded.count >= required ? nonExcluded : eligible
 197 | 
 198 |         return pool
 199 |             .sorted {
 200 |                 let a = playedCounts[$0.id, default: 0]
 201 |                 let b = playedCounts[$1.id, default: 0]
 202 |                 if a != b { return a < b }
 203 |                 return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 204 |             }
 205 |             .prefix(required)
 206 |             .map { $0 }
 207 |     }
 208 | 
 209 |     private func roundsPlayedCounts(event: Event) -> [UUID: Int] {
 210 |         var counts: [UUID: Int] = [:]
 211 |         for eg in event.eventGames {
 212 |             for r in eg.rounds where r.completedAt != nil {
 213 |                 for team in r.teams {
 214 |                     for pid in team.memberPersonIds {
 215 |                         counts[pid, default: 0] += 1
 216 |                     }
 217 |                 }
 218 |             }
 219 |         }
 220 |         return counts
 221 |     }
 222 | 
 223 |     // MARK: - Matchup signature (head-to-head)
 224 | 
 225 |     private func matchupSignaturesForGame(eventGame: EventGame) -> Set<String> {
 226 |         var s = Set<String>()
 227 |         for r in eventGame.rounds where r.completedAt != nil {
 228 |             let sig = matchupSignature(teams: r.teams)
 229 |             s.insert(sig)
 230 |         }
 231 |         return s
 232 |     }
 233 | 
 234 |     private func matchupSignature(teams: [RoundTeam]) -> String {
 235 |         let normalizedTeams = teams
 236 |             .map { $0.memberPersonIds.sorted(by: { $0.uuidString < $1.uuidString }) }
 237 |             .sorted { left, right in
 238 |                 left.map(\.uuidString).joined(separator: ",") < right.map(\.uuidString).joined(separator: ",")
 239 |             }
 240 |         return normalizedTeams
 241 |             .map { $0.map(\.uuidString).joined(separator: ",") }
 242 |             .joined(separator: "||")
 243 |     }
 244 | 
 245 |     // MARK: - Scoring
 246 | 
 247 |     private func scoreTeams(
 248 |         teams: [RoundTeam],
 249 |         peopleById: [UUID: Person],
 250 |         historySignatures: Set<String>,
 251 |         allowSpousesSameTeam: Bool
 252 |     ) -> Double {
 253 | 
 254 |         var score: Double = 0
 255 | 
 256 |         // 1) Prevent repeating the exact head-to-head matchup
 257 |         let sig = matchupSignature(teams: teams)
 258 |         if historySignatures.contains(sig) {
 259 |             score += 10_000
 260 |         }
 261 | 
 262 |         // 2) Spouse constraint (unless couplesOnly)
 263 |         if !allowSpousesSameTeam {
 264 |             for team in teams {
 265 |                 let ids = Set(team.memberPersonIds)
 266 |                 for pid in ids {
 267 |                     if let spouseId = peopleById[pid]?.spouseId, ids.contains(spouseId) {
 268 |                         score += 5_000
 269 |                     }
 270 |                 }
 271 |             }
 272 |         }
 273 | 
 274 |         // 3) Balance by athleticAbility / weight / age (if available)
 275 |         func teamStat(_ team: RoundTeam, get: (Person) -> Int?) -> Double {
 276 |             let vals = team.memberPersonIds.compactMap { peopleById[$0] }.compactMap(get)
 277 |             if vals.isEmpty { return 0 }
 278 |             return Double(vals.reduce(0, +))
 279 |         }
 280 | 
 281 |         let athletic = teams.map { teamStat($0) { $0.athleticAbility } }
 282 |         let weight = teams.map { teamStat($0) { $0.weight } }
 283 |         let age = teams.map { teamStat($0) { $0.age } }
 284 | 
 285 |         score += variancePenalty(athletic) * 2.0
 286 |         score += variancePenalty(weight) * 0.25
 287 |         score += variancePenalty(age) * 0.5
 288 | 
 289 |         return score
 290 |     }
 291 | 
 292 |     private func variancePenalty(_ values: [Double]) -> Double {
 293 |         guard values.count > 1 else { return 0 }
 294 |         let mean = values.reduce(0, +) / Double(values.count)
 295 |         let varSum = values.reduce(0) { $0 + pow($1 - mean, 2) }
 296 |         return varSum
 297 |     }
 298 | 
 299 |     // MARK: - Couples-only teams
 300 | 
 301 |     private func generateCouplesOnlyTeams(teamCount: Int, eligible: [Person]) throws -> [RoundTeam] {
 302 | 
 303 |         let byId = Dictionary(uniqueKeysWithValues: eligible.map { ($0.id, $0) })
 304 | 
 305 |         var used = Set<UUID>()
 306 |         var pairs: [[UUID]] = []
 307 | 
 308 |         for person in eligible {
 309 |             guard !used.contains(person.id),
 310 |                   let spouseId = person.spouseId,
 311 |                   let spouse = byId[spouseId],
 312 |                   spouse.spouseId == person.id,
 313 |                   !used.contains(spouse.id)
 314 |             else { continue }
 315 | 
 316 |             used.insert(person.id)
 317 |             used.insert(spouse.id)
 318 |             pairs.append([person.id, spouse.id])
 319 |         }
 320 | 
 321 |         guard pairs.count >= teamCount else {
 322 |             throw FairnessError.notEnoughCouples(required: teamCount, available: pairs.count)
 323 |         }
 324 | 
 325 |         return pairs.prefix(teamCount).map { RoundTeam(memberPersonIds: $0) }
 326 |     }
 327 | 
 328 |     // MARK: - Utilities
 329 | 
 330 |     private func partition(ids: [UUID], teamCount: Int, playersPerTeam: Int) -> [RoundTeam] {
 331 |         var result: [RoundTeam] = []
 332 |         var index = 0
 333 |         for _ in 0..<teamCount {
 334 |             let slice = ids[index..<(index + playersPerTeam)]
 335 |             result.append(RoundTeam(memberPersonIds: Array(slice)))
 336 |             index += playersPerTeam
 337 |         }
 338 |         return result
 339 |     }
 340 | 
 341 |     private func fetchEligiblePeople(for event: Event) throws -> [Person] {
 342 |         let all = try context.fetch(FetchDescriptor<Person>())
 343 |         let idSet = Set(event.participantIds)
 344 |         return all.filter { $0.isActive && idSet.contains($0.id) }
 345 |     }
 346 | 
 347 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 348 |         let d = FetchDescriptor<GameTemplate>()
 349 |         let templates = try context.fetch(d)
 350 |         return templates.first(where: { $0.id == id })
 351 |     }
 352 | }
 353 | 
 354 | // MARK: - Errors
 355 | 
 356 | enum FairnessError: LocalizedError {
 357 |     case missingEventGame
 358 |     case notEnoughPlayers(required: Int, available: Int)
 359 |     case notEnoughCouples(required: Int, available: Int)
 360 | 
 361 |     var errorDescription: String? {
 362 |         switch self {
 363 |         case .missingEventGame:
 364 |             return "Round is not attached to an EventGame."
 365 |         case .notEnoughPlayers(let r, let a):
 366 |             return "Not enough players. Required \(r), available \(a)."
 367 |         case .notEnoughCouples(let r, let a):
 368 |             return "Not enough couples. Required \(r), available \(a)."
 369 |         }
 370 |     }
 371 | }


END FILE: ./Christmas Games/FairnessEngine.swift


################################################################################
START FILE: ./Christmas Games/FilesHelper.swift
################################################################################
   1 | import Foundation
   2 | import UIKit
   3 | 
   4 | enum FilesHelper {
   5 | 
   6 |     static func openAppFolder() {
   7 |         guard let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
   8 |             return
   9 |         }
  10 | 
  11 |         UIApplication.shared.open(url)
  12 |     }
  13 | 
  14 |     static func ensureGamesFolderExists() {
  15 |         guard let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
  16 |             return
  17 |         }
  18 | 
  19 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  20 | 
  21 |         if !FileManager.default.fileExists(atPath: folder.path) {
  22 |             try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  23 |         }
  24 |     }
  25 | }


END FILE: ./Christmas Games/FilesHelper.swift


################################################################################
START FILE: ./Christmas Games/GameTemplateSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreateGameTemplateSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let onCreated: (GameTemplate) -> Void
   9 | 
  10 |     @State private var name = ""
  11 |     @State private var groupName = ""
  12 |     @State private var defaultTeamCount = 2
  13 |     @State private var defaultPlayersPerTeam = 2
  14 |     @State private var defaultRoundsPerGame = 1
  15 |     @State private var teamType: TeamType = .any
  16 |     @State private var playInstructions = ""
  17 |     @State private var setupInstructions = ""
  18 | 
  19 |     var body: some View {
  20 |         NavigationStack {
  21 |             Form {
  22 |                 Section("Basic") {
  23 |                     TextField("Name", text: $name)
  24 |                     TextField("Group (optional)", text: $groupName)
  25 |                 }
  26 | 
  27 |                 Section("Defaults") {
  28 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
  29 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
  30 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
  31 | 
  32 |                     Picker("Team Type", selection: $teamType) {
  33 |                         Text("Any").tag(TeamType.any)
  34 |                         Text("Male Only").tag(TeamType.maleOnly)
  35 |                         Text("Female Only").tag(TeamType.femaleOnly)
  36 |                         Text("Couples Only").tag(TeamType.couplesOnly)
  37 |                     }
  38 |                 }
  39 | 
  40 |                 Section("Instructions") {
  41 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
  42 |                         .lineLimit(3...8)
  43 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
  44 |                         .lineLimit(3...8)
  45 |                 }
  46 |             }
  47 |             .navigationTitle("New Game Template")
  48 |             .toolbar {
  49 |                 ToolbarItem(placement: .topBarLeading) {
  50 |                     Button("Cancel") { dismiss() }
  51 |                 }
  52 | 
  53 |                 ToolbarItem(placement: .topBarTrailing) {
  54 |                     Button("Save") { save() }
  55 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  56 |                 }
  57 |             }
  58 |         }
  59 |     }
  60 | 
  61 |     private func save() {
  62 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
  63 |         guard !trimmedName.isEmpty else { return }
  64 | 
  65 |         let template = GameTemplate(
  66 |             externalId: "user_\(UUID().uuidString.lowercased())",
  67 |             name: trimmedName,
  68 |             groupName: groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName,
  69 |             defaultTeamCount: defaultTeamCount,
  70 |             defaultPlayersPerTeam: defaultPlayersPerTeam,
  71 |             defaultRoundsPerGame: defaultRoundsPerGame,
  72 |             defaultTeamType: teamType,
  73 |             playInstructions: playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions,
  74 |             setupInstructions: setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
  75 |         )
  76 | 
  77 |         context.insert(template)
  78 |         try? context.save()
  79 | 
  80 |         onCreated(template)
  81 |         dismiss()
  82 |     }
  83 | }


END FILE: ./Christmas Games/GameTemplateSheet.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogImporter {
   6 | 
   7 |     // MARK: - Public API (matches your BootstrapView calls)
   8 | 
   9 |     /// Imports games.json from Documents *if present*.
  10 |     /// Returns the number of templates imported/updated, or nil if the file doesn't exist.
  11 |     static func importFromDocumentsIfPresent(
  12 |         context: ModelContext,
  13 |         filename: String,
  14 |         fileExtension: String
  15 |     ) throws -> Int? {
  16 |         let url = documentsURL(filename: filename, fileExtension: fileExtension)
  17 | 
  18 |         guard FileManager.default.fileExists(atPath: url.path) else {
  19 |             return nil
  20 |         }
  21 | 
  22 |         let data = try Data(contentsOf: url)
  23 |         let count = try importFromData(context: context, jsonData: data)
  24 |         return count
  25 |     }
  26 | 
  27 |     /// Imports games.json from the app bundle.
  28 |     /// Returns the number of templates imported/updated.
  29 |     static func importFromBundle(
  30 |         context: ModelContext,
  31 |         filename: String,
  32 |         fileExtension: String
  33 |     ) throws -> Int {
  34 |         guard let url = Bundle.main.url(forResource: filename, withExtension: fileExtension) else {
  35 |             return 0 // treat missing bundled json as "no seed"
  36 |         }
  37 | 
  38 |         let data = try Data(contentsOf: url)
  39 |         let count = try importFromData(context: context, jsonData: data)
  40 |         return count
  41 |     }
  42 | 
  43 |     // MARK: - Backward-compatible helpers (optional; safe to keep)
  44 | 
  45 |     static func importFromBundle(context: ModelContext) throws {
  46 |         _ = try importFromBundle(context: context, filename: "games", fileExtension: "json")
  47 |     }
  48 | 
  49 |     static func importFromDocuments(context: ModelContext) throws {
  50 |         _ = try importFromDocumentsIfPresent(context: context, filename: "games", fileExtension: "json")
  51 |     }
  52 | 
  53 |     // MARK: - Core import
  54 | 
  55 |     private static func importFromData(context: ModelContext, jsonData: Data) throws -> Int {
  56 |         let decoder = JSONDecoder()
  57 |         let catalog = try decoder.decode(GameCatalog.self, from: jsonData)
  58 | 
  59 |         var count = 0
  60 |         for game in catalog.games {
  61 |             try upsert(game: game, context: context)
  62 |             count += 1
  63 |         }
  64 | 
  65 |         try context.save()
  66 |         return count
  67 |     }
  68 | 
  69 |     private static func upsert(game: GameCatalogGame, context: ModelContext) throws {
  70 |         let descriptor = FetchDescriptor<GameTemplate>(
  71 |             predicate: #Predicate { $0.externalId == game.externalId }
  72 |         )
  73 | 
  74 |         if let existing = try context.fetch(descriptor).first {
  75 |             existing.name = game.name
  76 |             existing.groupName = game.groupName
  77 |             existing.defaultTeamCount = game.defaultTeamCount
  78 |             existing.defaultPlayersPerTeam = game.defaultPlayersPerTeam
  79 |             existing.defaultRoundsPerGame = game.defaultRoundsPerGame
  80 |             existing.defaultTeamTypeRaw = game.teamType.rawValue
  81 |             existing.playInstructions = game.playInstructions
  82 |             existing.setupInstructions = game.setupInstructions
  83 |         } else {
  84 |             let template = GameTemplate(
  85 |                 externalId: game.externalId,
  86 |                 name: game.name,
  87 |                 groupName: game.groupName,
  88 |                 defaultTeamCount: game.defaultTeamCount,
  89 |                 defaultPlayersPerTeam: game.defaultPlayersPerTeam,
  90 |                 defaultRoundsPerGame: game.defaultRoundsPerGame,
  91 |                 defaultTeamType: game.teamType,
  92 |                 playInstructions: game.playInstructions,
  93 |                 setupInstructions: game.setupInstructions
  94 |             )
  95 |             context.insert(template)
  96 |         }
  97 |     }
  98 | 
  99 |     // MARK: - Paths
 100 | 
 101 |     private static func documentsURL(filename: String, fileExtension: String) -> URL {
 102 |         FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
 103 |             .appendingPathComponent("\(filename).\(fileExtension)")
 104 |     }
 105 | }
 106 | 
 107 | // MARK: - Private JSON DTOs (avoid redeclaration collisions)
 108 | 
 109 | private struct GameCatalog: Codable {
 110 |     let games: [GameCatalogGame]
 111 | }
 112 | 
 113 | private struct GameCatalogGame: Codable {
 114 |     let externalId: String
 115 |     let name: String
 116 |     let groupName: String?
 117 |     let defaultTeamCount: Int
 118 |     let defaultPlayersPerTeam: Int
 119 |     let defaultRoundsPerGame: Int
 120 |     let teamType: TeamType
 121 |     let playInstructions: String?
 122 |     let setupInstructions: String?
 123 | }


END FILE: ./Christmas Games/GameCatalogImporter.swift


################################################################################
START FILE: ./Christmas Games/EventStatsView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct EventStatsView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     @Query(sort: \Event.createdAt, order: .reverse)
   9 |     private var allEvents: [Event]
  10 | 
  11 |     @Query(sort: \Person.displayName)
  12 |     private var people: [Person]
  13 | 
  14 |     @State private var selectedEventId: UUID?
  15 | 
  16 |     @State private var showResetConfirm = false
  17 |     @State private var message: String?
  18 |     @State private var showMessage = false
  19 | 
  20 |     @State private var sortColumn: SortColumn = .rank
  21 |     @State private var sortAscending: Bool = true
  22 | 
  23 |     enum SortColumn {
  24 |         case name, games, rounds, first, second, third, rank
  25 |     }
  26 | 
  27 |     var body: some View {
  28 |         ZStack {
  29 |             themeManager.background
  30 |                 .ignoresSafeArea()
  31 | 
  32 |             VStack(spacing: 0) {
  33 |                 eventPicker
  34 | 
  35 |                 if let stats = calculatedStats {
  36 |                     statsTable(stats: stats)
  37 |                         .scrollContentBackground(.hidden)
  38 |                 } else {
  39 |                     ContentUnavailableView(
  40 |                         "No Stats Available",
  41 |                         systemImage: "chart.bar",
  42 |                         description: Text("Play some games to see statistics.")
  43 |                     )
  44 |                     .padding()
  45 |                 }
  46 |             }
  47 |         }
  48 |         .navigationTitle("Event Stats")
  49 |         .toolbarBackground(.hidden, for: .navigationBar)
  50 |         .toolbar {
  51 |             ToolbarItem(placement: .topBarTrailing) {
  52 |                 Button("Reset") { showResetConfirm = true }
  53 |                     .foregroundColor(themeManager.text)
  54 |                     .disabled(selectedEventId == nil)
  55 |             }
  56 |         }
  57 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
  58 |             Button("Reset Event", role: .destructive) {
  59 |                 resetSelectedEvent()
  60 |             }
  61 |             Button("Cancel", role: .cancel) { }
  62 |         } message: {
  63 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
  64 |         }
  65 |         .alert("Message", isPresented: $showMessage) {
  66 |             Button("OK", role: .cancel) { }
  67 |         } message: {
  68 |             Text(message ?? "Unknown error")
  69 |         }
  70 |     }
  71 | 
  72 |     private var eventPicker: some View {
  73 |         Picker("Event", selection: $selectedEventId) {
  74 |             Text("All Events").tag(nil as UUID?)
  75 |             ForEach(allEvents) { event in
  76 |                 Text(event.name).tag(event.id as UUID?)
  77 |             }
  78 |         }
  79 |         .pickerStyle(.menu)
  80 |         .padding()
  81 |     }
  82 | 
  83 |     private var calculatedStats: [PlayerStats]? {
  84 |         let eventsToAnalyze: [Event]
  85 |         if let selectedEventId {
  86 |             eventsToAnalyze = allEvents.filter { $0.id == selectedEventId }
  87 |         } else {
  88 |             eventsToAnalyze = allEvents
  89 |         }
  90 | 
  91 |         guard !eventsToAnalyze.isEmpty else { return nil }
  92 | 
  93 |         var statsDict: [UUID: PlayerStats] = [:]
  94 | 
  95 |         for event in eventsToAnalyze {
  96 |             for eventGame in event.eventGames {
  97 |                 var peopleInThisGame: Set<UUID> = []
  98 | 
  99 |                 for round in eventGame.rounds where round.completedAt != nil {
 100 |                     let participantsInRound: Set<UUID> = Set(round.teams.flatMap { $0.memberPersonIds })
 101 | 
 102 |                     // Rounds Played
 103 |                     for personId in participantsInRound {
 104 |                         var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 105 |                         stat.roundsPlayed += 1
 106 |                         statsDict[personId] = stat
 107 |                     }
 108 | 
 109 |                     // For Games Played rollup
 110 |                     peopleInThisGame.formUnion(participantsInRound)
 111 | 
 112 |                     // Placements
 113 |                     if !round.placements.isEmpty {
 114 |                         for (personId, placement) in round.placements {
 115 |                             var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 116 |                             switch placement {
 117 |                             case 1: stat.firstPlace += 1
 118 |                             case 2: stat.secondPlace += 1
 119 |                             case 3: stat.thirdPlace += 1
 120 |                             default: break
 121 |                             }
 122 |                             statsDict[personId] = stat
 123 |                         }
 124 |                     } else if round.resultType == .tie, round.winningTeamId == nil {
 125 |                         // Tie with no placements recorded: everyone in the round gets 1st
 126 |                         for personId in participantsInRound {
 127 |                             var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 128 |                             stat.firstPlace += 1
 129 |                             statsDict[personId] = stat
 130 |                         }
 131 |                     }
 132 |                 }
 133 | 
 134 |                 // Games Played: +1 per game if person participated in any completed round within that game
 135 |                 for personId in peopleInThisGame {
 136 |                     var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 137 |                     stat.gamesPlayed += 1
 138 |                     statsDict[personId] = stat
 139 |                 }
 140 |             }
 141 |         }
 142 | 
 143 |         guard !statsDict.isEmpty else { return nil }
 144 | 
 145 |         let peopleById = Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 146 | 
 147 |         var result = statsDict.values.map { stat -> PlayerStats in
 148 |             var s = stat
 149 |             s.displayName = peopleById[stat.personId]?.displayName ?? "Unknown"
 150 |             s.totalPoints = (s.firstPlace * 3) + (s.secondPlace * 2) + (s.thirdPlace * 1)
 151 |             return s
 152 |         }
 153 | 
 154 |         // Apply sorting based on selected column
 155 |         switch sortColumn {
 156 |         case .name:
 157 |             result.sort { lhs, rhs in
 158 |                 sortAscending
 159 |                 ? lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedAscending
 160 |                 : lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedDescending
 161 |             }
 162 |         case .games:
 163 |             result.sort { sortAscending ? $0.gamesPlayed < $1.gamesPlayed : $0.gamesPlayed > $1.gamesPlayed }
 164 |         case .rounds:
 165 |             result.sort { sortAscending ? $0.roundsPlayed < $1.roundsPlayed : $0.roundsPlayed > $1.roundsPlayed }
 166 |         case .first:
 167 |             result.sort { sortAscending ? $0.firstPlace < $1.firstPlace : $0.firstPlace > $1.firstPlace }
 168 |         case .second:
 169 |             result.sort { sortAscending ? $0.secondPlace < $1.secondPlace : $0.secondPlace > $1.secondPlace }
 170 |         case .third:
 171 |             result.sort { sortAscending ? $0.thirdPlace < $1.thirdPlace : $0.thirdPlace > $1.thirdPlace }
 172 |         case .rank:
 173 |             result.sort { sortAscending ? $0.totalPoints < $1.totalPoints : $0.totalPoints > $1.totalPoints }
 174 |         }
 175 | 
 176 |         // Assign ranks based on points (for display)
 177 |         let rankedByPoints = result.sorted { $0.totalPoints > $1.totalPoints }
 178 |         var rankMap: [UUID: Int] = [:]
 179 |         for (index, stat) in rankedByPoints.enumerated() {
 180 |             rankMap[stat.personId] = index + 1
 181 |         }
 182 | 
 183 |         for i in 0..<result.count {
 184 |             result[i].rank = rankMap[result[i].personId] ?? 0
 185 |         }
 186 | 
 187 |         return result
 188 |     }
 189 | 
 190 |     private func toggleSort(column: SortColumn) {
 191 |         if sortColumn == column {
 192 |             sortAscending.toggle()
 193 |         } else {
 194 |             sortColumn = column
 195 |             sortAscending = (column == .name) // Name defaults A-Z, numbers default high-to-low
 196 |         }
 197 |     }
 198 | 
 199 |     private func sortIndicator(for column: SortColumn) -> String {
 200 |         guard sortColumn == column else { return "" }
 201 |         return sortAscending ? " ↑" : " ↓"
 202 |     }
 203 | 
 204 |     private func statsTable(stats: [PlayerStats]) -> some View {
 205 |         List {
 206 |             Section {
 207 |                 HStack {
 208 |                     Button(action: { toggleSort(column: .name) }) {
 209 |                         Text("Name\(sortIndicator(for: .name))")
 210 |                             .frame(maxWidth: .infinity, alignment: .leading)
 211 |                     }
 212 |                     .buttonStyle(.plain)
 213 | 
 214 |                     Button(action: { toggleSort(column: .games) }) {
 215 |                         Text("Games\(sortIndicator(for: .games))")
 216 |                             .frame(width: 52)
 217 |                     }
 218 |                     .buttonStyle(.plain)
 219 | 
 220 |                     Button(action: { toggleSort(column: .rounds) }) {
 221 |                         Text("Rounds\(sortIndicator(for: .rounds))")
 222 |                             .frame(width: 60)
 223 |                     }
 224 |                     .buttonStyle(.plain)
 225 | 
 226 |                     Button(action: { toggleSort(column: .first) }) {
 227 |                         Text("1st\(sortIndicator(for: .first))")
 228 |                             .frame(width: 40)
 229 |                     }
 230 |                     .buttonStyle(.plain)
 231 | 
 232 |                     Button(action: { toggleSort(column: .second) }) {
 233 |                         Text("2nd\(sortIndicator(for: .second))")
 234 |                             .frame(width: 40)
 235 |                     }
 236 |                     .buttonStyle(.plain)
 237 | 
 238 |                     Button(action: { toggleSort(column: .third) }) {
 239 |                         Text("3rd\(sortIndicator(for: .third))")
 240 |                             .frame(width: 40)
 241 |                     }
 242 |                     .buttonStyle(.plain)
 243 | 
 244 |                     Button(action: { toggleSort(column: .rank) }) {
 245 |                         Text("Rank\(sortIndicator(for: .rank))")
 246 |                             .frame(width: 50)
 247 |                     }
 248 |                     .buttonStyle(.plain)
 249 |                 }
 250 |                 .font(.caption)
 251 |                 .bold()
 252 |             }
 253 | 
 254 |             ForEach(stats) { stat in
 255 |                 HStack {
 256 |                     Text(stat.displayName)
 257 |                         .frame(maxWidth: .infinity, alignment: .leading)
 258 | 
 259 |                     Text("\(stat.gamesPlayed)").frame(width: 52)
 260 |                     Text("\(stat.roundsPlayed)").frame(width: 60)
 261 | 
 262 |                     Text("\(stat.firstPlace)").frame(width: 40)
 263 |                     Text("\(stat.secondPlace)").frame(width: 40)
 264 |                     Text("\(stat.thirdPlace)").frame(width: 40)
 265 | 
 266 |                     Text("\(stat.rank)")
 267 |                         .frame(width: 50)
 268 |                         .bold()
 269 |                 }
 270 |                 .font(.body)
 271 |             }
 272 |         }
 273 |     }
 274 | 
 275 |     private func resetSelectedEvent() {
 276 |         guard let selectedEventId,
 277 |               let event = allEvents.first(where: { $0.id == selectedEventId }) else {
 278 |             return
 279 |         }
 280 | 
 281 |         do {
 282 |             try EventEngine(context: context).resetEvent(event)
 283 |             message = "Event '\(event.name)' has been reset successfully."
 284 |             showMessage = true
 285 |         } catch {
 286 |             message = error.localizedDescription
 287 |             showMessage = true
 288 |         }
 289 |     }
 290 | }
 291 | 
 292 | // MARK: - Stats Model
 293 | 
 294 | private struct PlayerStats: Identifiable {
 295 |     let id = UUID()
 296 |     let personId: UUID
 297 | 
 298 |     var displayName: String = ""
 299 | 
 300 |     /// Number of EventGames the player participated in (>= 1 completed round within the game)
 301 |     var gamesPlayed: Int = 0
 302 | 
 303 |     /// Number of completed rounds the player participated in (appeared on any team)
 304 |     var roundsPlayed: Int = 0
 305 | 
 306 |     var firstPlace: Int = 0
 307 |     var secondPlace: Int = 0
 308 |     var thirdPlace: Int = 0
 309 | 
 310 |     var totalPoints: Int = 0
 311 |     var rank: Int = 0
 312 | }
 313 | 
 314 | #Preview {
 315 |     NavigationStack {
 316 |         EventStatsView()
 317 |     }
 318 |     .modelContainer(for: [Event.self, Person.self])
 319 |     .environmentObject(ThemeManager())
 320 | }


END FILE: ./Christmas Games/EventStatsView.swift


################################################################################
START FILE: ./Christmas Games/EventEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | final class EventEngine {
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     // MARK: - Participants
  13 | 
  14 |     func setParticipants(for event: Event, participantIds: [UUID]) throws {
  15 |         event.participantIds = participantIds
  16 |         touch(event)
  17 |         try context.save()
  18 |     }
  19 | 
  20 |     // MARK: - Event Games: Import / Add / Remove
  21 | 
  22 |     /// Imports all GameTemplate rows into the given Event as EventGame rows.
  23 |     /// Idempotent: re-running does NOT create duplicates.
  24 |     func importAllCatalogGames(into event: Event) throws {
  25 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  26 |         let existingTemplateIds = Set(event.eventGames.map { $0.gameTemplateId })
  27 | 
  28 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  29 |         var nextIndex = maxIndex + 1
  30 | 
  31 |         for template in templates {
  32 |             guard !existingTemplateIds.contains(template.id) else { continue }
  33 | 
  34 |             let eg = EventGame(
  35 |                 event: event,
  36 |                 gameTemplateId: template.id,
  37 |                 orderIndex: nextIndex
  38 |             )
  39 |             nextIndex += 1
  40 | 
  41 |             context.insert(eg)
  42 |             event.eventGames.append(eg)
  43 |         }
  44 | 
  45 |         touch(event)
  46 |         try context.save()
  47 |     }
  48 | 
  49 |     /// Adds a single template to the event (no duplicates).
  50 |     func addGameTemplate(_ template: GameTemplate, to event: Event) throws {
  51 |         let exists = event.eventGames.contains(where: { $0.gameTemplateId == template.id })
  52 |         guard !exists else { return }
  53 | 
  54 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  55 |         let eg = EventGame(
  56 |             event: event,
  57 |             gameTemplateId: template.id,
  58 |             orderIndex: maxIndex + 1
  59 |         )
  60 | 
  61 |         context.insert(eg)
  62 |         event.eventGames.append(eg)
  63 | 
  64 |         touch(event)
  65 |         try context.save()
  66 |     }
  67 | 
  68 |     /// Removes an EventGame from the event.
  69 |     func removeEventGame(_ eventGame: EventGame, from event: Event) throws {
  70 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
  71 |         context.delete(eventGame)
  72 | 
  73 |         // If you removed the current game, clear pointer
  74 |         if event.currentEventGameId == eventGame.id {
  75 |             event.currentEventGameId = nil
  76 |         }
  77 | 
  78 |         touch(event)
  79 |         try context.save()
  80 |     }
  81 | 
  82 |     // MARK: - Skip Current Game
  83 |     
  84 |     /// Skip current game and start a new random game, keeping same players
  85 |     func skipToNextGame(_ currentGame: EventGame, keepingPlayers playerIds: [UUID]) throws {
  86 |         guard let event = currentGame.event else { return }
  87 |         
  88 |         // Mark current game as completed (skipped)
  89 |         currentGame.status = .completed
  90 |         
  91 |         // Pick next random game
  92 |         guard let nextGame = try pickNextGameRandom(event: event) else {
  93 |             // No more games available
  94 |             event.status = .completed
  95 |             event.currentEventGameId = nil
  96 |             touch(event)
  97 |             try context.save()
  98 |             return
  99 |         }
 100 |         
 101 |         // Start the new game
 102 |         event.status = .active
 103 |         event.currentEventGameId = nextGame.id
 104 |         nextGame.status = .inProgress
 105 |         
 106 |         // Create round 0 if none exist
 107 |         if nextGame.rounds.isEmpty {
 108 |             let r = Round(eventGame: nextGame, roundIndex: 0, teams: [])
 109 |             context.insert(r)
 110 |             nextGame.rounds.append(r)
 111 |         }
 112 |         
 113 |         // Generate teams with preferred players
 114 |         if let currentRound = nextGame.rounds.first(where: { $0.completedAt == nil }) {
 115 |             let fairness = FairnessEngine(context: context)
 116 |             let teams = try fairness.generateTeamsWithPreferredPlayers(
 117 |                 for: currentRound,
 118 |                 in: event,
 119 |                 preferredPlayers: playerIds
 120 |             )
 121 |             currentRound.teams = teams
 122 |         }
 123 |         
 124 |         touch(event)
 125 |         try context.save()
 126 |     }
 127 | 
 128 |     // MARK: - Event Lifecycle
 129 | 
 130 |     func startEvent(_ event: Event) throws {
 131 |         // Starting the event means: mark active and immediately start the next game.
 132 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 133 | 
 134 |         event.status = .active
 135 | 
 136 |         if let next = try pickNextGameRandom(event: event) {
 137 |             try start(event: event, eventGame: next)
 138 |         }
 139 | 
 140 |         touch(event)
 141 |         try context.save()
 142 |     }
 143 | 
 144 |     func pauseEvent(_ event: Event) throws {
 145 |         event.status = .paused
 146 |         touch(event)
 147 |         try context.save()
 148 |     }
 149 | 
 150 |     // MARK: - Reset Event
 151 | 
 152 | func resetEvent(_ event: Event) throws {
 153 |     // Delete all rounds from all games
 154 |     for eventGame in event.eventGames {
 155 |         for round in eventGame.rounds {
 156 |             context.delete(round)
 157 |         }
 158 |         eventGame.rounds.removeAll()
 159 |         eventGame.status = .notStarted
 160 |     }
 161 |     
 162 |     // Reset event state
 163 |     event.status = .available
 164 |     event.currentEventGameId = nil
 165 |     
 166 |     touch(event)
 167 |     try context.save()
 168 | }
 169 |     
 170 |     func resumeEvent(_ event: Event) throws {
 171 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 172 | 
 173 |         event.status = .active
 174 | 
 175 |         // If there is no current game (or it is completed), start the next game.
 176 |         let current = event.currentEventGameId.flatMap { id in
 177 |             event.eventGames.first(where: { $0.id == id })
 178 |         }
 179 | 
 180 |         if current == nil || current?.status == .completed {
 181 |             if let next = try pickNextGameRandom(event: event) {
 182 |                 try start(event: event, eventGame: next)
 183 |             } else {
 184 |                 event.status = .completed
 185 |                 event.currentEventGameId = nil
 186 |             }
 187 |         }
 188 | 
 189 |         touch(event)
 190 |         try context.save()
 191 |     }
 192 | 
 193 |     /// Starts a specific EventGame:
 194 |     /// - sets event active
 195 |     /// - sets currentEventGameId
 196 |     /// - sets game status to inProgress
 197 |     /// - creates round 0 if missing
 198 |     func start(event: Event, eventGame: EventGame) throws {
 199 |         // Must have participants to play
 200 |         guard !event.participantIds.isEmpty else {
 201 |             throw StartError.noParticipants
 202 |         }
 203 | 
 204 |         // Resolve template to know defaultRoundsPerGame
 205 |         guard try fetchTemplate(id: eventGame.gameTemplateId) != nil else {
 206 |             throw StartError.missingTemplate
 207 |         }
 208 | 
 209 |         event.status = .active
 210 |         event.currentEventGameId = eventGame.id
 211 |         eventGame.status = .inProgress
 212 | 
 213 |         // Create round 0 if no rounds exist, OR if all rounds are completed
 214 |         let hasActiveRound = eventGame.rounds.contains { $0.completedAt == nil }
 215 |         if eventGame.rounds.isEmpty || !hasActiveRound {
 216 |             let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 217 |             let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 218 |             context.insert(r)
 219 |             eventGame.rounds.append(r)
 220 |         }
 221 | 
 222 |         touch(event)
 223 |         try context.save()
 224 |     }
 225 |     
 226 |     // MARK: - Game / Round progression
 227 | 
 228 |     func createNextRound(for eventGame: EventGame) throws -> Round {
 229 |         let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 230 |         let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 231 |         r.eventGame = eventGame  // Explicitly set inverse relationship
 232 |         context.insert(r)
 233 |         eventGame.rounds.append(r)
 234 | 
 235 |         if let event = eventGame.event {
 236 |             touch(event)
 237 |         }
 238 |         try context.save()
 239 |         return r
 240 |     }
 241 | 
 242 |     func completeGame(_ eventGame: EventGame) throws {
 243 |         eventGame.status = .completed
 244 |         if let event = eventGame.event {
 245 |             // If the completed game was current, clear pointer (next game will set it)
 246 |             if event.currentEventGameId == eventGame.id {
 247 |                 event.currentEventGameId = nil
 248 |             }
 249 |             touch(event)
 250 |         }
 251 |         try context.save()
 252 |     }
 253 | 
 254 |     func pickNextGameRandom(event: Event) throws -> EventGame? {
 255 |         let remaining = event.eventGames.filter { $0.status == .notStarted }
 256 |         guard !remaining.isEmpty else { return nil }
 257 | 
 258 |         // Simple variety heuristic: prefer a different group than the last completed game.
 259 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
 260 |         let templateById = Dictionary(uniqueKeysWithValues: templates.map { ($0.id, $0) })
 261 | 
 262 |         let lastCompleted = event.eventGames
 263 |             .filter { $0.status == .completed }
 264 |             .sorted { ($0.orderIndex) > ($1.orderIndex) }
 265 |             .first
 266 | 
 267 |         let lastGroup = lastCompleted.flatMap { templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines) }
 268 | 
 269 |         if let lastGroup, !lastGroup.isEmpty {
 270 |             let differentGroup = remaining.filter {
 271 |                 let g = templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 272 |                 return (g?.isEmpty == false) ? (g != lastGroup) : true
 273 |             }
 274 |             if let pick = differentGroup.randomElement() {
 275 |                 return pick
 276 |             }
 277 |         }
 278 | 
 279 |         return remaining.randomElement()
 280 |     }
 281 | 
 282 |     func pushGameToLater(_ eventGame: EventGame) throws {
 283 |         guard let event = eventGame.event else { return }
 284 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
 285 |         eventGame.orderIndex = maxIndex + 1
 286 |         touch(event)
 287 |         try context.save()
 288 |     }
 289 | 
 290 |     func removeGameFromEvent(_ eventGame: EventGame) throws {
 291 |         guard let event = eventGame.event else {
 292 |             context.delete(eventGame)
 293 |             try context.save()
 294 |             return
 295 |         }
 296 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
 297 |         context.delete(eventGame)
 298 |         if event.currentEventGameId == eventGame.id {
 299 |             event.currentEventGameId = nil
 300 |         }
 301 |         touch(event)
 302 |         try context.save()
 303 |     }
 304 | 
 305 |     // MARK: - Teams / Rounds
 306 | 
 307 |     func generateTeams(for round: Round) throws {
 308 |         guard let eventGame = round.eventGame, let event = eventGame.event else { return }
 309 | 
 310 |         let fairness = FairnessEngine(context: context)
 311 |         let teams = try fairness.generateTeams(for: round, in: event)
 312 | 
 313 |         round.teams = teams
 314 |         touch(event)
 315 |         try context.save()
 316 |     }
 317 | 
 318 |     func swapPlayer(in round: Round, from outgoing: UUID, to incoming: UUID) throws {
 319 |         var updated = round.teams
 320 |         guard let teamIndex = updated.firstIndex(where: { $0.memberPersonIds.contains(outgoing) }) else { return }
 321 | 
 322 |         var team = updated[teamIndex]
 323 |         team.memberPersonIds = team.memberPersonIds.map { $0 == outgoing ? incoming : $0 }
 324 |         updated[teamIndex] = team
 325 |         round.teams = updated
 326 | 
 327 |         if let event = round.eventGame?.event {
 328 |             touch(event)
 329 |         }
 330 |         try context.save()
 331 |     }
 332 | 
 333 |     func finalizeRound(
 334 |         _ round: Round,
 335 |         winnerTeamId: UUID?,
 336 |         secondTeamId: UUID? = nil,
 337 |         thirdTeamId: UUID? = nil
 338 |     ) throws {
 339 |         round.completedAt = Date()
 340 | 
 341 |         // Tie: everyone gets 1st place
 342 |         if winnerTeamId == nil {
 343 |             round.resultType = .tie
 344 |             round.winningTeamId = nil
 345 | 
 346 |             var placements: [UUID: Int] = [:]
 347 |             for team in round.teams {
 348 |                 for personId in team.memberPersonIds {
 349 |                     placements[personId] = 1
 350 |                 }
 351 |             }
 352 |             round.placements = placements
 353 | 
 354 |             if let event = round.eventGame?.event { touch(event) }
 355 |             try context.save()
 356 |             return
 357 |         }
 358 | 
 359 |         // Win: record winner + placements
 360 |         round.resultType = .win
 361 |         round.winningTeamId = winnerTeamId
 362 | 
 363 |         guard let winnerTeam = round.teams.first(where: { $0.id == winnerTeamId }) else {
 364 |             // If teams changed unexpectedly, still save completion state
 365 |             if let event = round.eventGame?.event { touch(event) }
 366 |             try context.save()
 367 |             return
 368 |         }
 369 | 
 370 |         var placements: [UUID: Int] = [:]
 371 | 
 372 |         // 1st place: winner team members
 373 |         for pid in winnerTeam.memberPersonIds { placements[pid] = 1 }
 374 | 
 375 |         // 2nd place (optional)
 376 |         if let secondTeamId, let secondTeam = round.teams.first(where: { $0.id == secondTeamId }) {
 377 |             for pid in secondTeam.memberPersonIds { placements[pid] = 2 }
 378 |         }
 379 | 
 380 |         // 3rd place (optional)
 381 |         if let thirdTeamId, let thirdTeam = round.teams.first(where: { $0.id == thirdTeamId }) {
 382 |             for pid in thirdTeam.memberPersonIds { placements[pid] = 3 }
 383 |         }
 384 | 
 385 |         round.placements = placements
 386 | 
 387 |         if let event = round.eventGame?.event { touch(event) }
 388 |         try context.save()
 389 |     }
 390 | 
 391 | 
 392 |     // MARK: - Helpers
 393 | 
 394 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 395 |         let descriptor = FetchDescriptor<GameTemplate>()
 396 |         let templates = try context.fetch(descriptor)
 397 |         return templates.first(where: { $0.id == id })
 398 |     }
 399 | 
 400 |     private func touch(_ event: Event) {
 401 |         event.lastModifiedAt = Date()
 402 |     }
 403 | 
 404 |     enum StartError: LocalizedError {
 405 |         case noParticipants
 406 |         case missingTemplate
 407 |         case invalidRoundCount
 408 | 
 409 |         var errorDescription: String? {
 410 |             switch self {
 411 |             case .noParticipants:
 412 |                 return "No players selected for this event. Add players before starting a game."
 413 |             case .missingTemplate:
 414 |                 return "The selected game template could not be found in the catalog."
 415 |             case .invalidRoundCount:
 416 |                 return "This game has an invalid number of rounds."
 417 |             }
 418 |         }
 419 |     }
 420 | }


END FILE: ./Christmas Games/EventEngine.swift


################################################################################
START FILE: ./Christmas Games/CurrentEventStatsSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | /// Shows live stats for a specific event in a dismissible sheet
   5 | struct CurrentEventStatsSheet: View {
   6 |     @Environment(\.dismiss) private var dismiss
   7 |     @Environment(\.modelContext) private var context
   8 |     @EnvironmentObject var themeManager: ThemeManager
   9 | 
  10 |     let event: Event
  11 | 
  12 |     @Query(sort: \Person.displayName)
  13 |     private var people: [Person]
  14 | 
  15 |     @State private var sortColumn: SortColumn = .rank
  16 |     @State private var sortAscending: Bool = true
  17 | 
  18 |     enum SortColumn {
  19 |         case name, games, rounds, first, second, third, rank
  20 |     }
  21 | 
  22 |     var body: some View {
  23 |         NavigationStack {
  24 |             ZStack {
  25 |                 themeManager.background
  26 |                     .ignoresSafeArea()
  27 | 
  28 |                 if let stats = calculatedStats {
  29 |                     statsTable(stats: stats)
  30 |                         .scrollContentBackground(.hidden)
  31 |                 } else {
  32 |                     ContentUnavailableView(
  33 |                         "No Stats Yet",
  34 |                         systemImage: "chart.bar",
  35 |                         description: Text("Play some games to see statistics.")
  36 |                     )
  37 |                     .padding()
  38 |                 }
  39 |             }
  40 |             .navigationTitle("Current Leaderboard")
  41 |             .navigationBarTitleDisplayMode(.inline)
  42 |             .toolbar {
  43 |                 ToolbarItem(placement: .topBarTrailing) {
  44 |                     Button("Done") { dismiss() }
  45 |                         .foregroundColor(themeManager.primary)
  46 |                 }
  47 |             }
  48 |         }
  49 |     }
  50 | 
  51 |     /// Definitions:
  52 |     /// - roundsPlayed: count of completed rounds where person appeared on a team
  53 |     /// - gamesPlayed: count of eventGames where person appeared in at least one completed round
  54 |     /// - placements: incremented from round.placements; if tie and placements are missing, everyone in the round gets a 1st
  55 |     private var calculatedStats: [PlayerStats]? {
  56 |         var statsDict: [UUID: PlayerStats] = [:]
  57 | 
  58 |         // For each game, we will compute the set of people who actually played in at least one completed round.
  59 |         for eventGame in event.eventGames {
  60 |             var peopleInThisGame: Set<UUID> = []
  61 | 
  62 |             for round in eventGame.rounds where round.completedAt != nil {
  63 |                 // Determine who participated in this round (from teams)
  64 |                 let participantsInRound: Set<UUID> = Set(round.teams.flatMap { $0.memberPersonIds })
  65 | 
  66 |                 // Rounds Played: +1 per completed round participated in
  67 |                 for personId in participantsInRound {
  68 |                     var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  69 |                     stat.roundsPlayed += 1
  70 |                     statsDict[personId] = stat
  71 |                 }
  72 | 
  73 |                 // Mark for Games Played rollup
  74 |                 peopleInThisGame.formUnion(participantsInRound)
  75 | 
  76 |                 // Placements (if present)
  77 |                 if !round.placements.isEmpty {
  78 |                     for (personId, placement) in round.placements {
  79 |                         var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  80 |                         switch placement {
  81 |                         case 1: stat.firstPlace += 1
  82 |                         case 2: stat.secondPlace += 1
  83 |                         case 3: stat.thirdPlace += 1
  84 |                         default: break
  85 |                         }
  86 |                         statsDict[personId] = stat
  87 |                     }
  88 |                 } else if round.resultType == .tie, round.winningTeamId == nil {
  89 |                     // Tie with no placements recorded: everyone in the round gets 1st
  90 |                     for personId in participantsInRound {
  91 |                         var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  92 |                         stat.firstPlace += 1
  93 |                         statsDict[personId] = stat
  94 |                     }
  95 |                 }
  96 |             }
  97 | 
  98 |             // Games Played: +1 per game if person participated in any completed round within that game
  99 |             for personId in peopleInThisGame {
 100 |                 var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 101 |                 stat.gamesPlayed += 1
 102 |                 statsDict[personId] = stat
 103 |             }
 104 |         }
 105 | 
 106 |         guard !statsDict.isEmpty else { return nil }
 107 | 
 108 |         let peopleById = Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 109 | 
 110 |         var result = statsDict.values.map { stat -> PlayerStats in
 111 |             var s = stat
 112 |             s.displayName = peopleById[stat.personId]?.displayName ?? "Unknown"
 113 |             s.totalPoints = (s.firstPlace * 3) + (s.secondPlace * 2) + (s.thirdPlace * 1)
 114 |             return s
 115 |         }
 116 | 
 117 |         // Apply sorting based on selected column
 118 |         switch sortColumn {
 119 |         case .name:
 120 |             result.sort { lhs, rhs in
 121 |                 sortAscending
 122 |                 ? lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedAscending
 123 |                 : lhs.displayName.localizedCaseInsensitiveCompare(rhs.displayName) == .orderedDescending
 124 |             }
 125 | 
 126 |         case .games:
 127 |             result.sort { sortAscending ? $0.gamesPlayed < $1.gamesPlayed : $0.gamesPlayed > $1.gamesPlayed }
 128 | 
 129 |         case .rounds:
 130 |             result.sort { sortAscending ? $0.roundsPlayed < $1.roundsPlayed : $0.roundsPlayed > $1.roundsPlayed }
 131 | 
 132 |         case .first:
 133 |             result.sort { sortAscending ? $0.firstPlace < $1.firstPlace : $0.firstPlace > $1.firstPlace }
 134 | 
 135 |         case .second:
 136 |             result.sort { sortAscending ? $0.secondPlace < $1.secondPlace : $0.secondPlace > $1.secondPlace }
 137 | 
 138 |         case .third:
 139 |             result.sort { sortAscending ? $0.thirdPlace < $1.thirdPlace : $0.thirdPlace > $1.thirdPlace }
 140 | 
 141 |         case .rank:
 142 |             result.sort { sortAscending ? $0.totalPoints < $1.totalPoints : $0.totalPoints > $1.totalPoints }
 143 |         }
 144 | 
 145 |         // Assign ranks based on points (for display)
 146 |         let rankedByPoints = result.sorted { $0.totalPoints > $1.totalPoints }
 147 |         var rankMap: [UUID: Int] = [:]
 148 |         for (index, stat) in rankedByPoints.enumerated() {
 149 |             rankMap[stat.personId] = index + 1
 150 |         }
 151 | 
 152 |         for i in 0..<result.count {
 153 |             result[i].rank = rankMap[result[i].personId] ?? 0
 154 |         }
 155 | 
 156 |         return result
 157 |     }
 158 | 
 159 |     private func toggleSort(column: SortColumn) {
 160 |         if sortColumn == column {
 161 |             sortAscending.toggle()
 162 |         } else {
 163 |             sortColumn = column
 164 |             sortAscending = (column == .name) // Name defaults A-Z, numbers default high-to-low
 165 |         }
 166 |     }
 167 | 
 168 |     private func sortIndicator(for column: SortColumn) -> String {
 169 |         guard sortColumn == column else { return "" }
 170 |         return sortAscending ? " ↑" : " ↓"
 171 |     }
 172 | 
 173 |     private func statsTable(stats: [PlayerStats]) -> some View {
 174 |         List {
 175 |             Section {
 176 |                 HStack {
 177 |                     Button(action: { toggleSort(column: .name) }) {
 178 |                         Text("Name\(sortIndicator(for: .name))")
 179 |                             .frame(maxWidth: .infinity, alignment: .leading)
 180 |                     }
 181 |                     .buttonStyle(.plain)
 182 | 
 183 |                     Button(action: { toggleSort(column: .games) }) {
 184 |                         Text("Games\(sortIndicator(for: .games))")
 185 |                             .frame(width: 52)
 186 |                     }
 187 |                     .buttonStyle(.plain)
 188 | 
 189 |                     Button(action: { toggleSort(column: .rounds) }) {
 190 |                         Text("Rounds\(sortIndicator(for: .rounds))")
 191 |                             .frame(width: 60)
 192 |                     }
 193 |                     .buttonStyle(.plain)
 194 | 
 195 |                     Button(action: { toggleSort(column: .first) }) {
 196 |                         Text("1st\(sortIndicator(for: .first))")
 197 |                             .frame(width: 40)
 198 |                     }
 199 |                     .buttonStyle(.plain)
 200 | 
 201 |                     Button(action: { toggleSort(column: .second) }) {
 202 |                         Text("2nd\(sortIndicator(for: .second))")
 203 |                             .frame(width: 40)
 204 |                     }
 205 |                     .buttonStyle(.plain)
 206 | 
 207 |                     Button(action: { toggleSort(column: .third) }) {
 208 |                         Text("3rd\(sortIndicator(for: .third))")
 209 |                             .frame(width: 40)
 210 |                     }
 211 |                     .buttonStyle(.plain)
 212 | 
 213 |                     Button(action: { toggleSort(column: .rank) }) {
 214 |                         Text("Rank\(sortIndicator(for: .rank))")
 215 |                             .frame(width: 50)
 216 |                     }
 217 |                     .buttonStyle(.plain)
 218 |                 }
 219 |                 .font(.caption)
 220 |                 .bold()
 221 |             }
 222 | 
 223 |             ForEach(stats) { stat in
 224 |                 HStack {
 225 |                     Text(stat.displayName)
 226 |                         .frame(maxWidth: .infinity, alignment: .leading)
 227 | 
 228 |                     Text("\(stat.gamesPlayed)").frame(width: 52)
 229 |                     Text("\(stat.roundsPlayed)").frame(width: 60)
 230 | 
 231 |                     Text("\(stat.firstPlace)").frame(width: 40)
 232 |                     Text("\(stat.secondPlace)").frame(width: 40)
 233 |                     Text("\(stat.thirdPlace)").frame(width: 40)
 234 | 
 235 |                     Text("\(stat.rank)")
 236 |                         .frame(width: 50)
 237 |                         .bold()
 238 |                 }
 239 |                 .font(.body)
 240 |             }
 241 |         }
 242 |     }
 243 | }
 244 | 
 245 | // MARK: - Stats (‘Current Leaderboard’) Model
 246 | 
 247 | private struct PlayerStats: Identifiable {
 248 |     let id = UUID()
 249 |     let personId: UUID
 250 | 
 251 |     var displayName: String = ""
 252 | 
 253 |     /// Number of EventGames the player participated in (>= 1 completed round within the game)
 254 |     var gamesPlayed: Int = 0
 255 | 
 256 |     /// Number of completed rounds the player participated in (appeared on any team)
 257 |     var roundsPlayed: Int = 0
 258 | 
 259 |     var firstPlace: Int = 0
 260 |     var secondPlace: Int = 0
 261 |     var thirdPlace: Int = 0
 262 | 
 263 |     var totalPoints: Int = 0
 264 |     var rank: Int = 0
 265 | }
 266 | 
 267 | #Preview {
 268 |     let config = ModelConfiguration(isStoredInMemoryOnly: true)
 269 |     let container = try! ModelContainer(for: Event.self, Person.self, configurations: config)
 270 | 
 271 |     let event = Event(name: "Test Event")
 272 |     container.mainContext.insert(event)
 273 | 
 274 |     return CurrentEventStatsSheet(event: event)
 275 |         .modelContainer(container)
 276 |         .environmentObject(ThemeManager())
 277 | }


END FILE: ./Christmas Games/CurrentEventStatsSheet.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogExporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogExporter {
   6 | 
   7 |     static func exportToDocuments(
   8 |         context: ModelContext,
   9 |         filename: String = "games",
  10 |         fileExtension: String = "json"
  11 |     ) throws -> URL {
  12 | 
  13 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  14 | 
  15 |         let games: [ExportGameCatalogGame] = templates
  16 |             .map { t in
  17 |                 ExportGameCatalogGame(
  18 |                     externalId: t.externalId,
  19 |                     name: t.name,
  20 |                     groupName: t.groupName,
  21 |                     defaultTeamCount: t.defaultTeamCount,
  22 |                     defaultPlayersPerTeam: t.defaultPlayersPerTeam,
  23 |                     defaultRoundsPerGame: t.defaultRoundsPerGame,
  24 |                     teamType: t.defaultTeamType,
  25 |                     playInstructions: t.playInstructions,
  26 |                     setupInstructions: t.setupInstructions
  27 |                 )
  28 |             }
  29 |             .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
  30 | 
  31 |         let catalog = ExportGameCatalog(games: games)
  32 | 
  33 |         let data = try JSONEncoder().encode(catalog)
  34 | 
  35 |         let url = try documentsURL(filename: filename, fileExtension: fileExtension)
  36 |         try data.write(to: url, options: [.atomic])
  37 | 
  38 |         return url
  39 |     }
  40 | 
  41 |     private static func documentsURL(filename: String, fileExtension: String) throws -> URL {
  42 |         let dir = try FileManager.default.url(
  43 |             for: .documentDirectory,
  44 |             in: .userDomainMask,
  45 |             appropriateFor: nil,
  46 |             create: true
  47 |         )
  48 |         return dir.appendingPathComponent("\(filename).\(fileExtension)")
  49 |     }
  50 | }
  51 | 
  52 | // MARK: - Private JSON DTOs (scoped to exporter)
  53 | 
  54 | private struct ExportGameCatalog: Codable {
  55 |     let games: [ExportGameCatalogGame]
  56 | }
  57 | 
  58 | private struct ExportGameCatalogGame: Codable {
  59 |     let externalId: String
  60 |     let name: String
  61 |     let groupName: String?
  62 |     let defaultTeamCount: Int
  63 |     let defaultPlayersPerTeam: Int
  64 |     let defaultRoundsPerGame: Int
  65 |     let teamType: TeamType
  66 |     let playInstructions: String?
  67 |     let setupInstructions: String?
  68 | }


END FILE: ./Christmas Games/GameCatalogExporter.swift


################################################################################
START FILE: ./Christmas Games/GameSettingsView.swift
################################################################################
   1 | import SwiftUI
   2 | 
   3 | struct GameSettingsView: View {
   4 |     @Environment(\.dismiss) private var dismiss
   5 |     @EnvironmentObject var themeManager: ThemeManager
   6 | 
   7 |     // Existing toggle (keep this)
   8 |     @AppStorage("gameTransitionSound") private var soundEnabled: Bool = true
   9 | 
  10 |     // NEW: which sound to use
  11 |     // Values: "random", "jeopardy1", "jeopardy2", "jeopardy3", "off"
  12 |     @AppStorage("transitionSoundName") private var transitionSoundName: String = "random"
  13 | 
  14 |     var body: some View {
  15 |         NavigationStack {
  16 |             List {
  17 | 
  18 |                 // MARK: - Game Transitions
  19 |                 Section {
  20 |                     Toggle("Enable Transition Sound", isOn: $soundEnabled)
  21 | 
  22 |                     Picker("Transition Sound", selection: $transitionSoundName) {
  23 |                         Text("Random").tag("random")
  24 |                         Text("Jeopardy 1").tag("jeopardy1")
  25 |                         Text("Jeopardy 2").tag("jeopardy2")
  26 |                         Text("Jeopardy 3").tag("jeopardy3")
  27 |                         Text("Off").tag("off")
  28 |                     }
  29 |                     .disabled(!soundEnabled)
  30 | 
  31 |                 } header: {
  32 |                     Text("Game Transitions")
  33 |                 } footer: {
  34 |                     Text("Choose which sound plays while the app is selecting the next game.")
  35 |                 }
  36 |             }
  37 |             .navigationTitle("Settings")
  38 |             .navigationBarTitleDisplayMode(.inline)
  39 |             .toolbar {
  40 |                 ToolbarItem(placement: .topBarTrailing) {
  41 |                     Button("Done") {
  42 |                         dismiss()
  43 |                     }
  44 |                     .foregroundColor(themeManager.primary)
  45 |                 }
  46 |             }
  47 |         }
  48 |     }
  49 | }
  50 | 
  51 | #Preview {
  52 |     GameSettingsView()
  53 |         .environmentObject(ThemeManager())
  54 | }


END FILE: ./Christmas Games/GameSettingsView.swift


################################################################################
START FILE: ./Christmas Games/Christmas_GamesApp.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | @main
   5 | struct Christmas_GamesApp: App {
   6 | 
   7 |     private var sharedModelContainer: ModelContainer = {
   8 |         let schema = Schema([
   9 |             Person.self,
  10 |             GameTemplate.self,
  11 |             Event.self,
  12 |             EventGame.self,
  13 |             Round.self
  14 |         ])
  15 | 
  16 |         let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
  17 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  18 |         try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  19 | 
  20 |         let storeURL = folder.appendingPathComponent("ChristmasGames_v2.store")
  21 | 
  22 |         let configuration = ModelConfiguration(schema: schema, url: storeURL)
  23 | 
  24 |         do {
  25 |             return try ModelContainer(for: schema, configurations: [configuration])
  26 |         } catch {
  27 |             fatalError("Failed to create ModelContainer: \(error)")
  28 |         }
  29 |     }()
  30 | 
  31 |     var body: some Scene {
  32 |         WindowGroup {
  33 |             MainMenuView()
  34 |         }
  35 |         .modelContainer(sharedModelContainer)
  36 |     }
  37 | }


END FILE: ./Christmas Games/Christmas_GamesApp.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct GameCatalogView: View {
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \GameTemplate.name)
   9 |     private var templates: [GameTemplate]
  10 | 
  11 |     @State private var showCreateTemplate = false
  12 |     @State private var showCSVImporter = false
  13 |     @State private var editingTemplate: GameTemplate?
  14 | 
  15 |     @State private var pendingCSVData: Data?
  16 |     @State private var pendingCSVFilename: String?
  17 |     @State private var showCSVPreview = false
  18 | 
  19 |     @State private var alertTitle = "Message"
  20 |     @State private var alertMessage: String?
  21 |     @State private var showAlert = false
  22 |     
  23 |     // Filter and sort state
  24 |     @AppStorage("gameCatalog_filterTeamSize") private var filterTeamSize: Int?
  25 |     @AppStorage("gameCatalog_filterTeamCount") private var filterTeamCount: Int?
  26 |     @AppStorage("gameCatalog_sortOption") private var sortOption: SortOption = .alphabetical
  27 |     @AppStorage("gameCatalog_teamTypeFilter") private var teamTypeFilter: TeamTypeFilter = .all
  28 |     
  29 |     enum SortOption: String, CaseIterable, Codable {
  30 |         case alphabetical = "A-Z"
  31 |         case reverseAlphabetical = "Z-A"
  32 |         case status = "Status"
  33 |     }
  34 |     
  35 |     enum TeamTypeFilter: String, CaseIterable, Codable {
  36 |         case all = "All"
  37 |         case any = "Any"
  38 |         case maleOnly = "Male Only"
  39 |         case femaleOnly = "Female Only"
  40 |         case couplesOnly = "Couples Only"
  41 |     }
  42 | 
  43 |     var body: some View {
  44 |         List {
  45 |             // Filters section
  46 |             Section {
  47 |                 HStack {
  48 |                     Picker("Team Size", selection: $filterTeamSize) {
  49 |                         Text("Any").tag(nil as Int?)
  50 |                         ForEach(availableTeamSizes, id: \.self) { size in
  51 |                             Text("\(size)").tag(size as Int?)
  52 |                         }
  53 |                     }
  54 |                     .pickerStyle(.menu)
  55 |                     
  56 |                     Picker("Teams", selection: $filterTeamCount) {
  57 |                         Text("Any").tag(nil as Int?)
  58 |                         ForEach(availableTeamCounts, id: \.self) { count in
  59 |                             Text("\(count)").tag(count as Int?)
  60 |                         }
  61 |                     }
  62 |                     .pickerStyle(.menu)
  63 |                 }
  64 |                 
  65 |                 HStack {
  66 |                     Picker("Sort", selection: $sortOption) {
  67 |                         ForEach(SortOption.allCases, id: \.self) { option in
  68 |                             Text(option.rawValue).tag(option)
  69 |                         }
  70 |                     }
  71 |                     .pickerStyle(.menu)
  72 |                     
  73 |                     Picker("Team Type", selection: $teamTypeFilter) {
  74 |                         ForEach(TeamTypeFilter.allCases, id: \.self) { filter in
  75 |                             Text(filter.rawValue).tag(filter)
  76 |                         }
  77 |                     }
  78 |                     .pickerStyle(.menu)
  79 |                 }
  80 |             } header: {
  81 |                 Text("Games (\(filteredAndSortedTemplates.count))")
  82 |             }
  83 |             
  84 |             // Games list
  85 |             Section {
  86 |                 ForEach(filteredAndSortedTemplates) { template in
  87 |                     Button {
  88 |                         editingTemplate = template
  89 |                     } label: {
  90 |                         gameRow(for: template)
  91 |                     }
  92 |                 }
  93 |                 .onDelete(perform: deleteTemplates)
  94 |             }
  95 |         }
  96 |         .navigationTitle("Game Catalog")
  97 |         .toolbar {
  98 |             ToolbarItemGroup(placement: .topBarTrailing) {
  99 |                 Button("Add") { showCreateTemplate = true }
 100 |                 Button("Import CSV") { showCSVImporter = true }
 101 |             }
 102 |         }
 103 |         .sheet(isPresented: $showCreateTemplate) {
 104 |             CreateGameTemplateSheet { _ in }
 105 |         }
 106 |         .sheet(item: $editingTemplate) { template in
 107 |             EditGameTemplateSheet(template: template)
 108 |         }
 109 |         .fileImporter(
 110 |             isPresented: $showCSVImporter,
 111 |             allowedContentTypes: [UTType.commaSeparatedText],
 112 |             allowsMultipleSelection: false
 113 |         ) { result in
 114 |             do {
 115 |                 let urls = try result.get()
 116 |                 guard let url = urls.first else { return }
 117 | 
 118 |                 let didStart = url.startAccessingSecurityScopedResource()
 119 |                 defer { if didStart { url.stopAccessingSecurityScopedResource() } }
 120 | 
 121 |                 let data = try Data(contentsOf: url)
 122 | 
 123 |                 pendingCSVData = data
 124 |                 pendingCSVFilename = url.lastPathComponent
 125 |                 showCSVPreview = true
 126 | 
 127 |             } catch {
 128 |                 alertTitle = "Import failed"
 129 |                 alertMessage = error.localizedDescription
 130 |                 showAlert = true
 131 |             }
 132 |         }
 133 |         .sheet(isPresented: $showCSVPreview) {
 134 |             if let data = pendingCSVData {
 135 |                 CSVImportPreviewSheet(csvData: data, filename: pendingCSVFilename)
 136 |             } else {
 137 |                 Text("No CSV loaded.")
 138 |                     .padding()
 139 |             }
 140 |         }
 141 |         .alert(alertTitle, isPresented: $showAlert) {
 142 |             Button("OK", role: .cancel) { }
 143 |         } message: {
 144 |             Text(alertMessage ?? "Unknown error")
 145 |         }
 146 |     }
 147 |     
 148 |     // MARK: - Computed Properties
 149 |     
 150 |     private var availableTeamSizes: [Int] {
 151 |         Set(templates.map { $0.defaultPlayersPerTeam }).sorted()
 152 |     }
 153 |     
 154 |     private var availableTeamCounts: [Int] {
 155 |         Set(templates.map { $0.defaultTeamCount }).sorted()
 156 |     }
 157 |     
 158 |     private var filteredAndSortedTemplates: [GameTemplate] {
 159 |         var result = templates
 160 |         
 161 |         // Apply team size filter
 162 |         if let filterTeamSize {
 163 |             result = result.filter { $0.defaultPlayersPerTeam == filterTeamSize }
 164 |         }
 165 |         
 166 |         // Apply team count filter
 167 |         if let filterTeamCount {
 168 |             result = result.filter { $0.defaultTeamCount == filterTeamCount }
 169 |         }
 170 |         
 171 |         // Apply team type filter
 172 |         switch teamTypeFilter {
 173 |         case .all:
 174 |             break
 175 |         case .any:
 176 |             result = result.filter { $0.defaultTeamType == .any }
 177 |         case .maleOnly:
 178 |             result = result.filter { $0.defaultTeamType == .maleOnly }
 179 |         case .femaleOnly:
 180 |             result = result.filter { $0.defaultTeamType == .femaleOnly }
 181 |         case .couplesOnly:
 182 |             result = result.filter { $0.defaultTeamType == .couplesOnly }
 183 |         }
 184 |         
 185 |         // Apply sort
 186 |         switch sortOption {
 187 |         case .alphabetical:
 188 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
 189 |         case .reverseAlphabetical:
 190 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedDescending }
 191 |         case .status:
 192 |             // For GameCatalog, we can sort by group name as a proxy for "status"
 193 |             result.sort { lhs, rhs in
 194 |                 let lGroup = lhs.groupName ?? ""
 195 |                 let rGroup = rhs.groupName ?? ""
 196 |                 if lGroup != rGroup {
 197 |                     return lGroup.localizedCaseInsensitiveCompare(rGroup) == .orderedAscending
 198 |                 }
 199 |                 return lhs.name.localizedCaseInsensitiveCompare(rhs.name) == .orderedAscending
 200 |             }
 201 |         }
 202 |         
 203 |         return result
 204 |     }
 205 |     
 206 |     private func gameRow(for template: GameTemplate) -> some View {
 207 |         VStack(alignment: .leading, spacing: 4) {
 208 |             Text(template.name)
 209 |                 .font(.body)
 210 |                 .foregroundStyle(.primary)
 211 |             
 212 |             HStack {
 213 |                 if let group = template.groupName?.trimmingCharacters(in: .whitespacesAndNewlines),
 214 |                    !group.isEmpty {
 215 |                     Text(group)
 216 |                         .font(.footnote)
 217 |                         .foregroundStyle(.secondary)
 218 |                     Text("•")
 219 |                         .font(.footnote)
 220 |                         .foregroundStyle(.secondary)
 221 |                 }
 222 |                 
 223 |                 Text("Teams: \(template.defaultTeamCount) × \(template.defaultPlayersPerTeam)")
 224 |                     .font(.footnote)
 225 |                     .foregroundStyle(.secondary)
 226 |                 
 227 |                 Text("•")
 228 |                     .font(.footnote)
 229 |                     .foregroundStyle(.secondary)
 230 |                 
 231 |                 Text("Rounds: \(template.defaultRoundsPerGame)")
 232 |                     .font(.footnote)
 233 |                     .foregroundStyle(.secondary)
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func deleteTemplates(at offsets: IndexSet) {
 239 |         for index in offsets {
 240 |             let template = filteredAndSortedTemplates[index]
 241 |             if let original = templates.first(where: { $0.id == template.id }) {
 242 |                 context.delete(original)
 243 |             }
 244 |         }
 245 |         try? context.save()
 246 |     }
 247 | }
 248 | 
 249 | // MARK: - Edit Game Template Sheet
 250 | 
 251 | private struct EditGameTemplateSheet: View {
 252 |     @Environment(\.dismiss) private var dismiss
 253 |     @Environment(\.modelContext) private var context
 254 | 
 255 |     let template: GameTemplate
 256 | 
 257 |     @State private var name = ""
 258 |     @State private var groupName = ""
 259 |     @State private var defaultTeamCount = 2
 260 |     @State private var defaultPlayersPerTeam = 2
 261 |     @State private var defaultRoundsPerGame = 1
 262 |     @State private var teamType: TeamType = .any
 263 |     @State private var playInstructions = ""
 264 |     @State private var setupInstructions = ""
 265 | 
 266 |     var body: some View {
 267 |         NavigationStack {
 268 |             Form {
 269 |                 Section("Basic") {
 270 |                     TextField("Name", text: $name)
 271 |                     TextField("Group (optional)", text: $groupName)
 272 |                 }
 273 | 
 274 |                 Section("Defaults") {
 275 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
 276 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
 277 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
 278 | 
 279 |                     Picker("Team Type", selection: $teamType) {
 280 |                         Text("Any").tag(TeamType.any)
 281 |                         Text("Male Only").tag(TeamType.maleOnly)
 282 |                         Text("Female Only").tag(TeamType.femaleOnly)
 283 |                         Text("Couples Only").tag(TeamType.couplesOnly)
 284 |                     }
 285 |                 }
 286 | 
 287 |                 Section("Instructions") {
 288 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
 289 |                         .lineLimit(3...8)
 290 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
 291 |                         .lineLimit(3...8)
 292 |                 }
 293 |             }
 294 |             .navigationTitle("Edit Game Template")
 295 |             .toolbar {
 296 |                 ToolbarItem(placement: .topBarLeading) {
 297 |                     Button("Cancel") { dismiss() }
 298 |                 }
 299 | 
 300 |                 ToolbarItem(placement: .topBarTrailing) {
 301 |                     Button("Save") { save() }
 302 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 303 |                 }
 304 |             }
 305 |             .onAppear {
 306 |                 name = template.name
 307 |                 groupName = template.groupName ?? ""
 308 |                 defaultTeamCount = template.defaultTeamCount
 309 |                 defaultPlayersPerTeam = template.defaultPlayersPerTeam
 310 |                 defaultRoundsPerGame = template.defaultRoundsPerGame
 311 |                 teamType = template.defaultTeamType
 312 |                 playInstructions = template.playInstructions ?? ""
 313 |                 setupInstructions = template.setupInstructions ?? ""
 314 |             }
 315 |         }
 316 |     }
 317 | 
 318 |     private func save() {
 319 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
 320 |         guard !trimmedName.isEmpty else { return }
 321 | 
 322 |         template.name = trimmedName
 323 |         template.groupName = groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName
 324 |         template.defaultTeamCount = defaultTeamCount
 325 |         template.defaultPlayersPerTeam = defaultPlayersPerTeam
 326 |         template.defaultRoundsPerGame = defaultRoundsPerGame
 327 |         template.defaultTeamType = teamType
 328 |         template.playInstructions = playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions
 329 |         template.setupInstructions = setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
 330 | 
 331 |         try? context.save()
 332 |         dismiss()
 333 |     }
 334 | }
 335 | 
 336 | #Preview {
 337 |     NavigationStack {
 338 |         GameCatalogView()
 339 |     }
 340 |     .modelContainer(for: [GameTemplate.self])
 341 | }


END FILE: ./Christmas Games/GameCatalogView.swift


################################################################################
START FILE: ./Christmas Games/SeedData.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum SeedData {
   5 | 
   6 |     @MainActor
   7 |     static func seedOrUpdateRoster(context: ModelContext) throws {
   8 | 
   9 |         let existing = try context.fetch(FetchDescriptor<Person>())
  10 |         var byName: [String: Person] =
  11 |             Dictionary(uniqueKeysWithValues: existing.map { ($0.displayName, $0) })
  12 | 
  13 |         let legacyNamesToDelete: Set<String> = ["Couple2-A", "Couple2-B"]
  14 |         for person in existing where legacyNamesToDelete.contains(person.displayName) {
  15 |             context.delete(person)
  16 |             byName[person.displayName] = nil
  17 |         }
  18 | 
  19 |         @discardableResult
  20 |         func upsert(
  21 |             _ name: String,
  22 |             sex: String,
  23 |             age: Int,
  24 |             weight: Int,
  25 |             athleticAbility: Int,
  26 |             height: String
  27 |         ) -> Person {
  28 | 
  29 |             if let p = byName[name] {
  30 |                 p.sex = sex
  31 |                 p.age = age
  32 |                 p.weight = weight
  33 |                 p.athleticAbility = athleticAbility
  34 |                 p.height = height
  35 |                 p.isActive = true
  36 |                 
  37 |                 // Set categories from detailed values
  38 |                 p.weightCategory = categoryForWeight(weight)
  39 |                 p.heightCategory = categoryForHeight(height)
  40 |                 
  41 |                 return p
  42 |             } else {
  43 |                 let p = Person(
  44 |                     displayName: name,
  45 |                     sex: sex,
  46 |                     age: age,
  47 |                     weight: weight,
  48 |                     athleticAbility: athleticAbility,
  49 |                     height: height,
  50 |                     weightCategory: categoryForWeight(weight),
  51 |                     heightCategory: categoryForHeight(height),
  52 |                     isActive: true
  53 |                 )
  54 |                 context.insert(p)
  55 |                 byName[name] = p
  56 |                 return p
  57 |             }
  58 |         }
  59 | 
  60 |         let dean     = upsert("Dean",     sex: "M", age: 60, weight: 250, athleticAbility: 3, height: #"6'3""#)
  61 |         let shannon  = upsert("Shannon",  sex: "F", age: 57, weight: 150, athleticAbility: 4, height: #"6'"#)
  62 | 
  63 |         let michael  = upsert("Michael",  sex: "M", age: 34, weight: 250, athleticAbility: 3, height: #"6'"#)
  64 |         let brittany = upsert("Brittany", sex: "F", age: 33, weight: 190, athleticAbility: 1, height: #"5'10""#)
  65 | 
  66 |         let blake    = upsert("Blake",    sex: "M", age: 30, weight: 250, athleticAbility: 5, height: #"6'2""#)
  67 |         let brooklin = upsert("Brooklin", sex: "F", age: 30, weight: 140, athleticAbility: 4, height: #"5'2""#)
  68 | 
  69 |         let brandon  = upsert("Brandon",  sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'6""#)
  70 |         let jenna    = upsert("Jenna",    sex: "F", age: 27, weight: 140, athleticAbility: 4, height: #"5'8""#)
  71 | 
  72 |         let hunter   = upsert("Hunter",   sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'5""#)
  73 |         let brooke   = upsert("Brooke",   sex: "F", age: 24, weight: 140, athleticAbility: 5, height: #"5'10""#)
  74 | 
  75 |         func linkSpouses(_ a: Person, _ b: Person) {
  76 |             a.spouseId = b.id
  77 |             b.spouseId = a.id
  78 |         }
  79 | 
  80 |         linkSpouses(dean, shannon)
  81 |         linkSpouses(michael, brittany)
  82 |         linkSpouses(blake, brooklin)
  83 |         linkSpouses(brandon, jenna)
  84 |         linkSpouses(hunter, brooke)
  85 | 
  86 |         try context.save()
  87 |     }
  88 |     
  89 |     // MARK: - Category Mapping
  90 |     
  91 |     private static func categoryForWeight(_ weight: Int) -> String {
  92 |         switch weight {
  93 |         case ..<160: return "S"
  94 |         case 160..<220: return "M"
  95 |         default: return "L"
  96 |         }
  97 |     }
  98 |     
  99 |     private static func categoryForHeight(_ height: String) -> String {
 100 |         // Parse height like "6'3"" → inches
 101 |         let components = height.replacingOccurrences(of: "\"", with: "").split(separator: "'")
 102 |         guard components.count == 2,
 103 |               let feet = Int(components[0]),
 104 |               let inches = Int(components[1]) else {
 105 |             return "M" // Default
 106 |         }
 107 |         
 108 |         let totalInches = (feet * 12) + inches
 109 |         
 110 |         switch totalInches {
 111 |         case ..<67: return "S"  // < 5'7"
 112 |         case 67..<73: return "M" // 5'7" - 6'0"
 113 |         default: return "L"      // > 6'0"
 114 |         }
 115 |     }
 116 | }


END FILE: ./Christmas Games/SeedData.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogCSVImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum GameCatalogCSVImporterError: LocalizedError {
   5 |     case invalidFormat(String)
   6 |     case missingRequiredColumn(String)
   7 | 
   8 |     var errorDescription: String? {
   9 |         switch self {
  10 |         case .invalidFormat(let msg): return msg
  11 |         case .missingRequiredColumn(let col): return "CSV is missing required column: \(col)"
  12 |         }
  13 |     }
  14 | }
  15 | 
  16 | @MainActor
  17 | enum GameCatalogCSVImporter {
  18 | 
  19 |     struct ImportResult {
  20 |         var insertedOrUpdated: Int
  21 |         var skipped: Int
  22 |         var removed: Int
  23 |     }
  24 | 
  25 |     /// Importer tailored for your "Minute to Win It - Head to Head" CSV:
  26 |     /// Required columns:
  27 |     /// - gameId
  28 |     /// - gameName
  29 |     /// - teamType
  30 |     ///
  31 |     /// Optional columns:
  32 |     /// - groupName
  33 |     /// - defaultTeamCount, defaultPlayersPerTeam, defaultRoundsPerGame
  34 |     /// - instructionText
  35 |     /// - Materials, Gather, Purchase, Url (ignored by default)
  36 |     /// - Check (if "x", row is skipped and counted as removed)
  37 |     static func importCSV(context: ModelContext, csvData: Data) throws -> ImportResult {
  38 | 
  39 |         guard let text = String(data: csvData, encoding: .utf8) else {
  40 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file could not be read as UTF-8 text.")
  41 |         }
  42 | 
  43 |         let rawLines = text
  44 |             .split(whereSeparator: \.isNewline)
  45 |             .map(String.init)
  46 |             .filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
  47 | 
  48 |         guard !rawLines.isEmpty else {
  49 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file is empty.")
  50 |         }
  51 | 
  52 |         // 1) Find the header row by detecting the expected columns.
  53 |         guard let headerIndex = rawLines.firstIndex(where: { line in
  54 |             let cols = parseCSVLine(line).map(normalizeHeaderKey)
  55 |             return cols.contains("gameid") && cols.contains("gamename") && cols.contains("teamtype")
  56 |         }) else {
  57 |             let firstLineCols = parseCSVLine(rawLines.first ?? "")
  58 |                 .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
  59 |                 .joined(separator: ", ")
  60 |             throw GameCatalogCSVImporterError.invalidFormat(
  61 |                 "Could not find a valid header row. Expected columns: gameId, gameName, teamType. " +
  62 |                 "First line columns were: \(firstLineCols)"
  63 |             )
  64 |         }
  65 | 
  66 |         let headerCols = parseCSVLine(rawLines[headerIndex])
  67 | 
  68 |         // Build header map; tolerate duplicate column names by keeping first occurrence.
  69 |         var headerMap: [String: Int] = [:]
  70 |         for (idx, name) in headerCols.enumerated() {
  71 |             let key = normalizeHeaderKey(name)
  72 |             if headerMap[key] == nil {
  73 |                 headerMap[key] = idx
  74 |             }
  75 |         }
  76 | 
  77 |         func colIndex(_ key: String, alternatives: [String] = []) -> Int? {
  78 |             if let i = headerMap[normalizeHeaderKey(key)] { return i }
  79 |             for alt in alternatives {
  80 |                 if let i = headerMap[normalizeHeaderKey(alt)] { return i }
  81 |             }
  82 |             return nil
  83 |         }
  84 | 
  85 |         // Required
  86 |         guard let iGameId = colIndex("gameId", alternatives: ["gameid", "id"]) else {
  87 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameId")
  88 |         }
  89 |         guard let iGameName = colIndex("gameName", alternatives: ["gamename", "name"]) else {
  90 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameName")
  91 |         }
  92 |         guard let iTeamType = colIndex("teamType", alternatives: ["teamtype"]) else {
  93 |             throw GameCatalogCSVImporterError.missingRequiredColumn("teamType")
  94 |         }
  95 | 
  96 |         // Optional
  97 |         let iGroupName = colIndex("groupName", alternatives: ["group", "groupname"])
  98 |         let iTeamCount = colIndex("defaultTeamCount", alternatives: ["defaultteamcount"])
  99 |         let iPlayersPerTeam = colIndex("defaultPlayersPerTeam", alternatives: ["defaultplayersperteam"])
 100 |         let iRounds = colIndex("defaultRoundsPerGame", alternatives: ["defaultroundspergame"])
 101 |         let iPlayInstructionText = colIndex("playInstructions", alternatives: ["playinstructions", "playinstructiontext"])
 102 |         let iSetupInstructionText = colIndex("setupInstructions", alternatives: ["setupinstructions", "setupinstructiontext"])
 103 |         let iCheck = colIndex("check", alternatives: ["Check"])
 104 | 
 105 |         var result = ImportResult(insertedOrUpdated: 0, skipped: 0, removed: 0)
 106 | 
 107 |         // 2) Process rows
 108 |         for line in rawLines.dropFirst(headerIndex + 1) {
 109 |             let cols = parseCSVLine(line)
 110 | 
 111 |             guard iGameId < cols.count, iGameName < cols.count, iTeamType < cols.count else {
 112 |                 result.skipped += 1
 113 |                 continue
 114 |             }
 115 | 
 116 |             // Check column: if "x" -> skip/remove
 117 |             if let iCheck, iCheck < cols.count {
 118 |                 let flag = cols[iCheck].trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
 119 |                 if flag == "x" {
 120 |                     result.removed += 1
 121 |                     continue
 122 |                 }
 123 |             }
 124 | 
 125 |             let gameIdRaw = cols[iGameId].trimmingCharacters(in: .whitespacesAndNewlines)
 126 |             let name = cols[iGameName].trimmingCharacters(in: .whitespacesAndNewlines)
 127 | 
 128 |             guard !gameIdRaw.isEmpty, !name.isEmpty else {
 129 |                 result.skipped += 1
 130 |                 continue
 131 |             }
 132 | 
 133 |             // Stable externalId derived from gameId
 134 |             let externalId = "mtwi_\(slug(gameIdRaw))"
 135 | 
 136 |             let groupName: String? = {
 137 |                 guard let iGroupName, iGroupName < cols.count else { return nil }
 138 |                 let g = cols[iGroupName].trimmingCharacters(in: .whitespacesAndNewlines)
 139 |                 return g.isEmpty ? nil : g
 140 |             }()
 141 | 
 142 |             let playInstructions: String? = {
 143 |                 guard let iPlayInstructionText, iPlayInstructionText < cols.count else { return nil }
 144 |                 let t = cols[iPlayInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 145 |                 return t.isEmpty ? nil : t
 146 |             }()
 147 | 
 148 |             let setupInstructions: String? = {
 149 |                 guard let iSetupInstructionText, iSetupInstructionText < cols.count else { return nil }
 150 |                 let t = cols[iSetupInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 151 |                 return t.isEmpty ? nil : t
 152 |             }()
 153 | 
 154 |             let teamType = mapTeamType(cols[iTeamType])
 155 | 
 156 |             let defaultTeamCount = parsePositiveInt(cols, iTeamCount, defaultValue: 2)
 157 |             let defaultPlayersPerTeam = parsePositiveInt(cols, iPlayersPerTeam, defaultValue: 2)
 158 |             let defaultRoundsPerGame = parsePositiveInt(cols, iRounds, defaultValue: 1)
 159 | 
 160 |             let existing = try fetchTemplateByExternalId(context: context, externalId: externalId)
 161 | 
 162 |             if let t = existing {
 163 |                 t.name = name
 164 |                 t.groupName = groupName
 165 |                 t.defaultTeamCount = defaultTeamCount
 166 |                 t.defaultPlayersPerTeam = defaultPlayersPerTeam
 167 |                 t.defaultRoundsPerGame = defaultRoundsPerGame
 168 |                 t.defaultTeamTypeRaw = teamType.rawValue
 169 |                 t.playInstructions = playInstructions
 170 |                 t.setupInstructions = setupInstructions
 171 |                 result.insertedOrUpdated += 1
 172 |             } else {
 173 |                 let t = GameTemplate(
 174 |                     externalId: externalId,
 175 |                     name: name,
 176 |                     groupName: groupName,
 177 |                     defaultTeamCount: defaultTeamCount,
 178 |                     defaultPlayersPerTeam: defaultPlayersPerTeam,
 179 |                     defaultRoundsPerGame: defaultRoundsPerGame,
 180 |                     defaultTeamType: teamType,
 181 |                     playInstructions: playInstructions,
 182 |                     setupInstructions: setupInstructions
 183 |                 )
 184 |                 context.insert(t)
 185 |                 result.insertedOrUpdated += 1
 186 |             }
 187 |         }
 188 | 
 189 |         try context.save()
 190 |         return result
 191 |     }
 192 | 
 193 |     // MARK: - Helpers
 194 | 
 195 |     private static func parsePositiveInt(_ cols: [String], _ index: Int?, defaultValue: Int) -> Int {
 196 |         guard let index, index < cols.count else { return defaultValue }
 197 |         let s = cols[index].trimmingCharacters(in: .whitespacesAndNewlines)
 198 |         if s.isEmpty { return defaultValue }
 199 |         if let v = Int(s), v > 0 { return v }
 200 |         return defaultValue
 201 |     }
 202 | 
 203 |     private static func mapTeamType(_ raw: String) -> TeamType {
 204 |         let n = raw
 205 |             .trimmingCharacters(in: .whitespacesAndNewlines)
 206 |             .lowercased()
 207 |             .replacingOccurrences(of: " ", with: "")
 208 |             .replacingOccurrences(of: "_", with: "")
 209 |             .replacingOccurrences(of: "-", with: "")
 210 | 
 211 |         if n.isEmpty { return .any }
 212 | 
 213 |         switch n {
 214 |         case "any", "anygender", "mixed", "coed", "all":
 215 |             return .any
 216 |         case "maleonly", "menonly", "boysonly", "male", "men":
 217 |             return .maleOnly
 218 |         case "femaleonly", "womenonly", "girlsonly", "female", "women":
 219 |             return .femaleOnly
 220 |         case "couplesonly", "couples", "couple", "spousesonly", "spouse":
 221 |             return .couplesOnly
 222 |         default:
 223 |             return .any
 224 |         }
 225 |     }
 226 | 
 227 |     private static func normalizeHeaderKey(_ s: String) -> String {
 228 |         let lowered = s.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
 229 |         let compact = lowered
 230 |             .replacingOccurrences(of: " ", with: "")
 231 |             .replacingOccurrences(of: "_", with: "")
 232 |         let allowed = compact.unicodeScalars.filter { CharacterSet.alphanumerics.contains($0) }
 233 |         return String(String.UnicodeScalarView(allowed))
 234 |     }
 235 | 
 236 |     private static func slug(_ s: String) -> String {
 237 |         let lowered = s.lowercased()
 238 |         let mapped = lowered.unicodeScalars.map { scalar -> Character in
 239 |             CharacterSet.alphanumerics.contains(scalar) ? Character(scalar) : "-"
 240 |         }
 241 |         let raw = String(mapped)
 242 |         let collapsed = raw
 243 |             .replacingOccurrences(of: "-+", with: "-", options: .regularExpression)
 244 |             .trimmingCharacters(in: CharacterSet(charactersIn: "-"))
 245 |         return collapsed.isEmpty ? UUID().uuidString.lowercased() : collapsed
 246 |     }
 247 | 
 248 |     /// CSV parser with quote handling (supports commas inside quoted fields)
 249 |     private static func parseCSVLine(_ line: String) -> [String] {
 250 |         var result: [String] = []
 251 |         var current = ""
 252 |         var inQuotes = false
 253 |         var i = line.startIndex
 254 | 
 255 |         while i < line.endIndex {
 256 |             let ch = line[i]
 257 | 
 258 |             if ch == "\"" {
 259 |                 let next = line.index(after: i)
 260 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 261 |                     current.append("\"")
 262 |                     i = line.index(after: next)
 263 |                     continue
 264 |                 }
 265 |                 inQuotes.toggle()
 266 |                 i = line.index(after: i)
 267 |                 continue
 268 |             }
 269 | 
 270 |             if ch == ",", !inQuotes {
 271 |                 result.append(current)
 272 |                 current = ""
 273 |                 i = line.index(after: i)
 274 |                 continue
 275 |             }
 276 | 
 277 |             current.append(ch)
 278 |             i = line.index(after: i)
 279 |         }
 280 | 
 281 |         result.append(current)
 282 |         return result
 283 |     }
 284 | 
 285 |     private static func fetchTemplateByExternalId(context: ModelContext, externalId: String) throws -> GameTemplate? {
 286 |         let descriptor = FetchDescriptor<GameTemplate>()
 287 |         let templates = try context.fetch(descriptor)
 288 |         return templates.first(where: { $0.externalId == externalId })
 289 |         }
 290 |     }
 291 | 


END FILE: ./Christmas Games/GameCatalogCSVImporter.swift


################################################################################
START FILE: ./Christmas Games/GameTransitionView.swift
################################################################################
   1 | import SwiftUI
   2 | import AVFoundation
   3 | import AudioToolbox
   4 | 
   5 | /// Animated transition view shown between games
   6 | struct GameTransitionView: View {
   7 |     @EnvironmentObject var themeManager: ThemeManager
   8 |     @AppStorage("gameTransitionSound") private var soundEnabled: Bool = true
   9 |     @AppStorage("transitionSoundName") private var transitionSoundName: String = "random"
  10 | 
  11 | 
  12 |     let onComplete: () -> Void
  13 | 
  14 |     @State private var dotCount = 0
  15 |     @State private var audioPlayer: AVAudioPlayer?
  16 | 
  17 |     var body: some View {
  18 |         ZStack {
  19 |             themeManager.background
  20 |                 .ignoresSafeArea()
  21 | 
  22 |             VStack(spacing: 22) {
  23 |                 Image(systemName: "hourglass.circle.fill")
  24 |                     .font(.system(size: 86))
  25 |                     .foregroundColor(themeManager.primary)
  26 |                     .rotationEffect(.degrees(dotCount % 2 == 0 ? -10 : 10))
  27 | 
  28 |                 Text("Selecting next game\(String(repeating: ".", count: dotCount % 4))")
  29 |                     .font(.title2)
  30 |                     .foregroundColor(themeManager.text)
  31 |             }
  32 |         }
  33 |         .onAppear {
  34 |             if soundEnabled { playSound() }
  35 |             startDotAnimation()
  36 | 
  37 |             // Keep this short so the app feels responsive.
  38 |             DispatchQueue.main.asyncAfter(deadline: .now() + 2.2) {
  39 |                 onComplete()
  40 |             }
  41 |         }
  42 |     }
  43 | 
  44 |     private func playSound() {
  45 |         // Allow user to disable
  46 |         if transitionSoundName == "off" { return }
  47 | 
  48 |         let baseName: String
  49 |         if transitionSoundName == "random" {
  50 |             baseName = ["jeopardy1", "jeopardy2", "jeopardy3"].randomElement() ?? "jeopardy1"
  51 |         } else {
  52 |             baseName = transitionSoundName
  53 |         }
  54 | 
  55 |         guard let url = Bundle.main.url(forResource: baseName, withExtension: "m4a") else {
  56 |             // Fallback: try mp3 if you ever swap formats
  57 |             if let url2 = Bundle.main.url(forResource: baseName, withExtension: "mp3") {
  58 |                 audioPlayer = try? AVAudioPlayer(contentsOf: url2)
  59 |                 audioPlayer?.volume = 1.0
  60 |                 audioPlayer?.prepareToPlay()
  61 |                 audioPlayer?.play()
  62 |             }
  63 |             return
  64 |         }
  65 | 
  66 |         audioPlayer = try? AVAudioPlayer(contentsOf: url)
  67 |         audioPlayer?.volume = 1.0
  68 |         audioPlayer?.prepareToPlay()
  69 |         audioPlayer?.play()
  70 |     }
  71 | 
  72 | 
  73 | 
  74 |     private func startDotAnimation() {
  75 |         Timer.scheduledTimer(withTimeInterval: 0.35, repeats: true) { timer in
  76 |             dotCount += 1
  77 |             if dotCount > 40 { timer.invalidate() }
  78 |         }
  79 |     }
  80 | }


END FILE: ./Christmas Games/GameTransitionView.swift


################################################################################
START FILE: ./Christmas Games/Models.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | // MARK: - Enums
   5 | 
   6 | enum EventStatus: String, Codable, CaseIterable {
   7 |     case available
   8 |     case active
   9 |     case paused
  10 |     case completed
  11 | }
  12 | 
  13 | enum GameStatus: String, Codable, CaseIterable {
  14 |     case notStarted
  15 |     case inProgress
  16 |     case completed
  17 | }
  18 | 
  19 | enum TeamType: String, Codable, CaseIterable {
  20 |     case any
  21 |     case maleOnly
  22 |     case femaleOnly
  23 |     case couplesOnly
  24 | }
  25 | 
  26 | enum RoundResultType: String, Codable, CaseIterable {
  27 |     case win
  28 |     case tie
  29 | }
  30 | 
  31 | // MARK: - People
  32 | 
  33 | @Model
  34 | final class Person {
  35 |     @Attribute(.unique) var id: UUID
  36 |     var displayName: String
  37 |     var sex: String?
  38 |     var spouseId: UUID?
  39 | 
  40 |     // Detailed (used by CSV import, FairnessEngine)
  41 |     var age: Int?
  42 |     var weight: Int?
  43 |     var athleticAbility: Int?
  44 |     var height: String?
  45 | 
  46 |     // Categories (used by simple UI)
  47 |     var weightCategory: String?   // "S", "M", "L"
  48 |     var heightCategory: String?   // "S", "M", "L"
  49 | 
  50 |     var isActive: Bool
  51 | 
  52 |     init(
  53 |         id: UUID = UUID(),
  54 |         displayName: String,
  55 |         sex: String? = nil,
  56 |         spouseId: UUID? = nil,
  57 |         age: Int? = nil,
  58 |         weight: Int? = nil,
  59 |         athleticAbility: Int? = nil,
  60 |         height: String? = nil,
  61 |         weightCategory: String? = nil,
  62 |         heightCategory: String? = nil,
  63 |         isActive: Bool = true
  64 |     ) {
  65 |         self.id = id
  66 |         self.displayName = displayName
  67 |         self.sex = sex
  68 |         self.spouseId = spouseId
  69 |         self.age = age
  70 |         self.weight = weight
  71 |         self.athleticAbility = athleticAbility
  72 |         self.height = height
  73 |         self.weightCategory = weightCategory
  74 |         self.heightCategory = heightCategory
  75 |         self.isActive = isActive
  76 |     }
  77 | }
  78 | 
  79 | // MARK: - Game Templates
  80 | 
  81 | @Model
  82 | final class GameTemplate {
  83 |     @Attribute(.unique) var id: UUID
  84 |     @Attribute(.unique) var externalId: String
  85 | 
  86 |     var name: String
  87 |     var groupName: String?
  88 | 
  89 |     var defaultTeamCount: Int
  90 |     var defaultPlayersPerTeam: Int
  91 |     var defaultRoundsPerGame: Int
  92 |     var defaultTeamTypeRaw: String
  93 | 
  94 |     var playInstructions: String?
  95 |     var setupInstructions: String?
  96 | 
  97 |     init(
  98 |         id: UUID = UUID(),
  99 |         externalId: String,
 100 |         name: String,
 101 |         groupName: String? = nil,
 102 |         defaultTeamCount: Int,
 103 |         defaultPlayersPerTeam: Int,
 104 |         defaultRoundsPerGame: Int,
 105 |         defaultTeamType: TeamType,
 106 |         playInstructions: String? = nil,
 107 |         setupInstructions: String? = nil
 108 |     ) {
 109 |         self.id = id
 110 |         self.externalId = externalId
 111 |         self.name = name
 112 |         self.groupName = groupName
 113 |         self.defaultTeamCount = defaultTeamCount
 114 |         self.defaultPlayersPerTeam = defaultPlayersPerTeam
 115 |         self.defaultRoundsPerGame = defaultRoundsPerGame
 116 |         self.defaultTeamTypeRaw = defaultTeamType.rawValue
 117 |         self.playInstructions = playInstructions
 118 |         self.setupInstructions = setupInstructions
 119 |     }
 120 | 
 121 |     @Transient
 122 |     var defaultTeamType: TeamType {
 123 |         get { TeamType(rawValue: defaultTeamTypeRaw) ?? .any }
 124 |         set { defaultTeamTypeRaw = newValue.rawValue }
 125 |     }
 126 | }
 127 | 
 128 | // MARK: - RoundTeam
 129 | 
 130 | struct RoundTeam: Codable, Equatable, Identifiable {
 131 |     var id: UUID
 132 |     var memberPersonIds: [UUID]
 133 | 
 134 |     init(id: UUID = UUID(), memberPersonIds: [UUID]) {
 135 |         self.id = id
 136 |         self.memberPersonIds = memberPersonIds
 137 |     }
 138 | }
 139 | 
 140 | // MARK: - Event
 141 | 
 142 | @Model
 143 | final class Event {
 144 |     @Attribute(.unique) var id: UUID
 145 |     var name: String
 146 | 
 147 |     var statusRaw: String
 148 |     var participantIds: [UUID]
 149 | 
 150 |     var createdAt: Date
 151 |     var lastModifiedAt: Date
 152 | 
 153 |     var currentEventGameId: UUID?
 154 | 
 155 |     @Relationship(deleteRule: .cascade, inverse: \EventGame.event)
 156 |     var eventGames: [EventGame]
 157 | 
 158 |     init(
 159 |         id: UUID = UUID(),
 160 |         name: String,
 161 |         status: EventStatus = .available,
 162 |         participantIds: [UUID] = [],
 163 |         createdAt: Date = Date(),
 164 |         lastModifiedAt: Date = Date(),
 165 |         currentEventGameId: UUID? = nil,
 166 |         eventGames: [EventGame] = []
 167 |     ) {
 168 |         self.id = id
 169 |         self.name = name
 170 |         self.statusRaw = status.rawValue
 171 |         self.participantIds = participantIds
 172 |         self.createdAt = createdAt
 173 |         self.lastModifiedAt = lastModifiedAt
 174 |         self.currentEventGameId = currentEventGameId
 175 |         self.eventGames = eventGames
 176 |     }
 177 | 
 178 |     @Transient
 179 |     var status: EventStatus {
 180 |         get { EventStatus(rawValue: statusRaw) ?? .available }
 181 |         set { statusRaw = newValue.rawValue }
 182 |     }
 183 | }
 184 | 
 185 | // MARK: - EventGame
 186 | 
 187 | @Model
 188 | final class EventGame {
 189 |     @Attribute(.unique) var id: UUID
 190 | 
 191 |     var event: Event?
 192 | 
 193 |     var gameTemplateId: UUID
 194 |     var orderIndex: Int
 195 |     var statusRaw: String
 196 | 
 197 |     var overrideTeamCount: Int?
 198 |     var overridePlayersPerTeam: Int?
 199 |     var overrideRoundsPerGame: Int?
 200 |     var overrideTeamTypeRaw: String?
 201 |     var overridePlayInstructions: String?
 202 |     var overrideSetupInstructions: String?
 203 | 
 204 |     var overrideTeamPlayersData: Data?
 205 | 
 206 |     @Relationship(deleteRule: .cascade, inverse: \Round.eventGame)
 207 |     var rounds: [Round]
 208 | 
 209 |     init(
 210 |         id: UUID = UUID(),
 211 |         event: Event? = nil,
 212 |         gameTemplateId: UUID,
 213 |         orderIndex: Int,
 214 |         status: GameStatus = .notStarted,
 215 |         overrideTeamCount: Int? = nil,
 216 |         overridePlayersPerTeam: Int? = nil,
 217 |         overrideRoundsPerGame: Int? = nil,
 218 |         overrideTeamType: TeamType? = nil,
 219 |         overrideTeamPlayers: [[UUID]]? = nil,
 220 |         overridePlayInstructions: String? = nil,
 221 |         overrideSetupInstructions: String? = nil,
 222 |         rounds: [Round] = []
 223 |     ) {
 224 |         self.id = id
 225 |         self.event = event
 226 |         self.gameTemplateId = gameTemplateId
 227 |         self.orderIndex = orderIndex
 228 |         self.statusRaw = status.rawValue
 229 |         self.overrideTeamCount = overrideTeamCount
 230 |         self.overridePlayersPerTeam = overridePlayersPerTeam
 231 |         self.overrideRoundsPerGame = overrideRoundsPerGame
 232 |         self.overrideTeamTypeRaw = overrideTeamType?.rawValue
 233 |         if let overrideTeamPlayers {
 234 |             self.overrideTeamPlayersData = try? JSONEncoder().encode(overrideTeamPlayers)
 235 |         } else {
 236 |             self.overrideTeamPlayersData = nil
 237 |         }
 238 |         self.overridePlayInstructions = overridePlayInstructions
 239 |         self.overrideSetupInstructions = overrideSetupInstructions
 240 |         self.rounds = rounds
 241 |     }
 242 | 
 243 |     @Transient
 244 |     var status: GameStatus {
 245 |         get { GameStatus(rawValue: statusRaw) ?? .notStarted }
 246 |         set { statusRaw = newValue.rawValue }
 247 |     }
 248 | 
 249 |     @Transient
 250 |     var overrideTeamType: TeamType? {
 251 |         get { overrideTeamTypeRaw.flatMap { TeamType(rawValue: $0) } }
 252 |         set { overrideTeamTypeRaw = newValue?.rawValue }
 253 |     }
 254 | 
 255 |     @Transient
 256 |     var overrideTeamPlayers: [[UUID]]? {
 257 |         get {
 258 |             guard let data = overrideTeamPlayersData else { return nil }
 259 |             return try? JSONDecoder().decode([[UUID]].self, from: data)
 260 |         }
 261 |         set {
 262 |             if let newValue {
 263 |                 overrideTeamPlayersData = try? JSONEncoder().encode(newValue)
 264 |             } else {
 265 |                 overrideTeamPlayersData = nil
 266 |             }
 267 |         }
 268 |     }
 269 | }
 270 | 
 271 | // MARK: - Round
 272 | 
 273 | @Model
 274 | final class Round {
 275 |     @Attribute(.unique) var id: UUID
 276 | 
 277 |     var eventGame: EventGame?
 278 | 
 279 |     var roundIndex: Int
 280 |     var createdAt: Date
 281 |     var completedAt: Date?
 282 | 
 283 |     var teamsData: Data
 284 |     var placementsData: Data
 285 | 
 286 |     var resultTypeRaw: String?
 287 |     var winningTeamId: UUID?
 288 |   
 289 | 
 290 |     init(
 291 |         id: UUID = UUID(),
 292 |         eventGame: EventGame? = nil,
 293 |         roundIndex: Int,
 294 |         createdAt: Date = Date(),
 295 |         completedAt: Date? = nil,
 296 |         teams: [RoundTeam] = [],
 297 |         placements: [UUID: Int] = [:],
 298 |         resultType: RoundResultType? = nil,
 299 |         winningTeamId: UUID? = nil
 300 |     ) {
 301 |         self.id = id
 302 |         self.eventGame = eventGame
 303 |         self.roundIndex = roundIndex
 304 |         self.createdAt = createdAt
 305 |         self.completedAt = completedAt
 306 |         self.teamsData = (try? JSONEncoder().encode(teams)) ?? Data()
 307 |         self.placementsData = (try? JSONEncoder().encode(placements)) ?? Data()
 308 |         self.resultTypeRaw = resultType?.rawValue
 309 |         self.winningTeamId = winningTeamId
 310 |     }
 311 | 
 312 |     @Transient
 313 |     var teams: [RoundTeam] {
 314 |         get { (try? JSONDecoder().decode([RoundTeam].self, from: teamsData)) ?? [] }
 315 |         set { teamsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 316 |     }
 317 | 
 318 |     @Transient
 319 |     var placements: [UUID: Int] {
 320 |         get { (try? JSONDecoder().decode([UUID: Int].self, from: placementsData)) ?? [:] }
 321 |         set { placementsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 322 |     }
 323 | 
 324 |     @Transient
 325 |     var resultType: RoundResultType? {
 326 |         get { resultTypeRaw.flatMap { RoundResultType(rawValue: $0) } }
 327 |         set { resultTypeRaw = newValue?.rawValue }
 328 |     }
 329 | 
 330 |     @Transient
 331 |     var isLocked: Bool {
 332 |         completedAt != nil
 333 |     }
 334 | }

END FILE: ./Christmas Games/Models.swift


################################################################################
START FILE: ./Christmas Games/Theme.swift
################################################################################
   1 | import SwiftUI
   2 | import Combine
   3 | 
   4 | // MARK: - Color Extension for Luminance
   5 | extension Color {
   6 |     // Initialize from Hex
   7 |     init(hex: String) {
   8 |         let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
   9 |         var int: UInt64 = 0
  10 |         Scanner(string: hex).scanHexInt64(&int)
  11 |         let a, r, g, b: UInt64
  12 |         switch hex.count {
  13 |         case 3: // RGB (12-bit)
  14 |             (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
  15 |         case 6: // RGB (24-bit)
  16 |             (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
  17 |         case 8: // ARGB (32-bit)
  18 |             (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
  19 |         default:
  20 |             (a, r, g, b) = (255, 0, 0, 0)
  21 |         }
  22 |         self.init(
  23 |             .sRGB,
  24 |             red: Double(r) / 255,
  25 |             green: Double(g) / 255,
  26 |             blue: Double(b) / 255,
  27 |             opacity: Double(a) / 255
  28 |         )
  29 |     }
  30 |     
  31 |     func toHex() -> String? {
  32 |         let uic = UIColor(self)
  33 |         guard let components = uic.cgColor.components, components.count >= 3 else {
  34 |             return nil
  35 |         }
  36 |         let r = Float(components[0])
  37 |         let g = Float(components[1])
  38 |         let b = Float(components[2])
  39 |         var a = Float(1.0)
  40 |         
  41 |         if components.count >= 4 { a = Float(components[3]) }
  42 |         
  43 |         if a != 1.0 {
  44 |             return String(format: "%02lX%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255), lroundf(a * 255))
  45 |         } else {
  46 |             return String(format: "%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255))
  47 |         }
  48 |     }
  49 | 
  50 |     var isLight: Bool {
  51 |         let uiColor = UIColor(self)
  52 |         var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
  53 |         
  54 |         if !uiColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha) {
  55 |             return true
  56 |         }
  57 |         
  58 |         let brightness = ((red * 299) + (green * 587) + (blue * 114)) / 1000
  59 |         return brightness > 0.5
  60 |     }
  61 | }
  62 | 
  63 | // MARK: - Dynamic Theme Model
  64 | struct Theme: Identifiable, Equatable {
  65 |     let id: String
  66 |     
  67 |     let primary: Color
  68 |     let secondary: Color
  69 |     let background: Color
  70 |     let card: Color
  71 |     let text: Color
  72 |     let divider: Color
  73 |     let onPrimary: Color
  74 |     
  75 |     /// Create a theme from a single base color and intensity
  76 |     init(hex: String, intensity: Double) {
  77 |         self.id = hex
  78 |         
  79 |         let base = Color(hex: hex)
  80 |         
  81 |         self.primary = base
  82 |         self.secondary = base.opacity(0.6)
  83 |         
  84 |         // Get base color RGB components
  85 |         let uiBase = UIColor(base)
  86 |         var baseR: CGFloat = 0, baseG: CGFloat = 0, baseB: CGFloat = 0, baseA: CGFloat = 0
  87 |         uiBase.getRed(&baseR, green: &baseG, blue: &baseB, alpha: &baseA)
  88 |         
  89 |         // Clamp intensity to valid range (allow full 0-1 range now)
  90 |         let clampedIntensity = max(0.0, min(1.0, intensity))
  91 |         
  92 |         // Calculate the EFFECTIVE color after alpha-blending with white background
  93 |         // Formula: effectiveColor = baseColor * alpha + white * (1 - alpha)
  94 |         let effectiveR = baseR * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  95 |         let effectiveG = baseG * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  96 |         let effectiveB = baseB * clampedIntensity + 1.0 * (1.0 - clampedIntensity)
  97 |         
  98 |         // Create the light mode background using the blended color (opaque)
  99 |         let lightModeBackground = UIColor(red: effectiveR, green: effectiveG, blue: effectiveB, alpha: 1.0)
 100 |         
 101 |         self.background = Color(UIColor { traitCollection in
 102 |             if traitCollection.userInterfaceStyle == .dark {
 103 |                 return .systemGroupedBackground
 104 |             } else {
 105 |                 return lightModeBackground
 106 |             }
 107 |         })
 108 |         
 109 |         self.card = Color(UIColor { traitCollection in
 110 |             return traitCollection.userInterfaceStyle == .dark ? .secondarySystemGroupedBackground : .white
 111 |         })
 112 |         
 113 |         self.divider = Color.gray.opacity(0.2)
 114 |         
 115 |         // Text on Primary: High contrast
 116 |         self.onPrimary = base.isLight ? Color.black : Color.white
 117 |         
 118 |         // Calculate luminance of the effective blended background
 119 |         let effectiveLuminance = (effectiveR * 0.299) + (effectiveG * 0.587) + (effectiveB * 0.114)
 120 |         // Raised threshold from 0.5 to 0.75 so text flips to white earlier
 121 |         let effectiveBgIsLight = effectiveLuminance > 0.75
 122 |         
 123 |         // For dynamic text that adapts to light/dark mode
 124 |         self.text = Color(UIColor { traitCollection in
 125 |             if traitCollection.userInterfaceStyle == .dark {
 126 |                 return .label
 127 |             } else {
 128 |                 // Light mode: flip based on effective background luminance
 129 |                 return effectiveBgIsLight ? .label : .white
 130 |             }
 131 |         })
 132 |     }
 133 | }
 134 | 
 135 | // MARK: - Theme Manager
 136 | @MainActor
 137 | final class ThemeManager: ObservableObject {
 138 |     private let storageKeyHex = "selectedThemeHex"
 139 |     private let storageKeyIntensity = "selectedThemeIntensity"
 140 |     private let defaultHex = "B22222" // Christmas red as default
 141 |     
 142 |     @Published var selectedThemeId: String {
 143 |         didSet { updateTheme() }
 144 |     }
 145 |     
 146 |     @Published var currentIntensity: Double {
 147 |         didSet { updateTheme() }
 148 |     }
 149 |     
 150 |     @Published private(set) var currentTheme: Theme
 151 |     
 152 |     init() {
 153 |         let savedHex = UserDefaults.standard.string(forKey: storageKeyHex) ?? defaultHex
 154 |         let savedIntensityDouble = UserDefaults.standard.double(forKey: storageKeyIntensity)
 155 |         let resolvedIntensity = savedIntensityDouble == 0 ? 0.15 : savedIntensityDouble
 156 |         
 157 |         self.selectedThemeId = savedHex
 158 |         self.currentIntensity = resolvedIntensity
 159 |         self.currentTheme = Theme(hex: savedHex, intensity: resolvedIntensity)
 160 |     }
 161 |     
 162 |     private func updateTheme() {
 163 |         UserDefaults.standard.set(selectedThemeId, forKey: storageKeyHex)
 164 |         UserDefaults.standard.set(currentIntensity, forKey: storageKeyIntensity)
 165 |         self.currentTheme = Theme(hex: selectedThemeId, intensity: currentIntensity)
 166 |     }
 167 |     
 168 |     // Convenience Proxies
 169 |     var primary: Color { currentTheme.primary }
 170 |     var secondary: Color { currentTheme.secondary }
 171 |     var background: Color { currentTheme.background }
 172 |     var card: Color { currentTheme.card }
 173 |     var text: Color { currentTheme.text }
 174 |     var divider: Color { currentTheme.divider }
 175 |     var onPrimary: Color { currentTheme.onPrimary }
 176 | }
 177 | 
 178 | // MARK: - Team Colors for Gameplay
 179 | extension ThemeManager {
 180 |     /// Get team colors that work well with the current theme
 181 |     /// Returns a set of 6 distinct colors suitable for team identification
 182 |     var teamColors: [Color] {
 183 |         // Use classic, high-contrast team colors that work with any theme
 184 |         return [
 185 |             .red,
 186 |             .blue,
 187 |             .green,
 188 |             .orange,
 189 |             .purple,
 190 |             Color(red: 0.0, green: 0.7, blue: 0.7)  // Teal
 191 |         ]
 192 |     }
 193 |     
 194 |     /// Get status color for events
 195 |     func statusColor(_ status: EventStatus) -> Color {
 196 |         switch status {
 197 |         case .available: return .gray
 198 |         case .active: return primary
 199 |         case .paused: return .orange
 200 |         case .completed: return .blue
 201 |         }
 202 |     }
 203 | }


END FILE: ./Christmas Games/Theme.swift


################################################################################
START FILE: ./Christmas Games/ParticipantCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct ParticipantCatalogView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @EnvironmentObject var themeManager: ThemeManager
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var people: [Person]
  10 | 
  11 |     @State private var showCreatePerson = false
  12 |     @State private var editingPerson: Person?
  13 | 
  14 |     @State private var alertTitle = "Message"
  15 |     @State private var alertMessage: String?
  16 |     @State private var showAlert = false
  17 | 
  18 |     var body: some View {
  19 |         ZStack {
  20 |             // Solid background
  21 |             themeManager.background
  22 |                 .ignoresSafeArea()
  23 | 
  24 |             // Your existing List
  25 |             List {
  26 |                 ForEach(people) { person in
  27 |                     Button {
  28 |                         editingPerson = person
  29 |                     } label: {
  30 |                         HStack {
  31 |                             VStack(alignment: .leading, spacing: 4) {
  32 |                                 Text(person.displayName)
  33 |                                     .font(.body)
  34 |                                     .foregroundStyle(.primary)
  35 | 
  36 |                                 if let sex = person.sex {
  37 |                                     Text("Gender: \(sex)")
  38 |                                         .font(.footnote)
  39 |                                         .foregroundStyle(.secondary)
  40 |                                 }
  41 |                             }
  42 | 
  43 |                             Spacer()
  44 | 
  45 |                             if !person.isActive {
  46 |                                 Text("Inactive")
  47 |                                     .font(.footnote)
  48 |                                     .foregroundStyle(.secondary)
  49 |                             }
  50 |                         }
  51 |                     }
  52 |                 }
  53 |                 .onDelete(perform: deletePeople)
  54 |             }
  55 |             .scrollContentBackground(.hidden)
  56 |         }
  57 |         .navigationTitle("Participant Catalog")
  58 |         .toolbarBackground(.hidden, for: .navigationBar)
  59 |         .toolbar {
  60 |             ToolbarItem(placement: .topBarTrailing) {
  61 |                 Button("Add") { showCreatePerson = true }
  62 |                     .foregroundColor(themeManager.text)
  63 |             }
  64 |         }
  65 |         .sheet(isPresented: $showCreatePerson) {
  66 |             CreatePersonSheet()
  67 |                 .environmentObject(themeManager)
  68 |         }
  69 |         .sheet(item: $editingPerson) { person in
  70 |             EditPersonSheet(person: person)
  71 |                 .environmentObject(themeManager)
  72 |         }
  73 |         .alert(alertTitle, isPresented: $showAlert) {
  74 |             Button("OK", role: .cancel) { }
  75 |         } message: {
  76 |             Text(alertMessage ?? "Unknown error")
  77 |         }
  78 |     }
  79 | 
  80 |     private func deletePeople(at offsets: IndexSet) {
  81 |         for index in offsets {
  82 |             context.delete(people[index])
  83 |         }
  84 |         try? context.save()
  85 |     }
  86 | }
  87 | 
  88 | #Preview {
  89 |     NavigationStack {
  90 |         ParticipantCatalogView()
  91 |     }
  92 |     .modelContainer(for: [Person.self])
  93 |     .environmentObject(ThemeManager())
  94 | }


END FILE: ./Christmas Games/ParticipantCatalogView.swift


################################################################################
START FILE: ./Christmas Games/WinnerCelebrationOverlay.swift
################################################################################
   1 | import SwiftUI
   2 | 
   3 | struct WinnerCelebrationOverlay: View {
   4 |     @EnvironmentObject var themeManager: ThemeManager
   5 | 
   6 |     let title: String
   7 |     let lines: [String]
   8 |     let useGifs: Bool
   9 |     let onNext: () -> Void
  10 |     let onClose: () -> Void
  11 | 
  12 |     // Lightweight “reaction” placeholder.
  13 |     // When you wire GIFs, replace this with a random GIF view.
  14 |     @State private var emoji = ["🎉", "🏆", "✨", "👏"].randomElement() ?? "🎉"
  15 | 
  16 |     var body: some View {
  17 |         ZStack {
  18 |             Color.black.opacity(0.65).ignoresSafeArea()
  19 | 
  20 |             VStack(spacing: 14) {
  21 |                 Text(useGifs ? emoji : "🏆")
  22 |                     .font(.system(size: 56))
  23 | 
  24 |                 Text(title)
  25 |                     .font(.title)
  26 |                     .fontWeight(.bold)
  27 |                     .foregroundColor(.white)
  28 | 
  29 |                 ForEach(lines, id: \.self) { line in
  30 |                     Text(line)
  31 |                         .font(.headline)
  32 |                         .foregroundColor(.white.opacity(0.95))
  33 |                         .multilineTextAlignment(.center)
  34 |                         .padding(.horizontal, 20)
  35 |                 }
  36 | 
  37 |                 HStack(spacing: 12) {
  38 |                     Button("Close") { onClose() }
  39 |                         .buttonStyle(.bordered)
  40 |                         .tint(.white.opacity(0.85))
  41 | 
  42 |                     Button("Next") { onNext() }
  43 |                         .buttonStyle(.borderedProminent)
  44 |                         .tint(themeManager.primary)
  45 |                 }
  46 |                 .padding(.top, 10)
  47 |             }
  48 |             .padding(.vertical, 26)
  49 |             .padding(.horizontal, 18)
  50 |             .background(
  51 |                 RoundedRectangle(cornerRadius: 22, style: .continuous)
  52 |                     .fill(Color.white.opacity(0.10))
  53 |             )
  54 |             .overlay(
  55 |                 RoundedRectangle(cornerRadius: 22, style: .continuous)
  56 |                     .stroke(Color.white.opacity(0.15), lineWidth: 1)
  57 |             )
  58 |             .padding(24)
  59 |         }
  60 |     }
  61 | }


END FILE: ./Christmas Games/WinnerCelebrationOverlay.swift


################################################################################
START FILE: ./Christmas Games/EventsListView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct EventsListView: View {
   6 |     @Environment(\.modelContext) private var context
   7 |     @EnvironmentObject var themeManager: ThemeManager
   8 | 
   9 |     @Query(sort: \Event.createdAt, order: .reverse)
  10 |     private var events: [Event]
  11 | 
  12 |     @State private var showAddEvent = false
  13 | 
  14 |     var body: some View {
  15 |         ZStack {
  16 |             themeManager.background
  17 |                 .ignoresSafeArea()
  18 | 
  19 |             List {
  20 |                 ForEach(events) { event in
  21 |                     NavigationLink {
  22 |                         EventDetailView(event: event)
  23 |                             .environmentObject(themeManager)
  24 |                     } label: {
  25 |                         VStack(alignment: .leading, spacing: 4) {
  26 |                             Text(event.name).font(.headline)
  27 |                             Text(event.statusRaw.capitalized)
  28 |                                 .font(.subheadline)
  29 |                                 .foregroundStyle(.secondary)
  30 |                         }
  31 |                     }
  32 |                 }
  33 |                 .onDelete(perform: deleteEvents)
  34 |             }
  35 |             .scrollContentBackground(.hidden)
  36 |         }
  37 |         .navigationTitle("Events")
  38 |         .toolbarBackground(.hidden, for: .navigationBar)
  39 |         .toolbar {
  40 |             ToolbarItem(placement: .topBarTrailing) {
  41 |                 Button("Add Event") { showAddEvent = true }
  42 |                     .foregroundColor(themeManager.text)
  43 |             }
  44 |         }
  45 |         .sheet(isPresented: $showAddEvent) {
  46 |             AddEventSheet()
  47 |                 .environmentObject(themeManager)
  48 |         }
  49 |     }
  50 | 
  51 |     private func deleteEvents(at offsets: IndexSet) {
  52 |         for index in offsets { context.delete(events[index]) }
  53 |         try? context.save()
  54 |     }
  55 | }
  56 | 
  57 | // MARK: - Event Detail
  58 | 
  59 | private struct EventDetailView: View {
  60 |     @Environment(\.modelContext) private var context
  61 |     @EnvironmentObject var themeManager: ThemeManager
  62 | 
  63 |     let event: Event
  64 | 
  65 |     @Query(sort: \GameTemplate.name)
  66 |     private var templates: [GameTemplate]
  67 | 
  68 |     @State private var showAddGame = false
  69 |     @State private var showPlayers = false
  70 |     @State private var showResetConfirm = false
  71 |     @State private var showEventStats = false
  72 | 
  73 |     @State private var message: String?
  74 |     @State private var showMessage = false
  75 | 
  76 |     // Filter and sort state
  77 |     @State private var filterTeamSize: Int? = nil
  78 |     @State private var filterTeamCount: Int? = nil
  79 |     @State private var sortOption: SortOption = .orderIndex
  80 |     @State private var statusFilter: StatusFilter = .all
  81 | 
  82 |     enum SortOption: String, CaseIterable {
  83 |         case orderIndex = "Order"
  84 |         case alphabetical = "A-Z"
  85 |         case reverseAlphabetical = "Z-A"
  86 |         case status = "Status"
  87 |     }
  88 | 
  89 |     enum StatusFilter: String, CaseIterable {
  90 |         case all = "All"
  91 |         case notStarted = "Not Started"
  92 |         case inProgress = "In Progress"
  93 |         case completed = "Completed"
  94 |         
  95 |         var gameStatus: GameStatus? {
  96 |             switch self {
  97 |             case .all: return nil
  98 |             case .notStarted: return .notStarted
  99 |             case .inProgress: return .inProgress
 100 |             case .completed: return .completed
 101 |             }
 102 |         }
 103 |     }
 104 | 
 105 |     var body: some View {
 106 |         ZStack {
 107 |             themeManager.background
 108 |                 .ignoresSafeArea()
 109 | 
 110 |             List {
 111 |                 // Compact stats section
 112 |                 Section {
 113 |                     HStack {
 114 |                         Label("\(event.participantIds.count)", systemImage: "person.2")
 115 |                         Spacer()
 116 |                         Label("\(completedGamesCount)/\(event.eventGames.count)", systemImage: "gamecontroller")
 117 |                         Spacer()
 118 |                         Label(event.statusRaw.capitalized, systemImage: statusIcon)
 119 |                             .foregroundStyle(statusColor)
 120 |                     }
 121 |                     .font(.subheadline)
 122 |                 }
 123 | 
 124 |                 Section {
 125 |                     NavigationLink("Run Event") {
 126 |                         RunGameView(event: event)
 127 |                             .environmentObject(themeManager)
 128 |                     }
 129 |                     .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty)
 130 |                 } header: {
 131 |                     Text("Host")
 132 |                 }
 133 | 
 134 |                 Section {
 135 |                     // Filters
 136 |                     HStack {
 137 |                         Picker("Team Size", selection: $filterTeamSize) {
 138 |                             Text("Any").tag(Int?.none)
 139 |                             ForEach(allTeamSizes, id: \.self) { size in
 140 |                                 Text("\(size)").tag(Int?.some(size))
 141 |                             }
 142 |                         }
 143 |                         .pickerStyle(.menu)
 144 | 
 145 |                         Picker("Team Count", selection: $filterTeamCount) {
 146 |                             Text("Any").tag(Int?.none)
 147 |                             ForEach(allTeamCounts, id: \.self) { count in
 148 |                                 Text("\(count)").tag(Int?.some(count))
 149 |                             }
 150 |                         }
 151 |                         .pickerStyle(.menu)
 152 |                     }
 153 | 
 154 |                     Picker("Status", selection: $statusFilter) {
 155 |                         ForEach(StatusFilter.allCases, id: \.self) { s in
 156 |                             Text(s.rawValue).tag(s)
 157 |                         }
 158 |                     }
 159 |                     .pickerStyle(.segmented)
 160 | 
 161 |                     Picker("Sort", selection: $sortOption) {
 162 |                         ForEach(SortOption.allCases, id: \.self) { s in
 163 |                             Text(s.rawValue).tag(s)
 164 |                         }
 165 |                     }
 166 |                     .pickerStyle(.segmented)
 167 |                 } header: {
 168 |                     Text("Filters & Sort")
 169 |                 }
 170 | 
 171 |                 Section {
 172 |                     Button("Participants") { showPlayers = true }
 173 |                     Button {
 174 |                         showPlayers = true
 175 |                     } label: {
 176 |                         Label("Manage Participants", systemImage: "person.3")
 177 |                     }
 178 | 
 179 |                 } header: {
 180 |                     Text("Manage")
 181 |                 }
 182 | 
 183 |                 Section {
 184 |                     Button("Add Games") { showAddGame = true }
 185 |                     Button("Reset Event", role: .destructive) { showResetConfirm = true }
 186 |                 } header: {
 187 |                     Text("Actions")
 188 |                 }
 189 | 
 190 |                 Section {
 191 |                     ForEach(filteredAndSortedGames) { eg in
 192 |                         NavigationLink {
 193 |                             EventGameDetailView(event: event, eventGame: eg)
 194 |                                 .environmentObject(themeManager)
 195 |                         } label: {
 196 |                             gameRow(for: eg)
 197 |                         }
 198 |                     }
 199 |                     .onDelete(perform: deleteEventGames)
 200 |                     .onMove(perform: moveEventGames)
 201 |                 } header: {
 202 |                     Text("Games")
 203 |                 }
 204 |             }
 205 |             .scrollContentBackground(.hidden)
 206 |         }
 207 |         .navigationBarTitleDisplayMode(.inline)
 208 |         .toolbarBackground(.hidden, for: .navigationBar)
 209 |         .toolbar {
 210 |             ToolbarItem(placement: .principal) {
 211 |                 Text(event.name)
 212 |                     .font(.title2.bold())
 213 |                     .lineLimit(1)
 214 |                     .minimumScaleFactor(0.5)
 215 |                     .foregroundColor(themeManager.text)
 216 |             }
 217 |             
 218 |             ToolbarItem(placement: .topBarLeading) {
 219 |                 lifecycleButton
 220 |             }
 221 |             ToolbarItem(placement: .topBarTrailing) {
 222 |                 EditButton()
 223 |                     .foregroundColor(themeManager.text)
 224 |             }
 225 |         }
 226 |         .sheet(isPresented: $showPlayers) {
 227 |             ParticipantPickerSheet(event: event)
 228 |                 .environmentObject(themeManager)
 229 |         }
 230 |         .sheet(isPresented: $showAddGame) {
 231 |             AddGamesSheet(event: event, templates: templates)
 232 |                 .environmentObject(themeManager)
 233 |         }
 234 |         .sheet(isPresented: $showEventStats) {
 235 |             CurrentEventStatsSheet(event: event)
 236 |                 .environmentObject(themeManager)
 237 |         }
 238 |         .alert("Message", isPresented: $showMessage) {
 239 |             Button("OK", role: .cancel) { }
 240 |         } message: {
 241 |             Text(message ?? "Unknown error")
 242 |         }
 243 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
 244 |             Button("Reset Event", role: .destructive) {
 245 |                 do {
 246 |                     try EventEngine(context: context).resetEvent(event)
 247 |                 } catch {
 248 |                     message = error.localizedDescription
 249 |                     showMessage = true
 250 |                 }
 251 |             }
 252 |             Button("Cancel", role: .cancel) { }
 253 |         } message: {
 254 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 255 |         }
 256 |     }
 257 | 
 258 |     // MARK: - Derived data
 259 | 
 260 |     private var engine: EventEngine { EventEngine(context: context) }
 261 | 
 262 |     private var completedGamesCount: Int {
 263 |         event.eventGames.filter { $0.status == .completed }.count
 264 |     }
 265 | 
 266 |     private var statusIcon: String {
 267 |         switch event.status {
 268 |         case .available: return "circle"
 269 |         case .active: return "play.circle.fill"
 270 |         case .paused: return "pause.circle.fill"
 271 |         case .completed: return "checkmark.circle.fill"
 272 |         }
 273 |     }
 274 | 
 275 |     private var statusColor: Color {
 276 |         themeManager.statusColor(event.status)
 277 |     }
 278 | 
 279 |     private var allTeamSizes: [Int] {
 280 |         let arr = Array(Set(event.eventGames.compactMap { eg -> Int? in
 281 |             let t = templates.first(where: { $0.id == eg.gameTemplateId })
 282 |             return eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam
 283 |         }))
 284 |         return arr.sorted()
 285 |     }
 286 | 
 287 |     private var allTeamCounts: [Int] {
 288 |         let arr = Array(Set(event.eventGames.compactMap { eg -> Int? in
 289 |             let t = templates.first(where: { $0.id == eg.gameTemplateId })
 290 |             return eg.overrideTeamCount ?? t?.defaultTeamCount
 291 |         }))
 292 |         return arr.sorted()
 293 |     }
 294 | 
 295 |     private var filteredAndSortedGames: [EventGame] {
 296 |         var games = event.eventGames
 297 | 
 298 |         // Apply team size filter
 299 |         if let size = filterTeamSize {
 300 |             games = games.filter { eg in
 301 |                 let t = templates.first(where: { $0.id == eg.gameTemplateId })
 302 |                 let ppt = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 0
 303 |                 return ppt == size
 304 |             }
 305 |         }
 306 | 
 307 |         // Apply team count filter
 308 |         if let count = filterTeamCount {
 309 |             games = games.filter { eg in
 310 |                 let t = templates.first(where: { $0.id == eg.gameTemplateId })
 311 |                 let tc = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 0
 312 |                 return tc == count
 313 |             }
 314 |         }
 315 | 
 316 |         // Apply status filter
 317 |         if let targetStatus = statusFilter.gameStatus {
 318 |             games = games.filter { $0.status == targetStatus }
 319 |         }
 320 | 
 321 |         // Apply sorting
 322 |         switch sortOption {
 323 |         case .orderIndex:
 324 |             games.sort { $0.orderIndex < $1.orderIndex }
 325 |         case .alphabetical:
 326 |             games.sort { eg1, eg2 in
 327 |                 let n1 = templates.first(where: { $0.id == eg1.gameTemplateId })?.name ?? ""
 328 |                 let n2 = templates.first(where: { $0.id == eg2.gameTemplateId })?.name ?? ""
 329 |                 return n1 < n2
 330 |             }
 331 |         case .reverseAlphabetical:
 332 |             games.sort { eg1, eg2 in
 333 |                 let n1 = templates.first(where: { $0.id == eg1.gameTemplateId })?.name ?? ""
 334 |                 let n2 = templates.first(where: { $0.id == eg2.gameTemplateId })?.name ?? ""
 335 |                 return n1 > n2
 336 |             }
 337 |         case .status:
 338 |             games.sort { $0.statusRaw < $1.statusRaw }
 339 |         }
 340 | 
 341 |         return games
 342 |     }
 343 | 
 344 |     // MARK: - Lifecycle UI
 345 | 
 346 |     private var lifecycleButton: some View {
 347 |         Menu {
 348 |             Button("Start") {
 349 |                 do { try engine.startEvent(event) } catch { present(error) }
 350 |             }
 351 |             Button("Pause") {
 352 |                 do { try engine.pauseEvent(event) } catch { present(error) }
 353 |             }
 354 |             Button("Resume") {
 355 |                 do { try engine.resumeEvent(event) } catch { present(error) }
 356 |             }
 357 |             Button("Complete") {
 358 |                 do {
 359 |                     event.status = .completed
 360 |                     event.currentEventGameId = nil
 361 |                     try context.save()
 362 |                 } catch {
 363 |                     present(error)
 364 |                 }
 365 |             }
 366 |             
 367 |             Divider()
 368 |             
 369 |             Button {
 370 |                 showEventStats = true
 371 |             } label: {
 372 |                 Label("View Stats", systemImage: "chart.bar.fill")
 373 |             }
 374 |             Button {
 375 |                 showPlayers = true
 376 |             } label: {
 377 |                 Label("Manage Participants", systemImage: "person.3")
 378 |             }
 379 |         } label: {
 380 |             Text("Event")
 381 |                 .foregroundColor(themeManager.text)
 382 |         }
 383 |     }
 384 | 
 385 |     private func gameName(for eg: EventGame) -> String {
 386 |         templates.first(where: { $0.id == eg.gameTemplateId })?.name ?? "Unknown"
 387 |     }
 388 | 
 389 |     private func gameRow(for eg: EventGame) -> some View {
 390 |         let t = templates.first(where: { $0.id == eg.gameTemplateId })
 391 |         let name = t?.name ?? "Unknown Game"
 392 | 
 393 |         let teamCount = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 394 |         let playersPerTeam = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 395 | 
 396 |         let group = t?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 397 |         let groupText = (group?.isEmpty == false) ? group! : nil
 398 | 
 399 |         let subtitleBits = [
 400 |             groupText,
 401 |             "Teams: \(teamCount) × \(playersPerTeam)",
 402 |             "Status: \(eg.statusRaw.capitalized)"
 403 |         ].compactMap { $0 }
 404 | 
 405 |         return VStack(alignment: .leading, spacing: 3) {
 406 |             Text(name).font(.body)
 407 |             Text(subtitleBits.joined(separator: " • "))
 408 |                 .font(.footnote)
 409 |                 .foregroundStyle(.secondary)
 410 |         }
 411 |     }
 412 | 
 413 |     // MARK: - Mutations
 414 | 
 415 |     private func deleteEventGames(at offsets: IndexSet) {
 416 |         for index in offsets {
 417 |             let eg = filteredAndSortedGames[index]
 418 |             context.delete(eg)
 419 |             if let i = event.eventGames.firstIndex(where: { $0.id == eg.id }) {
 420 |                 event.eventGames.remove(at: i)
 421 |             }
 422 |         }
 423 |         try? context.save()
 424 |     }
 425 | 
 426 |     private func moveEventGames(from source: IndexSet, to destination: Int) {
 427 |         // Move within the underlying array using the view's ordering
 428 |         var underlying = filteredAndSortedGames
 429 |         underlying.move(fromOffsets: source, toOffset: destination)
 430 | 
 431 |         // Re-apply orderIndex according to new ordering
 432 |         for (i, eg) in underlying.enumerated() {
 433 |             eg.orderIndex = i
 434 |         }
 435 | 
 436 |         // Also update event.eventGames to keep a consistent ordering
 437 |         event.eventGames = underlying
 438 | 
 439 |         try? context.save()
 440 |     }
 441 | 
 442 |     private func present(_ error: Error) {
 443 |         message = error.localizedDescription
 444 |         showMessage = true
 445 |     }
 446 | }
 447 | 
 448 | // MARK: - Missing Screens (Minimal Implementations)
 449 | // These are intentionally simple so the app compiles.
 450 | // You can enhance them later without blocking builds.
 451 | 
 452 | private struct AddEventSheet: View {
 453 |     @Environment(\.dismiss) private var dismiss
 454 |     @Environment(\.modelContext) private var context
 455 |     @EnvironmentObject var themeManager: ThemeManager
 456 | 
 457 |     @State private var name: String = ""
 458 | 
 459 |     var body: some View {
 460 |         NavigationStack {
 461 |             Form {
 462 |                 Section("Event name") {
 463 |                     TextField("Christmas Party", text: $name)
 464 |                 }
 465 |             }
 466 |             .navigationTitle("New Event")
 467 |             .toolbar {
 468 |                 ToolbarItem(placement: .topBarLeading) {
 469 |                     Button("Cancel") { dismiss() }
 470 |                         .foregroundColor(themeManager.primary)
 471 |                 }
 472 |                 ToolbarItem(placement: .topBarTrailing) {
 473 |                     Button("Save") { save() }
 474 |                         .foregroundColor(themeManager.primary)
 475 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 476 |                 }
 477 |             }
 478 |         }
 479 |     }
 480 | 
 481 |     private func save() {
 482 |         let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
 483 |         guard !trimmed.isEmpty else { return }
 484 | 
 485 |         // Your RunGameView preview proves Event(name:) exists.
 486 |         let event = Event(name: trimmed)
 487 |         context.insert(event)
 488 |         try? context.save()
 489 |         dismiss()
 490 |     }
 491 | }
 492 | 
 493 | private struct ParticipantPickerSheet: View {
 494 |     @Environment(\.dismiss) private var dismiss
 495 |     @Environment(\.modelContext) private var context
 496 |     @EnvironmentObject var themeManager: ThemeManager
 497 | 
 498 |     let event: Event
 499 | 
 500 |     @Query(sort: \Person.displayName)
 501 |     private var people: [Person]
 502 | 
 503 |     @State private var selected: Set<UUID> = []
 504 | 
 505 |     var body: some View {
 506 |         NavigationStack {
 507 |             List {
 508 |                 ForEach(people.filter { $0.isActive }) { person in
 509 |                     Button {
 510 |                         toggle(person.id)
 511 |                     } label: {
 512 |                         HStack {
 513 |                             Text(person.displayName)
 514 |                             Spacer()
 515 |                             if selected.contains(person.id) {
 516 |                                 Image(systemName: "checkmark")
 517 |                                     .foregroundColor(themeManager.primary)
 518 |                             }
 519 |                         }
 520 |                     }
 521 |                 }
 522 |             }
 523 |             .navigationTitle("Participants")
 524 |             .toolbar {
 525 |                 ToolbarItem(placement: .topBarLeading) {
 526 |                     Button("Cancel") { dismiss() }
 527 |                         .foregroundColor(themeManager.primary)
 528 |                 }
 529 |                 ToolbarItem(placement: .topBarTrailing) {
 530 |                     Button("Done") { commit() }
 531 |                         .foregroundColor(themeManager.primary)
 532 |                 }
 533 |             }
 534 |             .onAppear {
 535 |                 selected = Set(event.participantIds)
 536 |             }
 537 |         }
 538 |     }
 539 | 
 540 |     private func toggle(_ id: UUID) {
 541 |         if selected.contains(id) {
 542 |             selected.remove(id)
 543 |         } else {
 544 |             selected.insert(id)
 545 |         }
 546 |     }
 547 | 
 548 |     private func commit() {
 549 |         event.participantIds = Array(selected)
 550 |         try? context.save()
 551 |         dismiss()
 552 |     }
 553 | }
 554 | 
 555 | private struct AddGamesSheet: View {
 556 |     @Environment(\.dismiss) private var dismiss
 557 |     @EnvironmentObject var themeManager: ThemeManager
 558 | 
 559 |     let event: Event
 560 |     let templates: [GameTemplate]
 561 | 
 562 |     var body: some View {
 563 |         NavigationStack {
 564 |             List {
 565 |                 Section {
 566 |                     Text("This screen is a minimal placeholder so the project builds.")
 567 |                         .foregroundStyle(.secondary)
 568 |                     Text("Next step is wiring this to create EventGame records from selected GameTemplates.")
 569 |                         .foregroundStyle(.secondary)
 570 |                 }
 571 | 
 572 |                 Section("Templates in catalog") {
 573 |                     ForEach(templates) { t in
 574 |                         VStack(alignment: .leading, spacing: 3) {
 575 |                             Text(t.name).font(.headline)
 576 |                             if let group = t.groupName, !group.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
 577 |                                 Text(group).font(.footnote).foregroundStyle(.secondary)
 578 |                             }
 579 |                         }
 580 |                     }
 581 |                 }
 582 |             }
 583 |             .navigationTitle("Add Games")
 584 |             .toolbar {
 585 |                 ToolbarItem(placement: .topBarLeading) {
 586 |                     Button("Close") { dismiss() }
 587 |                         .foregroundColor(themeManager.primary)
 588 |                 }
 589 |             }
 590 |         }
 591 |     }
 592 | }
 593 | 
 594 | private struct EventGameDetailView: View {
 595 |     @EnvironmentObject var themeManager: ThemeManager
 596 |     
 597 |     let event: Event
 598 |     let eventGame: EventGame
 599 | 
 600 |     var body: some View {
 601 |         Form {
 602 |             Section("Game") {
 603 |                 Text("This is a placeholder detail view.")
 604 |                     .foregroundStyle(.secondary)
 605 |             }
 606 |             Section("IDs") {
 607 |                 Text("EventGame ID: \(eventGame.id.uuidString)")
 608 |             }
 609 |         }
 610 |         .navigationTitle("Game Detail")
 611 |     }
 612 | }
 613 | 
 614 | 
 615 | #Preview {
 616 |     EventsListView()
 617 |         .modelContainer(for: [Event.self, Person.self, GameTemplate.self])
 618 |         .environmentObject(ThemeManager())
 619 | }


END FILE: ./Christmas Games/EventsListView.swift


