################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift
################################################################################
   1 | //
   2 | //  Christmas_GamesUITestsLaunchTests.swift
   3 | //  Christmas GamesUITests
   4 | //
   5 | //  Created by Dean Roger Harmon on 12/16/25.
   6 | //
   7 | 
   8 | import XCTest
   9 | 
  10 | final class Christmas_GamesUITestsLaunchTests: XCTestCase {
  11 | 
  12 |     override class var runsForEachTargetApplicationUIConfiguration: Bool {
  13 |         true
  14 |     }
  15 | 
  16 |     override func setUpWithError() throws {
  17 |         continueAfterFailure = false
  18 |     }
  19 | 
  20 |     @MainActor
  21 |     func testLaunch() throws {
  22 |         let app = XCUIApplication()
  23 |         app.launch()
  24 | 
  25 |         // Insert steps here to perform after app launch but before taking a screenshot,
  26 |         // such as logging into a test account or navigating somewhere in the app
  27 | 
  28 |         let attachment = XCTAttachment(screenshot: app.screenshot())
  29 |         attachment.name = "Launch Screen"
  30 |         attachment.lifetime = .keepAlways
  31 |         add(attachment)
  32 |     }
  33 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITestsLaunchTests.swift


################################################################################
START FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift
################################################################################
   1 | import XCTest
   2 | 
   3 | final class MainMenuUITests: XCTestCase {
   4 |     
   5 |     func testNavigateToGameCatalog() throws {
   6 |         let app = XCUIApplication()
   7 |         app.launch()
   8 |         
   9 |         // Tap Game Catalog button
  10 |         app.buttons["Game Catalog"].tap()
  11 |         
  12 |         // Verify we're on the Game Catalog screen
  13 |         XCTAssertTrue(app.navigationBars["Game Catalog"].exists)
  14 |     }
  15 |     
  16 |     func testCreateNewEvent() throws {
  17 |         let app = XCUIApplication()
  18 |         app.launch()
  19 |         
  20 |         // Navigate to Events
  21 |         let eventsButton = app.buttons["Events"]
  22 |         XCTAssertTrue(eventsButton.exists)
  23 |         eventsButton.tap()
  24 |         
  25 |         // Tap Add Event
  26 |         app.buttons["Add Event"].tap()
  27 |         
  28 |         // Enter event name
  29 |         let eventNameField = app.textFields["Event Name"]
  30 |         eventNameField.tap()
  31 |         eventNameField.typeText("Test Event 2025")
  32 |         
  33 |         // Save
  34 |         app.buttons["Save"].tap()
  35 |         
  36 |         // Verify event appears in list
  37 |         XCTAssertTrue(app.staticTexts["Test Event 2025"].exists)
  38 |     }
  39 | }


END FILE: ./Christmas GamesUITests/Christmas_GamesUITests.swift


################################################################################
START FILE: ./Christmas GamesTests/Christmas_GamesTests.swift
################################################################################
   1 | import XCTest
   2 | import SwiftData
   3 | @testable import Christmas_Games
   4 | 
   5 | final class EventEngineTests: XCTestCase {
   6 |     var context: ModelContext!
   7 |     var engine: EventEngine!
   8 |     
   9 |     @MainActor
  10 |     override func setUp() {
  11 |         super.setUp()
  12 |         // Create in-memory database for testing
  13 |         let config = ModelConfiguration(isStoredInMemoryOnly: true)
  14 |         let container = try! ModelContainer(
  15 |             for: Event.self, Person.self, GameTemplate.self, EventGame.self, Round.self,
  16 |             configurations: config
  17 |         )
  18 |         context = container.mainContext
  19 |         engine = EventEngine(context: context)
  20 |     }
  21 |     
  22 |     @MainActor
  23 |     func testStartEvent_WithNoParticipants_ThrowsError() throws {
  24 |         // Given: an event with no participants
  25 |         let event = Event(name: "Test Event")
  26 |         let template = GameTemplate(
  27 |             externalId: "test",
  28 |             name: "Test Game",
  29 |             defaultTeamCount: 2,
  30 |             defaultPlayersPerTeam: 2,
  31 |             defaultRoundsPerGame: 1,
  32 |             defaultTeamType: .any
  33 |         )
  34 |         context.insert(event)
  35 |         context.insert(template)
  36 |         
  37 |         let eventGame = EventGame(
  38 |             event: event,
  39 |             gameTemplateId: template.id,
  40 |             orderIndex: 0
  41 |         )
  42 |         context.insert(eventGame)
  43 |         event.eventGames.append(eventGame)
  44 |         
  45 |         // When/Then: starting should throw noParticipants error
  46 |         XCTAssertThrowsError(try engine.startEvent(event)) { error in
  47 |             XCTAssertEqual(error as? EventEngine.StartError, .noParticipants)
  48 |         }
  49 |     }
  50 |     
  51 |     @MainActor
  52 |     func testStartEvent_CreatesActiveRound() throws {
  53 |         // Given: an event with participants and a game
  54 |         let event = Event(name: "Test Event")
  55 |         let person1 = Person(displayName: "Test Person 1")
  56 |         let person2 = Person(displayName: "Test Person 2")
  57 |         
  58 |         context.insert(event)
  59 |         context.insert(person1)
  60 |         context.insert(person2)
  61 |         
  62 |         event.participantIds = [person1.id, person2.id]
  63 |         
  64 |         let template = GameTemplate(
  65 |             externalId: "test",
  66 |             name: "Test Game",
  67 |             defaultTeamCount: 2,
  68 |             defaultPlayersPerTeam: 1,
  69 |             defaultRoundsPerGame: 1,
  70 |             defaultTeamType: .any
  71 |         )
  72 |         context.insert(template)
  73 |         
  74 |         let eventGame = EventGame(
  75 |             event: event,
  76 |             gameTemplateId: template.id,
  77 |             orderIndex: 0
  78 |         )
  79 |         context.insert(eventGame)
  80 |         event.eventGames.append(eventGame)
  81 |         
  82 |         // When: starting the event
  83 |         try engine.startEvent(event)
  84 |         
  85 |         // Then: event should be active with a current game and an active round
  86 |         XCTAssertEqual(event.status, .active)
  87 |         XCTAssertNotNil(event.currentEventGameId)
  88 |         XCTAssertEqual(eventGame.status, .inProgress)
  89 |         XCTAssertEqual(eventGame.rounds.count, 1)
  90 |         
  91 |         let round = eventGame.rounds.first!
  92 |         XCTAssertNil(round.completedAt, "Round should not be completed")
  93 |     }
  94 |     
  95 |     @MainActor
  96 |     func testFinalizeRound_AssignsCorrectPlacements() throws {
  97 |         // Given: a round with teams
  98 |         let event = Event(name: "Test Event")
  99 |         let person1 = Person(displayName: "Person 1")
 100 |         let person2 = Person(displayName: "Person 2")
 101 |         
 102 |         context.insert(event)
 103 |         context.insert(person1)
 104 |         context.insert(person2)
 105 |         
 106 |         let template = GameTemplate(
 107 |             externalId: "test",
 108 |             name: "Test Game",
 109 |             defaultTeamCount: 2,
 110 |             defaultPlayersPerTeam: 1,
 111 |             defaultRoundsPerGame: 1,
 112 |             defaultTeamType: .any
 113 |         )
 114 |         context.insert(template)
 115 |         
 116 |         let eventGame = EventGame(
 117 |             event: event,
 118 |             gameTemplateId: template.id,
 119 |             orderIndex: 0
 120 |         )
 121 |         context.insert(eventGame)
 122 |         
 123 |         let round = Round(eventGame: eventGame, roundIndex: 0)
 124 |         context.insert(round)
 125 |         eventGame.rounds.append(round)
 126 |         
 127 |         let team1 = RoundTeam(memberPersonIds: [person1.id])
 128 |         let team2 = RoundTeam(memberPersonIds: [person2.id])
 129 |         round.teams = [team1, team2]
 130 |         
 131 |         // When: finalizing round with team1 as winner
 132 |         try engine.finalizeRound(round, winnerTeamId: team1.id)
 133 |         
 134 |         // Then: placements should be assigned correctly
 135 |         XCTAssertNotNil(round.completedAt)
 136 |         XCTAssertEqual(round.placements[person1.id], 1, "Winner should get 1st place")
 137 |         XCTAssertEqual(round.placements[person2.id], 2, "Loser should get 2nd place")
 138 |     }
 139 |     
 140 |     @MainActor
 141 |     func testResetEvent_ClearsAllGamesAndRounds() throws {
 142 |         // Given: an event with completed games and rounds
 143 |         let event = Event(name: "Test Event", status: .completed)
 144 |         context.insert(event)
 145 |         
 146 |         let template = GameTemplate(
 147 |             externalId: "test",
 148 |             name: "Test Game",
 149 |             defaultTeamCount: 2,
 150 |             defaultPlayersPerTeam: 1,
 151 |             defaultRoundsPerGame: 1,
 152 |             defaultTeamType: .any
 153 |         )
 154 |         context.insert(template)
 155 |         
 156 |         let eventGame = EventGame(
 157 |             event: event,
 158 |             gameTemplateId: template.id,
 159 |             orderIndex: 0,
 160 |             status: .completed
 161 |         )
 162 |         context.insert(eventGame)
 163 |         event.eventGames.append(eventGame)
 164 |         
 165 |         let round = Round(eventGame: eventGame, roundIndex: 0, completedAt: Date())
 166 |         context.insert(round)
 167 |         eventGame.rounds.append(round)
 168 |         
 169 |         // When: resetting the event
 170 |         try engine.resetEvent(event)
 171 |         
 172 |         // Then: event should be reset
 173 |         XCTAssertEqual(event.status, .available)
 174 |         XCTAssertNil(event.currentEventGameId)
 175 |         XCTAssertEqual(eventGame.status, .notStarted)
 176 |         XCTAssertTrue(eventGame.rounds.isEmpty, "All rounds should be deleted")
 177 |     }
 178 | }


END FILE: ./Christmas GamesTests/Christmas_GamesTests.swift


################################################################################
START FILE: ./Christmas Games/RunGameView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct RunGameView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @Environment(\.colorTheme) private var theme
   7 | 
   8 |     let event: Event
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var templates: [GameTemplate]
  15 |     
  16 |     @State private var message: String?
  17 |     @State private var showMessage = false
  18 | 
  19 |     @State private var showPickNextGame = false
  20 |     @State private var showResetConfirm = false
  21 | 
  22 | 
  23 |     @State private var showSwap = false
  24 |     @State private var swapOutgoing: UUID?
  25 | 
  26 |     @State private var showAfterRoundDialog = false
  27 |     @State private var showAfterGameDialog = false
  28 | 
  29 |     @State private var showWinnerPicker = false
  30 |     @State private var showSkipConfirmation = false
  31 | 
  32 |     var body: some View {
  33 |         ZStack {
  34 |             LinearGradient(
  35 |                 colors: [theme.gradientStart, theme.gradientEnd],
  36 |                 startPoint: .topLeading,
  37 |                 endPoint: .bottomTrailing
  38 |             )
  39 |             .ignoresSafeArea()
  40 | 
  41 |             VStack(spacing: 12) {
  42 |                 content
  43 |                 Spacer()
  44 |             }
  45 |             .padding()
  46 | 
  47 |             if event.status == .paused {
  48 |                 pausedOverlay
  49 |             }
  50 |         }
  51 |         .navigationTitle("Run Game")
  52 |         .toolbarBackground(.hidden, for: .navigationBar)
  53 |         .toolbarColorScheme(.dark, for: .navigationBar)
  54 |         .toolbar {
  55 |             ToolbarItemGroup(placement: .topBarTrailing) {
  56 |                 // Pause/Resume button
  57 |                 if event.status == .active {
  58 |                     Button("Pause") {
  59 |                         do { try engine.pauseEvent(event) }
  60 |                         catch { show(error) }
  61 |                     }
  62 |                 } else if event.status == .paused {
  63 |                     Button("Resume") {
  64 |                         do { try engine.resumeEvent(event) }
  65 |                         catch { show(error) }
  66 |                     }
  67 |                 }
  68 |                 
  69 |                 // Skip Game button (only when game is active and not paused)
  70 |                 if currentGame != nil && event.status == .active {
  71 |                     Button("Skip Game") { showSkipConfirmation = true }
  72 |                 }
  73 |                 
  74 |                 // Pick Game button
  75 |                 Button("Pick Game") { showPickNextGame = true }
  76 |                     .disabled(event.status == .paused)
  77 |             }
  78 |         }
  79 |         .sheet(isPresented: $showPickNextGame) {
  80 |             PickNextGameSheet(event: event) { selection, skipMode in
  81 |                 handlePick(selection: selection, skipMode: skipMode)
  82 |             }
  83 |         }
  84 |         .alert("Message", isPresented: $showMessage) {
  85 |             Button("OK", role: .cancel) { }
  86 |         } message: {
  87 |             Text(message ?? "Unknown error")
  88 |         }
  89 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
  90 |             Button("Reset Event", role: .destructive) {
  91 |                 do {
  92 |                     try EventEngine(context: context).resetEvent(event)
  93 |                 } catch {
  94 |                     show(error)
  95 |                 }
  96 |             }
  97 |             Button("Cancel", role: .cancel) { }
  98 |         } message: {
  99 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 100 |         }
 101 |     }
 102 | 
 103 |     private var pausedOverlay: some View {
 104 |         ZStack {
 105 |             Color.black.opacity(0.7)
 106 |                 .ignoresSafeArea()
 107 |             
 108 |             VStack(spacing: 20) {
 109 |                 Image(systemName: "pause.circle.fill")
 110 |                     .font(.system(size: 80))
 111 |                     .foregroundStyle(.white)
 112 |                 
 113 |                 Text("Event Paused")
 114 |                     .font(.title)
 115 |                     .fontWeight(.bold)
 116 |                     .foregroundStyle(.white)
 117 |                 
 118 |                 Button("Resume") {
 119 |                     do { try engine.resumeEvent(event) }
 120 |                     catch { show(error) }
 121 |                 }
 122 |                 .buttonStyle(.borderedProminent)
 123 |                 .controlSize(.large)
 124 |             }
 125 |         }
 126 |     }
 127 | 
 128 |     private var engine: EventEngine { EventEngine(context: context) }
 129 | 
 130 |     private var peopleById: [UUID: Person] {
 131 |         Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 132 |     }
 133 | 
 134 |     private var currentGame: EventGame? {
 135 |         guard let id = event.currentEventGameId else { return nil }
 136 |         return event.eventGames.first(where: { $0.id == id })
 137 |     }
 138 | 
 139 |     private var currentTemplate: GameTemplate? {
 140 |         guard let eg = currentGame else { return nil }
 141 |         return templates.first(where: { $0.id == eg.gameTemplateId })
 142 |     }
 143 | 
 144 |     private var currentRound: Round? {
 145 |         guard let eg = currentGame else { return nil }
 146 |         return eg.rounds
 147 |             .sorted(by: { $0.roundIndex > $1.roundIndex })
 148 |             .first(where: { $0.completedAt == nil })
 149 |     }
 150 | 
 151 |     private func teamLabel(_ index: Int) -> String {
 152 |         let scalar = UnicodeScalar(65 + index)!
 153 |         return String(Character(scalar))
 154 |     }
 155 | 
 156 |     private func teamNames(_ team: RoundTeam) -> String {
 157 |         team.memberPersonIds
 158 |             .compactMap { peopleById[$0]?.displayName }
 159 |             .joined(separator: ", ")
 160 |     }
 161 | 
 162 |     @ViewBuilder
 163 |     private var content: some View {
 164 |         if let eg = currentGame, let template = currentTemplate {
 165 |             header(template: template, eventGame: eg)
 166 |             if let round = currentRound {
 167 |                 roundCard(template: template, eventGame: eg, round: round)
 168 |             } else {
 169 |                 Text("No active round.").foregroundStyle(.secondary)
 170 |             }
 171 |         } else {
 172 |             emptyState
 173 |         }
 174 |     }
 175 | 
 176 |     private var emptyState: some View {
 177 |         VStack(spacing: 12) {
 178 |             Text("No game is currently running.")
 179 |                 .foregroundStyle(.secondary)
 180 | 
 181 |             Button("Start Event") {
 182 |                 do { try engine.startEvent(event) }
 183 |                 catch { show(error) }
 184 |             }
 185 |             .buttonStyle(.borderedProminent)
 186 |             .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty || event.status == .paused)
 187 |         }
 188 |     }
 189 | 
 190 |     private func header(template: GameTemplate, eventGame: EventGame) -> some View {
 191 |         VStack(alignment: .leading, spacing: 8) {
 192 |             Text(template.name).font(.title2).bold()
 193 | 
 194 |             if let playInstructions = (eventGame.overridePlayInstructions ?? template.playInstructions),
 195 |                !playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
 196 |                 Text(playInstructions)
 197 |                     .foregroundStyle(.secondary)
 198 |             }
 199 | 
 200 |             HStack {
 201 |                 Text("Status: \(eventGame.statusRaw.capitalized)")
 202 |                     .foregroundStyle(.secondary)
 203 |                 Spacer()
 204 |                 Text("Players: \(event.participantIds.count)")
 205 |                     .foregroundStyle(.secondary)
 206 |             }
 207 |         }
 208 |     }
 209 | 
 210 |     private func roundCard(template: GameTemplate, eventGame: EventGame, round: Round) -> some View {
 211 |         VStack(alignment: .leading, spacing: 12) {
 212 |             HStack {
 213 |                 Text("Round \(round.roundIndex + 1)").font(.headline)
 214 |                 Spacer()
 215 |                 if round.isLocked { Text("Locked").foregroundStyle(.secondary) }
 216 |             }
 217 | 
 218 |             if round.teams.isEmpty {
 219 |                 Button("Generate Teams") {
 220 |                     do { try engine.generateTeams(for: round) }
 221 |                     catch { show(error) }
 222 |                 }
 223 |                 .buttonStyle(.borderedProminent)
 224 |                 .disabled(event.status == .paused)
 225 |             } else {
 226 |                 teamsList(round: round)
 227 | 
 228 |                 if !round.isLocked {
 229 |                     actionRowUnlocked(round: round)
 230 |                 } else {
 231 |                     Button("Continue") { showAfterRoundDialog = true }
 232 |                         .buttonStyle(.borderedProminent)
 233 |                         .disabled(event.status == .paused)
 234 |                 }
 235 | 
 236 |                 previousRoundsCompact(eventGame: eventGame)
 237 |             }
 238 |         }
 239 |         .sheet(isPresented: $showSwap) {
 240 |             SwapPlayerSheet(
 241 |                 event: event,
 242 |                 currentRound: round,
 243 |                 people: people,
 244 |                 outgoing: swapOutgoing
 245 |             ) { incoming in
 246 |                 do {
 247 |                     if let out = swapOutgoing {
 248 |                         try engine.swapPlayer(in: round, from: out, to: incoming)
 249 |                     }
 250 |                 } catch { show(error) }
 251 |             }
 252 |         }
 253 |         .confirmationDialog("Play another round of this game?", isPresented: $showAfterRoundDialog, titleVisibility: .visible) {
 254 |             Button("Yes – New Round") {
 255 |                 do { _ = try engine.createNextRound(for: eventGame) }
 256 |                 catch { show(error) }
 257 |             }
 258 |             Button("No – Next Game") { showAfterGameDialog = true }
 259 |             Button("Cancel", role: .cancel) { }
 260 |         }
 261 |         .confirmationDialog("Next game", isPresented: $showAfterGameDialog, titleVisibility: .visible) {
 262 |             Button("Pick next game (random)") {
 263 |                 handlePickNextGameRandom(currentGame: eventGame)
 264 |             }
 265 |             Button("Choose from list") { showPickNextGame = true }
 266 |             Button("Cancel", role: .cancel) { }
 267 |         }
 268 |     }
 269 | 
 270 |     private func teamsList(round: Round) -> some View {
 271 |         VStack(alignment: .leading, spacing: 10) {
 272 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, team in
 273 |                 VStack(alignment: .leading, spacing: 6) {
 274 |                     Text("Team \(teamLabel(index))")
 275 |                         .font(.subheadline)
 276 |                         .bold()
 277 |                         .foregroundColor(teamColor(for: index))
 278 | 
 279 |                     ForEach(team.memberPersonIds, id: \.self) { pid in
 280 |                         HStack {
 281 |                             Text(peopleById[pid]?.displayName ?? "Unknown")
 282 |                             Spacer()
 283 |                             if !round.isLocked && event.status != .paused {
 284 |                                 Button("Swap") {
 285 |                                     swapOutgoing = pid
 286 |                                     showSwap = true
 287 |                                 }
 288 |                                 .buttonStyle(.bordered)
 289 |                             }
 290 |                         }
 291 |                     }
 292 |                 }
 293 |                 .padding(.vertical, 6)
 294 |             }
 295 |         }
 296 |     }
 297 |     
 298 |     private func teamColor(for index: Int) -> Color {
 299 |         let colors: [Color] = [.red, .green, .yellow, .blue, .orange, .purple]
 300 |         return index < colors.count ? colors[index] : .primary
 301 |     }
 302 | 
 303 |     private func actionRowUnlocked(round: Round) -> some View {
 304 |         HStack {
 305 |             Button("Regenerate") {
 306 |                 do { try engine.generateTeams(for: round) }
 307 |                 catch { show(error) }
 308 |             }
 309 |             .buttonStyle(.bordered)
 310 |             .disabled(event.status == .paused)
 311 | 
 312 |             Spacer()
 313 | 
 314 |             Button("Select Winner") {
 315 |                 showWinnerPicker = true
 316 |             }
 317 |             .buttonStyle(.borderedProminent)
 318 |             .disabled(round.teams.isEmpty || event.status == .paused)
 319 |         }
 320 |         .confirmationDialog("Select winner", isPresented: $showWinnerPicker, titleVisibility: .visible) {
 321 |             ForEach(Array(round.teams.enumerated()), id: \.element.id) { index, t in
 322 |                 Button("Team \(teamLabel(index)) – \(teamNames(t))") {
 323 |                     do {
 324 |                         try engine.finalizeRound(round, winnerTeamId: t.id)
 325 |                         showAfterRoundDialog = true
 326 |                     } catch { show(error) }
 327 |                 }
 328 |             }
 329 | 
 330 |             Button("Tie") {
 331 |                 do {
 332 |                     try engine.finalizeRound(round, winnerTeamId: nil)
 333 |                     showAfterRoundDialog = true
 334 |                 } catch { show(error) }
 335 |             }
 336 | 
 337 |             Button("Cancel", role: .cancel) { }
 338 |         }
 339 |     }
 340 | 
 341 |     private func previousRoundsCompact(eventGame: EventGame) -> some View {
 342 |         let completed = eventGame.rounds
 343 |             .sorted { $0.roundIndex > $1.roundIndex }
 344 |             .filter { $0.completedAt != nil }
 345 | 
 346 |         return Group {
 347 |             if !completed.isEmpty {
 348 |                 Divider()
 349 |                 Text("Previous Rounds").font(.subheadline).bold()
 350 |                 ForEach(completed.prefix(3)) { r in
 351 |                     Text(historyLine(r))
 352 |                         .font(.footnote)
 353 |                         .foregroundStyle(.secondary)
 354 |                 }
 355 |             }
 356 |         }
 357 |     }
 358 | 
 359 |     private func historyLine(_ round: Round) -> String {
 360 |         if round.resultType == .tie {
 361 |             return "Round \(round.roundIndex + 1): Tie"
 362 |         }
 363 |         if let winTeam = round.winningTeamId,
 364 |            let team = round.teams.first(where: { $0.id == winTeam }) {
 365 |             let names = team.memberPersonIds
 366 |                 .compactMap { peopleById[$0]?.displayName }
 367 |                 .joined(separator: ", ")
 368 |             return "Round \(round.roundIndex + 1): Winner – \(names)"
 369 |         }
 370 |         return "Round \(round.roundIndex + 1): Completed"
 371 |     }
 372 | 
 373 |     private func handlePickNextGameRandom(currentGame: EventGame) {
 374 |         do {
 375 |             try engine.completeGame(currentGame)
 376 |             
 377 |             if let next = try engine.pickNextGameRandom(event: event) {
 378 |                 try engine.start(event: event, eventGame: next)
 379 |                 
 380 |                 // Force view refresh by saving again
 381 |                 try context.save()
 382 |             } else {
 383 |                 event.status = .completed
 384 |                 try context.save()
 385 |             }
 386 |         } catch {
 387 |             show(error)
 388 |         }
 389 |     }
 390 | 
 391 |     private func handlePick(selection: EventGame, skipMode: PickNextGameSheet.SkipMode?) {
 392 |         do {
 393 |             if let skipMode {
 394 |                 if skipMode == .pushLater { try engine.pushGameToLater(selection) }
 395 |                 if skipMode == .remove { try engine.removeGameFromEvent(selection) }
 396 |                 return
 397 |             }
 398 | 
 399 |             if let cg = currentGame { try engine.completeGame(cg) }
 400 |             try engine.start(event: event, eventGame: selection)
 401 |             
 402 |             // Force view refresh
 403 |             try context.save()
 404 |         } catch {
 405 |             show(error)
 406 |         }
 407 |     }
 408 | 
 409 |     private func handleSkipGame() {
 410 |         guard let game = currentGame else { return }
 411 |         
 412 |         // Get current player IDs
 413 |         let playerIds: [UUID]
 414 |         if let round = currentRound, !round.teams.isEmpty {
 415 |             playerIds = round.teams.flatMap { $0.memberPersonIds }
 416 |         } else {
 417 |             playerIds = []
 418 |         }
 419 |         
 420 |         do {
 421 |             try engine.skipToNextGame(game, keepingPlayers: playerIds)
 422 |             
 423 |             // Force view refresh
 424 |             try context.save()
 425 |         } catch {
 426 |             show(error)
 427 |         }
 428 |     }
 429 | 
 430 |     private func show(_ error: Error) {
 431 |         message = error.localizedDescription
 432 |         showMessage = true
 433 |     }
 434 | }
 435 | 
 436 | // MARK: - Pick Next Game
 437 | 
 438 | struct PickNextGameSheet: View {
 439 |     enum SkipMode { case pushLater, remove }
 440 | 
 441 |     @Environment(\.dismiss) private var dismiss
 442 | 
 443 |     let event: Event
 444 |     let onPick: (EventGame, SkipMode?) -> Void
 445 | 
 446 |     @Query(sort: \GameTemplate.name)
 447 |     private var templates: [GameTemplate]
 448 | 
 449 |     var body: some View {
 450 |         NavigationStack {
 451 |             List {
 452 |                 Section("Eligible (not started)") {
 453 |                     ForEach(eligibleGames) { eg in
 454 |                         Button {
 455 |                             onPick(eg, nil)
 456 |                             dismiss()
 457 |                         } label: {
 458 |                             gameRow(for: eg)
 459 |                         }
 460 |                     }
 461 |                 }
 462 | 
 463 |                 Section("Skip options") {
 464 |                     ForEach(eligibleGames) { eg in
 465 |                         Menu {
 466 |                             Button("Push to later") {
 467 |                                 onPick(eg, .pushLater)
 468 |                                 dismiss()
 469 |                             }
 470 |                             Button("Remove from event", role: .destructive) {
 471 |                                 onPick(eg, .remove)
 472 |                                 dismiss()
 473 |                             }
 474 |                         } label: {
 475 |                             Text("Skip \(gameName(for: eg))")
 476 |                         }
 477 |                     }
 478 |                 }
 479 |             }
 480 |             .navigationTitle("Choose Next Game")
 481 |             .toolbar {
 482 |                 ToolbarItem(placement: .topBarLeading) {
 483 |                     Button("Close") { dismiss() }
 484 |                 }
 485 |             }
 486 |         }
 487 |     }
 488 | 
 489 |     private var eligibleGames: [EventGame] {
 490 |         event.eventGames
 491 |             .filter { $0.status == .notStarted }
 492 |             .sorted { $0.orderIndex < $1.orderIndex }
 493 |     }
 494 | 
 495 |     private func template(for eg: EventGame) -> GameTemplate? {
 496 |         templates.first(where: { $0.id == eg.gameTemplateId })
 497 |     }
 498 | 
 499 |     private func gameName(for eg: EventGame) -> String {
 500 |         template(for: eg)?.name ?? "Unknown Game"
 501 |     }
 502 | 
 503 |     private func gameRow(for eg: EventGame) -> some View {
 504 |         let t = template(for: eg)
 505 | 
 506 |         let name = t?.name ?? "Unknown Game"
 507 |         let group = t?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 508 |         let groupText = (group?.isEmpty == false) ? group! : nil
 509 | 
 510 |         let teamCount = eg.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 511 |         let playersPerTeam = eg.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 512 | 
 513 |         let teamSizeText = "Teams: \(teamCount) × \(playersPerTeam)"
 514 |         let subtitle = groupText != nil ? "\(groupText!) • \(teamSizeText)" : teamSizeText
 515 | 
 516 |         return VStack(alignment: .leading, spacing: 3) {
 517 |             Text(name)
 518 |                 .font(.body)
 519 | 
 520 |             Text(subtitle)
 521 |                 .font(.footnote)
 522 |                 .foregroundStyle(.secondary)
 523 |         }
 524 |     }
 525 | }
 526 | 
 527 | // MARK: - Swap Player
 528 | 
 529 | struct SwapPlayerSheet: View {
 530 |     @Environment(\.dismiss) private var dismiss
 531 | 
 532 |     let event: Event
 533 |     let currentRound: Round
 534 |     let people: [Person]
 535 |     let outgoing: UUID?
 536 | 
 537 |     let onSwap: (UUID) -> Void
 538 | 
 539 |     var body: some View {
 540 |         let inRound = Set(currentRound.teams.flatMap { $0.memberPersonIds })
 541 |         let bench = people.filter { event.participantIds.contains($0.id) && !inRound.contains($0.id) && $0.isActive }
 542 | 
 543 |         NavigationStack {
 544 |             List {
 545 |                 Section {
 546 |                     Text("Outgoing: \(name(outgoing))")
 547 |                         .foregroundStyle(.secondary)
 548 |                 }
 549 | 
 550 |                 Section("Choose replacement") {
 551 |                     ForEach(bench) { p in
 552 |                         Button(p.displayName) {
 553 |                             onSwap(p.id)
 554 |                             dismiss()
 555 |                         }
 556 |                     }
 557 |                 }
 558 |             }
 559 |             .navigationTitle("Swap Player")
 560 |             .toolbar {
 561 |                 ToolbarItem(placement: .topBarLeading) {
 562 |                     Button("Cancel") { dismiss() }
 563 |                 }
 564 |             }
 565 |         }
 566 |     }
 567 | 
 568 |     private func name(_ id: UUID?) -> String {
 569 |         guard let id else { return "None" }
 570 |         return people.first(where: { $0.id == id })?.displayName ?? "Unknown"
 571 |     }
 572 | }
 573 | 
 574 | #Preview {
 575 |     let config = ModelConfiguration(isStoredInMemoryOnly: true)
 576 |     let container = try! ModelContainer(for: Event.self, Person.self, GameTemplate.self, configurations: config)
 577 |     
 578 |     let event = Event(name: "Test Event")
 579 |     container.mainContext.insert(event)
 580 |     
 581 |     return NavigationStack {
 582 |         RunGameView(event: event)
 583 |     }
 584 |     .modelContainer(container)
 585 | }


END FILE: ./Christmas Games/RunGameView.swift


################################################################################
START FILE: ./Christmas Games/CreatePersonSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreatePersonSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var allPeople: [Person]
  10 | 
  11 |     @State private var displayName = ""
  12 |     @State private var sex = "M"
  13 |     @State private var weightCategory = "M"
  14 |     @State private var heightCategory = "M"
  15 |     @State private var spouseId: UUID?
  16 |     @State private var isActive = true
  17 | 
  18 |     var body: some View {
  19 |         NavigationStack {
  20 |             Form {
  21 |                 Section("Basic") {
  22 |                     TextField("Name", text: $displayName)
  23 |                 }
  24 | 
  25 |                 Section("Details") {
  26 |                     HStack {
  27 |                         Text("Gender:")
  28 |                         Spacer()
  29 |                         Picker("Gender", selection: $sex) {
  30 |                             Text("M").tag("M")
  31 |                             Text("F").tag("F")
  32 |                         }
  33 |                         .pickerStyle(.segmented)
  34 |                         .labelsHidden()
  35 |                         .frame(width: 120)
  36 |                     }
  37 | 
  38 |                     HStack {
  39 |                         Text("Weight:")
  40 |                         Spacer()
  41 |                         Picker("Weight", selection: $weightCategory) {
  42 |                             Text("S").tag("S")
  43 |                             Text("M").tag("M")
  44 |                             Text("L").tag("L")
  45 |                         }
  46 |                         .pickerStyle(.segmented)
  47 |                         .labelsHidden()
  48 |                         .frame(width: 120)
  49 |                     }
  50 | 
  51 |                     HStack {
  52 |                         Text("Height:")
  53 |                         Spacer()
  54 |                         Picker("Height", selection: $heightCategory) {
  55 |                             Text("S").tag("S")
  56 |                             Text("M").tag("M")
  57 |                             Text("L").tag("L")
  58 |                         }
  59 |                         .pickerStyle(.segmented)
  60 |                         .labelsHidden()
  61 |                         .frame(width: 120)
  62 |                     }
  63 |                 }
  64 | 
  65 |                 Section("Spouse (Optional)") {
  66 |                     Picker("Spouse", selection: $spouseId) {
  67 |                         Text("None").tag(nil as UUID?)
  68 |                         ForEach(allPeople.filter { $0.isActive }) { person in
  69 |                             Text(person.displayName).tag(person.id as UUID?)
  70 |                         }
  71 |                     }
  72 |                 }
  73 | 
  74 |                 Section {
  75 |                     Toggle("Active", isOn: $isActive)
  76 |                 }
  77 |             }
  78 |             .navigationTitle("Add Participant")
  79 |             .toolbar {
  80 |                 ToolbarItem(placement: .topBarLeading) {
  81 |                     Button("Cancel") { dismiss() }
  82 |                 }
  83 | 
  84 |                 ToolbarItemGroup(placement: .topBarTrailing) {
  85 |                     Button("Save & Add Another") { saveAndContinue() }
  86 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  87 |                     
  88 |                     Button("Done") { saveAndDismiss() }
  89 |                 }
  90 |             }
  91 |         }
  92 |     }
  93 | 
  94 |     private func saveAndContinue() {
  95 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
  96 |         guard !trimmedName.isEmpty else { return }
  97 | 
  98 |         let person = Person(
  99 |             displayName: trimmedName,
 100 |             sex: sex,
 101 |             spouseId: spouseId,
 102 |             isActive: isActive
 103 |         )
 104 |         person.weightCategory = weightCategory
 105 |         person.heightCategory = heightCategory
 106 | 
 107 |         context.insert(person)
 108 |         try? context.save()
 109 |         
 110 |         // Reset form for next entry
 111 |         displayName = ""
 112 |         sex = "M"
 113 |         weightCategory = "M"
 114 |         heightCategory = "M"
 115 |         spouseId = nil
 116 |         isActive = true
 117 |     }
 118 |     
 119 |     private func saveAndDismiss() {
 120 |         // Only save if there's a name entered
 121 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 122 |         if !trimmedName.isEmpty {
 123 |             let person = Person(
 124 |                 displayName: trimmedName,
 125 |                 sex: sex,
 126 |                 spouseId: spouseId,
 127 |                 isActive: isActive
 128 |             )
 129 |             person.weightCategory = weightCategory
 130 |             person.heightCategory = heightCategory
 131 | 
 132 |             context.insert(person)
 133 |             try? context.save()
 134 |         }
 135 |         
 136 |         dismiss()
 137 |     }
 138 | }
 139 | 
 140 | struct EditPersonSheet: View {
 141 |     @Environment(\.dismiss) private var dismiss
 142 |     @Environment(\.modelContext) private var context
 143 | 
 144 |     @Query(sort: \Person.displayName)
 145 |     private var allPeople: [Person]
 146 | 
 147 |     let person: Person
 148 | 
 149 |     @State private var displayName = ""
 150 |     @State private var sex = "M"
 151 |     @State private var weightCategory = "M"
 152 |     @State private var heightCategory = "M"
 153 |     @State private var spouseId: UUID?
 154 |     @State private var isActive = true
 155 | 
 156 |     var body: some View {
 157 |         NavigationStack {
 158 |             Form {
 159 |                 Section("Basic") {
 160 |                     TextField("Name", text: $displayName)
 161 |                 }
 162 | 
 163 |                 Section("Details") {
 164 |                     HStack {
 165 |                         Text("Gender:")
 166 |                         Spacer()
 167 |                         Picker("Gender", selection: $sex) {
 168 |                             Text("M").tag("M")
 169 |                             Text("F").tag("F")
 170 |                         }
 171 |                         .pickerStyle(.segmented)
 172 |                         .labelsHidden()
 173 |                         .frame(width: 120)
 174 |                     }
 175 | 
 176 |                     HStack {
 177 |                         Text("Weight:")
 178 |                         Spacer()
 179 |                         Picker("Weight", selection: $weightCategory) {
 180 |                             Text("S").tag("S")
 181 |                             Text("M").tag("M")
 182 |                             Text("L").tag("L")
 183 |                         }
 184 |                         .pickerStyle(.segmented)
 185 |                         .labelsHidden()
 186 |                         .frame(width: 120)
 187 |                     }
 188 | 
 189 |                     HStack {
 190 |                         Text("Height:")
 191 |                         Spacer()
 192 |                         Picker("Height", selection: $heightCategory) {
 193 |                             Text("S").tag("S")
 194 |                             Text("M").tag("M")
 195 |                             Text("L").tag("L")
 196 |                         }
 197 |                         .pickerStyle(.segmented)
 198 |                         .labelsHidden()
 199 |                         .frame(width: 120)
 200 |                     }
 201 |                 }
 202 | 
 203 |                 Section("Spouse (Optional)") {
 204 |                     Picker("Spouse", selection: $spouseId) {
 205 |                         Text("None").tag(nil as UUID?)
 206 |                         ForEach(allPeople.filter { $0.id != person.id && $0.isActive }) { p in
 207 |                             Text(p.displayName).tag(p.id as UUID?)
 208 |                         }
 209 |                     }
 210 |                 }
 211 | 
 212 |                 Section {
 213 |                     Toggle("Active", isOn: $isActive)
 214 |                 }
 215 |             }
 216 |             .navigationTitle("Edit Participant")
 217 |             .toolbar {
 218 |                 ToolbarItem(placement: .topBarLeading) {
 219 |                     Button("Cancel") { dismiss() }
 220 |                 }
 221 | 
 222 |                 ToolbarItem(placement: .topBarTrailing) {
 223 |                     Button("Save") { save() }
 224 |                         .disabled(displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 225 |                 }
 226 |             }
 227 |             .onAppear {
 228 |                 displayName = person.displayName
 229 |                 sex = person.sex ?? "M"
 230 |                 weightCategory = person.weightCategory ?? "M"
 231 |                 heightCategory = person.heightCategory ?? "M"
 232 |                 spouseId = person.spouseId
 233 |                 isActive = person.isActive
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func save() {
 239 |         let trimmedName = displayName.trimmingCharacters(in: .whitespacesAndNewlines)
 240 |         guard !trimmedName.isEmpty else { return }
 241 | 
 242 |         person.displayName = trimmedName
 243 |         person.sex = sex
 244 |         person.weightCategory = weightCategory
 245 |         person.heightCategory = heightCategory
 246 |         person.spouseId = spouseId
 247 |         person.isActive = isActive
 248 | 
 249 |         try? context.save()
 250 |         dismiss()
 251 |     }
 252 | }
 253 | 
 254 | #Preview {
 255 |     CreatePersonSheet()
 256 |         .modelContainer(for: [Person.self])
 257 | }


END FILE: ./Christmas Games/CreatePersonSheet.swift


################################################################################
START FILE: ./Christmas Games/MainMenuView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | /// Main Menu matching the PDF wireframe (vertical menu buttons).
   5 | /// Order (per wireframe): Events → Game Catalog → Participant Catalog → Start/Resume Event → Event Stats
   6 | struct MainMenuView: View {
   7 |     @Query(sort: \Event.createdAt, order: .reverse)
   8 |     private var events: [Event]
   9 | 
  10 |     @Query(sort: \Person.displayName)
  11 |     private var people: [Person]
  12 | 
  13 |     @Query(sort: \GameTemplate.name)
  14 |     private var games: [GameTemplate]
  15 |     
  16 |     @AppStorage("selectedTheme") private var selectedThemeRaw: String = ColorTheme.christmas.rawValue
  17 |     @State private var showThemePicker = false
  18 |     
  19 |     private var selectedTheme: ColorTheme {
  20 |         ColorTheme(rawValue: selectedThemeRaw) ?? .christmas
  21 |     }
  22 | 
  23 |     var body: some View {
  24 |         NavigationStack {
  25 |             ZStack {
  26 |                 // Themed gradient background
  27 |                 LinearGradient(
  28 |                     colors: [selectedTheme.gradientStart, selectedTheme.gradientEnd],
  29 |                     startPoint: .topLeading,
  30 |                     endPoint: .bottomTrailing
  31 |                 )
  32 |                 .ignoresSafeArea()
  33 |                 
  34 |                 VStack(spacing: 0) {
  35 |                     header
  36 | 
  37 |                     ScrollView {
  38 |                         VStack(spacing: 14) {
  39 |                             NavigationLink {
  40 |                                 EventsListView()
  41 |                             } label: {
  42 |                                 MenuRow(
  43 |                                     title: "Events",
  44 |                                     subtitle: "\(events.count) total",
  45 |                                     systemImage: "calendar"
  46 |                                 )
  47 |                             }
  48 | 
  49 |                             NavigationLink {
  50 |                                 GameCatalogView()
  51 |                             } label: {
  52 |                                 MenuRow(
  53 |                                     title: "Game Catalog",
  54 |                                     subtitle: "\(games.count) games",
  55 |                                     systemImage: "list.bullet.rectangle"
  56 |                                 )
  57 |                             }
  58 | 
  59 |                             NavigationLink {
  60 |                                 ParticipantCatalogView()
  61 |                             } label: {
  62 |                                 MenuRow(
  63 |                                     title: "Participant Catalog",
  64 |                                     subtitle: "\(people.count) participants",
  65 |                                     systemImage: "person.3"
  66 |                                 )
  67 |                             }
  68 | 
  69 |                             NavigationLink {
  70 |                                 EventStatsView()
  71 |                             } label: {
  72 |                                 MenuRow(
  73 |                                     title: "Event Stats",
  74 |                                     subtitle: "Results grid",
  75 |                                     systemImage: "chart.bar"
  76 |                                 )
  77 |                             }
  78 |                         }
  79 |                         .padding(16)
  80 |                     }
  81 |                 }
  82 |             }
  83 |             .toolbar {
  84 |                 ToolbarItem(placement: .topBarTrailing) {
  85 |                     Button {
  86 |                         showThemePicker = true
  87 |                     } label: {
  88 |                         Image(systemName: "paintpalette.fill")
  89 |                             .foregroundColor(.white)
  90 |                             .font(.title3)
  91 |                     }
  92 |                 }
  93 |             }
  94 |             .toolbarBackground(.hidden, for: .navigationBar)
  95 |             .sheet(isPresented: $showThemePicker) {
  96 |                 ThemePickerSheet(selectedTheme: $selectedThemeRaw)
  97 |             }
  98 |             .environment(\.colorTheme, selectedTheme)
  99 |         }
 100 |     }
 101 | 
 102 |     private var header: some View {
 103 |         VStack(spacing: 6) {
 104 |             Text("Harmon Family Games")
 105 |                 .font(.title2)
 106 |                 .fontWeight(.semibold)
 107 |                 .foregroundColor(.white)  // White text on colored background
 108 |         }
 109 |         .frame(maxWidth: .infinity)
 110 |         .padding(.top, 18)
 111 |         .padding(.bottom, 12)
 112 |     }
 113 | }
 114 | 
 115 | private struct MenuRow: View {
 116 |     let title: String
 117 |     let subtitle: String
 118 |     let systemImage: String
 119 | 
 120 |     var body: some View {
 121 |         HStack(spacing: 14) {
 122 |             Image(systemName: systemImage)
 123 |                 .font(.title3)
 124 |                 .frame(width: 28)
 125 |                 .foregroundColor(.primary)
 126 | 
 127 |             VStack(alignment: .leading, spacing: 2) {
 128 |                 Text(title)
 129 |                     .font(.headline)
 130 |                     .foregroundColor(.primary)
 131 |                 Text(subtitle)
 132 |                     .font(.footnote)
 133 |                     .foregroundStyle(.secondary)
 134 |             }
 135 | 
 136 |             Spacer()
 137 | 
 138 |             Image(systemName: "chevron.right")
 139 |                 .font(.footnote)
 140 |                 .foregroundStyle(.secondary)
 141 |         }
 142 |         .padding(.vertical, 14)
 143 |         .padding(.horizontal, 14)
 144 |         .frame(maxWidth: .infinity)
 145 |         .background(
 146 |             RoundedRectangle(cornerRadius: 14, style: .continuous)
 147 |                 .fill(Color(UIColor.systemBackground))  // White/dark background for cards
 148 |                 .shadow(color: .black.opacity(0.15), radius: 5, x: 0, y: 2)
 149 |         )
 150 |         .contentShape(Rectangle())
 151 |     }
 152 | }
 153 | 
 154 | // MARK: - Theme Picker Sheet
 155 | 
 156 | struct ThemePickerSheet: View {
 157 |     @Environment(\.dismiss) private var dismiss
 158 |     @Binding var selectedTheme: String
 159 |     
 160 |     var body: some View {
 161 |         NavigationStack {
 162 |             List {
 163 |                 ForEach(ColorTheme.allCases) { theme in
 164 |                     Button {
 165 |                         selectedTheme = theme.rawValue
 166 |                         dismiss()
 167 |                     } label: {
 168 |                         HStack(spacing: 16) {
 169 |                             // Theme preview
 170 |                             ZStack {
 171 |                                 LinearGradient(
 172 |                                     colors: [theme.gradientStart, theme.gradientEnd],
 173 |                                     startPoint: .topLeading,
 174 |                                     endPoint: .bottomTrailing
 175 |                                 )
 176 |                                 .frame(width: 60, height: 60)
 177 |                                 .cornerRadius(12)
 178 |                                 
 179 |                                 Text(theme.icon)
 180 |                                     .font(.title)
 181 |                             }
 182 |                             
 183 |                             VStack(alignment: .leading, spacing: 4) {
 184 |                                 Text(theme.rawValue)
 185 |                                     .font(.headline)
 186 |                                     .foregroundColor(.primary)
 187 |                                 
 188 |                                 // Team colors preview
 189 |                                 HStack(spacing: 4) {
 190 |                                     ForEach(0..<min(6, theme.teamColors.count), id: \.self) { index in
 191 |                                         Circle()
 192 |                                             .fill(theme.teamColors[index])
 193 |                                             .frame(width: 16, height: 16)
 194 |                                     }
 195 |                                 }
 196 |                             }
 197 |                             
 198 |                             Spacer()
 199 |                             
 200 |                             if selectedTheme == theme.rawValue {
 201 |                                 Image(systemName: "checkmark.circle.fill")
 202 |                                     .foregroundColor(.green)
 203 |                                     .font(.title2)
 204 |                             }
 205 |                         }
 206 |                         .padding(.vertical, 8)
 207 |                     }
 208 |                 }
 209 |             }
 210 |             .navigationTitle("Choose Theme")
 211 |             .navigationBarTitleDisplayMode(.inline)
 212 |             .toolbar {
 213 |                 ToolbarItem(placement: .topBarTrailing) {
 214 |                     Button("Done") { dismiss() }
 215 |                 }
 216 |             }
 217 |         }
 218 |     }
 219 | }


END FILE: ./Christmas Games/MainMenuView.swift


################################################################################
START FILE: ./Christmas Games/CSVImportPreviewSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CSVImportPreviewSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let csvData: Data
   9 |     let filename: String?
  10 | 
  11 |     private let maxPreviewRows = 25
  12 |     private let maxPreviewColumns = 12
  13 | 
  14 |     @State private var parseResult: ParseResult = .empty
  15 |     @State private var isImporting = false
  16 | 
  17 |     @State private var alertTitle = "Message"
  18 |     @State private var alertMessage: String?
  19 |     @State private var showAlert = false
  20 | 
  21 |     var body: some View {
  22 |         NavigationStack {
  23 |             Group {
  24 |                 if parseResult.rows.isEmpty {
  25 |                     ContentUnavailableView("No preview available", systemImage: "doc.text")
  26 |                 } else {
  27 |                     previewBody
  28 |                 }
  29 |             }
  30 |             .navigationTitle("CSV Preview")
  31 |             .navigationBarTitleDisplayMode(.inline)
  32 |             .toolbar {
  33 |                 ToolbarItem(placement: .topBarLeading) {
  34 |                     Button("Cancel") { dismiss() }
  35 |                         .disabled(isImporting)
  36 |                 }
  37 |                 ToolbarItem(placement: .topBarTrailing) {
  38 |                     Button(isImporting ? "Importing…" : "Import") {
  39 |                         importNow()
  40 |                     }
  41 |                     .disabled(isImporting)
  42 |                 }
  43 |             }
  44 |             .onAppear {
  45 |                 parseResult = CSVParser.parse(data: csvData, maxRows: maxPreviewRows, maxColumns: maxPreviewColumns)
  46 |                 if let w = parseResult.warning {
  47 |                     alertTitle = "Preview warning"
  48 |                     alertMessage = w
  49 |                     showAlert = true
  50 |                 }
  51 |             }
  52 |             .alert(alertTitle, isPresented: $showAlert) {
  53 |                 Button("OK", role: .cancel) { }
  54 |             } message: {
  55 |                 Text(alertMessage ?? "Unknown error")
  56 |             }
  57 |         }
  58 |     }
  59 | 
  60 |     private var previewBody: some View {
  61 |         List {
  62 |             Section("File") {
  63 |                 HStack {
  64 |                     Text("Name")
  65 |                     Spacer()
  66 |                     Text(filename ?? "CSV")
  67 |                         .foregroundStyle(.secondary)
  68 |                 }
  69 |                 HStack {
  70 |                     Text("Rows shown")
  71 |                     Spacer()
  72 |                     Text("\(max(0, parseResult.rows.count - (parseResult.hasHeader ? 1 : 0)))")
  73 |                         .foregroundStyle(.secondary)
  74 |                 }
  75 |                 HStack {
  76 |                     Text("Columns shown")
  77 |                     Spacer()
  78 |                     Text("\(parseResult.columnCount)")
  79 |                         .foregroundStyle(.secondary)
  80 |                 }
  81 |                 HStack {
  82 |                     Text("Header row")
  83 |                     Spacer()
  84 |                     Text(parseResult.hasHeader ? "Yes" : "No")
  85 |                         .foregroundStyle(.secondary)
  86 |                 }
  87 |             }
  88 | 
  89 |             if parseResult.hasHeader, let header = parseResult.rows.first {
  90 |                 Section("Headers") {
  91 |                     ForEach(Array(header.prefix(parseResult.columnCount)).indices, id: \.self) { idx in
  92 |                         Text(header[idx].isEmpty ? "(blank)" : header[idx])
  93 |                     }
  94 |                 }
  95 |             }
  96 | 
  97 |             Section("Preview") {
  98 |                 let startIndex = parseResult.hasHeader ? 1 : 0
  99 |                 let displayRows = Array(parseResult.rows.dropFirst(startIndex))
 100 | 
 101 |                 ForEach(displayRows.indices, id: \.self) { r in
 102 |                     VStack(alignment: .leading, spacing: 6) {
 103 |                         Text("Row \(r + 1)")
 104 |                             .font(.subheadline)
 105 |                             .bold()
 106 | 
 107 |                         let row = displayRows[r]
 108 |                         ForEach(0..<parseResult.columnCount, id: \.self) { c in
 109 |                             let value = c < row.count ? row[c] : ""
 110 |                             let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)
 111 |                             if !trimmed.isEmpty {
 112 |                                 Text(trimmed)
 113 |                                     .font(.footnote)
 114 |                                     .foregroundStyle(.secondary)
 115 |                                     .lineLimit(2)
 116 |                             }
 117 |                         }
 118 |                     }
 119 |                     .padding(.vertical, 4)
 120 |                 }
 121 |             }
 122 |         }
 123 |     }
 124 | 
 125 |     private func importNow() {
 126 |         isImporting = true
 127 |         defer { isImporting = false }
 128 | 
 129 |         do {
 130 |             let r = try GameCatalogCSVImporter.importCSV(context: context, csvData: csvData)
 131 |             alertTitle = "Import complete"
 132 |             alertMessage = "Imported/updated \(r.insertedOrUpdated). Skipped \(r.skipped). Removed \(r.removed)."
 133 |             showAlert = true
 134 |         } catch {
 135 |             alertTitle = "Import failed"
 136 |             alertMessage = error.localizedDescription
 137 |             showAlert = true
 138 |         }
 139 |     }
 140 | }
 141 | 
 142 | // MARK: - Lightweight CSV Parser (preview only)
 143 | 
 144 | private enum CSVParser {
 145 |     static func parse(data: Data, maxRows: Int, maxColumns: Int) -> ParseResult {
 146 |         guard let s = String(data: data, encoding: .utf8) ?? String(data: data, encoding: .isoLatin1) else {
 147 |             return .init(rows: [], columnCount: 0, hasHeader: false, warning: "Could not decode file as UTF-8/Latin1.")
 148 |         }
 149 | 
 150 |         let normalized = s.replacingOccurrences(of: "\r\n", with: "\n").replacingOccurrences(of: "\r", with: "\n")
 151 |         let lines = normalized.split(separator: "\n", omittingEmptySubsequences: true)
 152 | 
 153 |         var rows: [[String]] = []
 154 |         rows.reserveCapacity(min(lines.count, maxRows + 1))
 155 | 
 156 |         for line in lines.prefix(maxRows + 1) {
 157 |             rows.append(parseLine(String(line)))
 158 |         }
 159 | 
 160 |         let columnCount = min(maxColumns, rows.map { $0.count }.max() ?? 0)
 161 |         let hasHeader = inferHeader(rows.first)
 162 | 
 163 |         var warning: String? = nil
 164 |         if columnCount == 0 {
 165 |             warning = "No columns detected. Check delimiter/format."
 166 |         } else if lines.count > maxRows + 1 {
 167 |             warning = "Preview is limited to the first \(maxRows) data rows."
 168 |         }
 169 | 
 170 |         return .init(rows: rows, columnCount: columnCount, hasHeader: hasHeader, warning: warning)
 171 |     }
 172 | 
 173 |     private static func parseLine(_ line: String) -> [String] {
 174 |         var result: [String] = []
 175 |         var current = ""
 176 |         var inQuotes = false
 177 |         var i = line.startIndex
 178 | 
 179 |         while i < line.endIndex {
 180 |             let ch = line[i]
 181 | 
 182 |             if ch == "\"" {
 183 |                 let next = line.index(after: i)
 184 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 185 |                     current.append("\"")
 186 |                     i = line.index(after: next)
 187 |                     continue
 188 |                 } else {
 189 |                     inQuotes.toggle()
 190 |                     i = line.index(after: i)
 191 |                     continue
 192 |                 }
 193 |             }
 194 | 
 195 |             if ch == "," && !inQuotes {
 196 |                 result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 197 |                 current = ""
 198 |                 i = line.index(after: i)
 199 |                 continue
 200 |             }
 201 | 
 202 |             current.append(ch)
 203 |             i = line.index(after: i)
 204 |         }
 205 | 
 206 |         result.append(current.trimmingCharacters(in: .whitespacesAndNewlines))
 207 |         return result
 208 |     }
 209 | 
 210 |     private static func inferHeader(_ firstRow: [String]?) -> Bool {
 211 |         guard let row = firstRow, !row.isEmpty else { return false }
 212 |         let sample = row.prefix(10)
 213 |         let nonEmpty = sample.filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
 214 |         guard !nonEmpty.isEmpty else { return false }
 215 | 
 216 |         let nonNumericCount = nonEmpty.filter { Double($0) == nil }.count
 217 |         return Double(nonNumericCount) / Double(nonEmpty.count) >= 0.7
 218 |     }
 219 | }
 220 | 
 221 | private struct ParseResult {
 222 |     let rows: [[String]]
 223 |     let columnCount: Int
 224 |     let hasHeader: Bool
 225 |     let warning: String?
 226 | 
 227 |     static let empty = ParseResult(rows: [], columnCount: 0, hasHeader: false, warning: nil)
 228 | }


END FILE: ./Christmas Games/CSVImportPreviewSheet.swift


################################################################################
START FILE: ./Christmas Games/FairnessEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | final class FairnessEngine {
   5 | 
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     func generateTeams(for round: Round, in event: Event) throws -> [RoundTeam] {
  13 | 
  14 |         guard let eventGame = round.eventGame else {
  15 |             throw FairnessError.missingEventGame
  16 |         }
  17 | 
  18 |         let settings = try effectiveSettings(for: eventGame)
  19 | 
  20 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  21 |         let required = settings.teamCount * settings.playersPerTeam
  22 | 
  23 |         guard eligiblePeople.count >= required else {
  24 |             throw FairnessError.notEnoughPlayers(required: required, available: eligiblePeople.count)
  25 |         }
  26 | 
  27 |         // Detect if this is a regeneration (teams already exist)
  28 |         let currentPlayerIds = Set(round.teams.flatMap { $0.memberPersonIds })
  29 |         let isRegeneration = !currentPlayerIds.isEmpty
  30 | 
  31 |         // Choose participants for this round based on "equal playing time"
  32 |         // If regenerating, try to exclude current players to force rotation
  33 |         let chosen = chooseParticipants(
  34 |             eligible: eligiblePeople,
  35 |             required: required,
  36 |             event: event,
  37 |             excluding: isRegeneration ? currentPlayerIds : []
  38 |         )
  39 | 
  40 |         if settings.teamType == .couplesOnly {
  41 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
  42 |         }
  43 | 
  44 |         // Generate candidate partitions and pick best by score
  45 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
  46 | 
  47 |         let candidates = 600
  48 |         var best: [RoundTeam] = []
  49 |         var bestScore = Double.greatestFiniteMagnitude
  50 | 
  51 |         for _ in 0..<candidates {
  52 |             let shuffled = chosen.shuffled().map { $0.id }
  53 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
  54 | 
  55 |             let score = scoreTeams(
  56 |                 teams: teams,
  57 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
  58 |                 historySignatures: historySignatures,
  59 |                 allowSpousesSameTeam: false
  60 |             )
  61 | 
  62 |             if score < bestScore {
  63 |                 bestScore = score
  64 |                 best = teams
  65 |                 if score == 0 { break }
  66 |             }
  67 |         }
  68 | 
  69 |         return best
  70 |     }
  71 | 
  72 |     /// Generate teams with a preferred set of players (used for skipping games)
  73 |     func generateTeamsWithPreferredPlayers(
  74 |         for round: Round,
  75 |         in event: Event,
  76 |         preferredPlayers: [UUID]
  77 |     ) throws -> [RoundTeam] {
  78 | 
  79 |         guard let eventGame = round.eventGame else {
  80 |             throw FairnessError.missingEventGame
  81 |         }
  82 | 
  83 |         let settings = try effectiveSettings(for: eventGame)
  84 |         let required = settings.teamCount * settings.playersPerTeam
  85 | 
  86 |         let eligiblePeople = try fetchEligiblePeople(for: event)
  87 |         let eligibleIds = Set(eligiblePeople.map { $0.id })
  88 | 
  89 |         // Filter preferred players to only those who are eligible
  90 |         let validPreferred = preferredPlayers.filter { eligibleIds.contains($0) }
  91 | 
  92 |         // Adjust player count if needed
  93 |         let chosen: [Person]
  94 |         if validPreferred.count == required {
  95 |             // Perfect match - use as-is
  96 |             chosen = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
  97 |         } else if validPreferred.count < required {
  98 |             // Need more players - add from bench by fairness
  99 |             let playedCounts = roundsPlayedCounts(event: event)
 100 |             let benchPlayers = eligiblePeople.filter { !validPreferred.contains($0.id) }
 101 |             let additionalNeeded = required - validPreferred.count
 102 | 
 103 |             let additional = benchPlayers
 104 |                 .sorted {
 105 |                     let a = playedCounts[$0.id, default: 0]
 106 |                     let b = playedCounts[$1.id, default: 0]
 107 |                     if a != b { return a < b }
 108 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 109 |                 }
 110 |                 .prefix(additionalNeeded)
 111 | 
 112 |             let preferredPeople = validPreferred.compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 113 |             chosen = preferredPeople + additional
 114 |         } else {
 115 |             // Too many players - remove by most playing time
 116 |             let playedCounts = roundsPlayedCounts(event: event)
 117 |             chosen = validPreferred
 118 |                 .compactMap { id in eligiblePeople.first(where: { $0.id == id }) }
 119 |                 .sorted {
 120 |                     let a = playedCounts[$0.id, default: 0]
 121 |                     let b = playedCounts[$1.id, default: 0]
 122 |                     if a != b { return a < b } // Keep those with LESS playing time
 123 |                     return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 124 |                 }
 125 |                 .prefix(required)
 126 |                 .map { $0 }
 127 |         }
 128 | 
 129 |         guard chosen.count == required else {
 130 |             throw FairnessError.notEnoughPlayers(required: required, available: chosen.count)
 131 |         }
 132 | 
 133 |         if settings.teamType == .couplesOnly {
 134 |             return try generateCouplesOnlyTeams(teamCount: settings.teamCount, eligible: chosen)
 135 |         }
 136 | 
 137 |         // Generate candidate partitions and pick best by score
 138 |         let historySignatures = matchupSignaturesForGame(eventGame: eventGame)
 139 | 
 140 |         let candidates = 600
 141 |         var best: [RoundTeam] = []
 142 |         var bestScore = Double.greatestFiniteMagnitude
 143 | 
 144 |         for _ in 0..<candidates {
 145 |             let shuffled = chosen.shuffled().map { $0.id }
 146 |             let teams = partition(ids: shuffled, teamCount: settings.teamCount, playersPerTeam: settings.playersPerTeam)
 147 | 
 148 |             let score = scoreTeams(
 149 |                 teams: teams,
 150 |                 peopleById: Dictionary(uniqueKeysWithValues: chosen.map { ($0.id, $0) }),
 151 |                 historySignatures: historySignatures,
 152 |                 allowSpousesSameTeam: false
 153 |             )
 154 | 
 155 |             if score < bestScore {
 156 |                 bestScore = score
 157 |                 best = teams
 158 |                 if score == 0 { break }
 159 |             }
 160 |         }
 161 | 
 162 |         return best
 163 |     }
 164 | 
 165 |     // MARK: - Settings
 166 | 
 167 |     private struct Settings {
 168 |         let teamCount: Int
 169 |         let playersPerTeam: Int
 170 |         let teamType: TeamType
 171 |     }
 172 | 
 173 |     private func effectiveSettings(for eventGame: EventGame) throws -> Settings {
 174 |         let t = try fetchTemplate(id: eventGame.gameTemplateId)
 175 | 
 176 |         let teamCount = eventGame.overrideTeamCount ?? t?.defaultTeamCount ?? 2
 177 |         let playersPerTeam = eventGame.overridePlayersPerTeam ?? t?.defaultPlayersPerTeam ?? 2
 178 |         let teamType = eventGame.overrideTeamType ?? t?.defaultTeamType ?? .any
 179 | 
 180 |         return Settings(teamCount: max(1, teamCount), playersPerTeam: max(1, playersPerTeam), teamType: teamType)
 181 |     }
 182 | 
 183 |     // MARK: - Participant choice (equal playing time by rounds played)
 184 | 
 185 |     private func chooseParticipants(
 186 |         eligible: [Person],
 187 |         required: Int,
 188 |         event: Event,
 189 |         excluding: Set<UUID> = []
 190 |     ) -> [Person] {
 191 |         let playedCounts = roundsPlayedCounts(event: event)
 192 | 
 193 |         // Try to exclude current players if there are enough non-excluded players
 194 |         let nonExcluded = eligible.filter { !excluding.contains($0.id) }
 195 | 
 196 |         let pool = nonExcluded.count >= required ? nonExcluded : eligible
 197 | 
 198 |         return pool
 199 |             .sorted {
 200 |                 let a = playedCounts[$0.id, default: 0]
 201 |                 let b = playedCounts[$1.id, default: 0]
 202 |                 if a != b { return a < b }
 203 |                 return $0.displayName.localizedCaseInsensitiveCompare($1.displayName) == .orderedAscending
 204 |             }
 205 |             .prefix(required)
 206 |             .map { $0 }
 207 |     }
 208 | 
 209 |     private func roundsPlayedCounts(event: Event) -> [UUID: Int] {
 210 |         var counts: [UUID: Int] = [:]
 211 |         for eg in event.eventGames {
 212 |             for r in eg.rounds where r.completedAt != nil {
 213 |                 for team in r.teams {
 214 |                     for pid in team.memberPersonIds {
 215 |                         counts[pid, default: 0] += 1
 216 |                     }
 217 |                 }
 218 |             }
 219 |         }
 220 |         return counts
 221 |     }
 222 | 
 223 |     // MARK: - Matchup signature (head-to-head)
 224 | 
 225 |     private func matchupSignaturesForGame(eventGame: EventGame) -> Set<String> {
 226 |         var s = Set<String>()
 227 |         for r in eventGame.rounds where r.completedAt != nil {
 228 |             let sig = matchupSignature(teams: r.teams)
 229 |             s.insert(sig)
 230 |         }
 231 |         return s
 232 |     }
 233 | 
 234 |     private func matchupSignature(teams: [RoundTeam]) -> String {
 235 |         let normalizedTeams = teams
 236 |             .map { $0.memberPersonIds.sorted(by: { $0.uuidString < $1.uuidString }) }
 237 |             .sorted { left, right in
 238 |                 left.map(\.uuidString).joined(separator: ",") < right.map(\.uuidString).joined(separator: ",")
 239 |             }
 240 |         return normalizedTeams
 241 |             .map { $0.map(\.uuidString).joined(separator: ",") }
 242 |             .joined(separator: "||")
 243 |     }
 244 | 
 245 |     // MARK: - Scoring
 246 | 
 247 |     private func scoreTeams(
 248 |         teams: [RoundTeam],
 249 |         peopleById: [UUID: Person],
 250 |         historySignatures: Set<String>,
 251 |         allowSpousesSameTeam: Bool
 252 |     ) -> Double {
 253 | 
 254 |         var score: Double = 0
 255 | 
 256 |         // 1) Prevent repeating the exact head-to-head matchup
 257 |         let sig = matchupSignature(teams: teams)
 258 |         if historySignatures.contains(sig) {
 259 |             score += 10_000
 260 |         }
 261 | 
 262 |         // 2) Spouse constraint (unless couplesOnly)
 263 |         if !allowSpousesSameTeam {
 264 |             for team in teams {
 265 |                 let ids = Set(team.memberPersonIds)
 266 |                 for pid in ids {
 267 |                     if let spouseId = peopleById[pid]?.spouseId, ids.contains(spouseId) {
 268 |                         score += 5_000
 269 |                     }
 270 |                 }
 271 |             }
 272 |         }
 273 | 
 274 |         // 3) Balance by athleticAbility / weight / age (if available)
 275 |         func teamStat(_ team: RoundTeam, get: (Person) -> Int?) -> Double {
 276 |             let vals = team.memberPersonIds.compactMap { peopleById[$0] }.compactMap(get)
 277 |             if vals.isEmpty { return 0 }
 278 |             return Double(vals.reduce(0, +))
 279 |         }
 280 | 
 281 |         let athletic = teams.map { teamStat($0) { $0.athleticAbility } }
 282 |         let weight = teams.map { teamStat($0) { $0.weight } }
 283 |         let age = teams.map { teamStat($0) { $0.age } }
 284 | 
 285 |         score += variancePenalty(athletic) * 2.0
 286 |         score += variancePenalty(weight) * 0.25
 287 |         score += variancePenalty(age) * 0.5
 288 | 
 289 |         return score
 290 |     }
 291 | 
 292 |     private func variancePenalty(_ values: [Double]) -> Double {
 293 |         guard values.count > 1 else { return 0 }
 294 |         let mean = values.reduce(0, +) / Double(values.count)
 295 |         let varSum = values.reduce(0) { $0 + pow($1 - mean, 2) }
 296 |         return varSum
 297 |     }
 298 | 
 299 |     // MARK: - Couples-only teams
 300 | 
 301 |     private func generateCouplesOnlyTeams(teamCount: Int, eligible: [Person]) throws -> [RoundTeam] {
 302 | 
 303 |         let byId = Dictionary(uniqueKeysWithValues: eligible.map { ($0.id, $0) })
 304 | 
 305 |         var used = Set<UUID>()
 306 |         var pairs: [[UUID]] = []
 307 | 
 308 |         for person in eligible {
 309 |             guard !used.contains(person.id),
 310 |                   let spouseId = person.spouseId,
 311 |                   let spouse = byId[spouseId],
 312 |                   spouse.spouseId == person.id,
 313 |                   !used.contains(spouse.id)
 314 |             else { continue }
 315 | 
 316 |             used.insert(person.id)
 317 |             used.insert(spouse.id)
 318 |             pairs.append([person.id, spouse.id])
 319 |         }
 320 | 
 321 |         guard pairs.count >= teamCount else {
 322 |             throw FairnessError.notEnoughCouples(required: teamCount, available: pairs.count)
 323 |         }
 324 | 
 325 |         return pairs.prefix(teamCount).map { RoundTeam(memberPersonIds: $0) }
 326 |     }
 327 | 
 328 |     // MARK: - Utilities
 329 | 
 330 |     private func partition(ids: [UUID], teamCount: Int, playersPerTeam: Int) -> [RoundTeam] {
 331 |         var result: [RoundTeam] = []
 332 |         var index = 0
 333 |         for _ in 0..<teamCount {
 334 |             let slice = ids[index..<(index + playersPerTeam)]
 335 |             result.append(RoundTeam(memberPersonIds: Array(slice)))
 336 |             index += playersPerTeam
 337 |         }
 338 |         return result
 339 |     }
 340 | 
 341 |     private func fetchEligiblePeople(for event: Event) throws -> [Person] {
 342 |         let all = try context.fetch(FetchDescriptor<Person>())
 343 |         let idSet = Set(event.participantIds)
 344 |         return all.filter { $0.isActive && idSet.contains($0.id) }
 345 |     }
 346 | 
 347 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 348 |         let d = FetchDescriptor<GameTemplate>()
 349 |         let templates = try context.fetch(d)
 350 |         return templates.first(where: { $0.id == id })
 351 |     }
 352 | }
 353 | 
 354 | // MARK: - Errors
 355 | 
 356 | enum FairnessError: LocalizedError {
 357 |     case missingEventGame
 358 |     case notEnoughPlayers(required: Int, available: Int)
 359 |     case notEnoughCouples(required: Int, available: Int)
 360 | 
 361 |     var errorDescription: String? {
 362 |         switch self {
 363 |         case .missingEventGame:
 364 |             return "Round is not attached to an EventGame."
 365 |         case .notEnoughPlayers(let r, let a):
 366 |             return "Not enough players. Required \(r), available \(a)."
 367 |         case .notEnoughCouples(let r, let a):
 368 |             return "Not enough couples. Required \(r), available \(a)."
 369 |         }
 370 |     }
 371 | }


END FILE: ./Christmas Games/FairnessEngine.swift


################################################################################
START FILE: ./Christmas Games/FilesHelper.swift
################################################################################
   1 | import Foundation
   2 | import UIKit
   3 | 
   4 | enum FilesHelper {
   5 | 
   6 |     static func openAppFolder() {
   7 |         guard let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
   8 |             return
   9 |         }
  10 | 
  11 |         UIApplication.shared.open(url)
  12 |     }
  13 | 
  14 |     static func ensureGamesFolderExists() {
  15 |         guard let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
  16 |             return
  17 |         }
  18 | 
  19 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  20 | 
  21 |         if !FileManager.default.fileExists(atPath: folder.path) {
  22 |             try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  23 |         }
  24 |     }
  25 | }


END FILE: ./Christmas Games/FilesHelper.swift


################################################################################
START FILE: ./Christmas Games/GameTemplateSheet.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct CreateGameTemplateSheet: View {
   5 |     @Environment(\.dismiss) private var dismiss
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     let onCreated: (GameTemplate) -> Void
   9 | 
  10 |     @State private var name = ""
  11 |     @State private var groupName = ""
  12 |     @State private var defaultTeamCount = 2
  13 |     @State private var defaultPlayersPerTeam = 2
  14 |     @State private var defaultRoundsPerGame = 1
  15 |     @State private var teamType: TeamType = .any
  16 |     @State private var playInstructions = ""
  17 |     @State private var setupInstructions = ""
  18 | 
  19 |     var body: some View {
  20 |         NavigationStack {
  21 |             Form {
  22 |                 Section("Basic") {
  23 |                     TextField("Name", text: $name)
  24 |                     TextField("Group (optional)", text: $groupName)
  25 |                 }
  26 | 
  27 |                 Section("Defaults") {
  28 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
  29 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
  30 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
  31 | 
  32 |                     Picker("Team Type", selection: $teamType) {
  33 |                         Text("Any").tag(TeamType.any)
  34 |                         Text("Male Only").tag(TeamType.maleOnly)
  35 |                         Text("Female Only").tag(TeamType.femaleOnly)
  36 |                         Text("Couples Only").tag(TeamType.couplesOnly)
  37 |                     }
  38 |                 }
  39 | 
  40 |                 Section("Instructions") {
  41 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
  42 |                         .lineLimit(3...8)
  43 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
  44 |                         .lineLimit(3...8)
  45 |                 }
  46 |             }
  47 |             .navigationTitle("New Game Template")
  48 |             .toolbar {
  49 |                 ToolbarItem(placement: .topBarLeading) {
  50 |                     Button("Cancel") { dismiss() }
  51 |                 }
  52 | 
  53 |                 ToolbarItem(placement: .topBarTrailing) {
  54 |                     Button("Save") { save() }
  55 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
  56 |                 }
  57 |             }
  58 |         }
  59 |     }
  60 | 
  61 |     private func save() {
  62 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
  63 |         guard !trimmedName.isEmpty else { return }
  64 | 
  65 |         let template = GameTemplate(
  66 |             externalId: "user_\(UUID().uuidString.lowercased())",
  67 |             name: trimmedName,
  68 |             groupName: groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName,
  69 |             defaultTeamCount: defaultTeamCount,
  70 |             defaultPlayersPerTeam: defaultPlayersPerTeam,
  71 |             defaultRoundsPerGame: defaultRoundsPerGame,
  72 |             defaultTeamType: teamType,
  73 |             playInstructions: playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions,
  74 |             setupInstructions: setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
  75 |         )
  76 | 
  77 |         context.insert(template)
  78 |         try? context.save()
  79 | 
  80 |         onCreated(template)
  81 |         dismiss()
  82 |     }
  83 | }


END FILE: ./Christmas Games/GameTemplateSheet.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogImporter {
   6 | 
   7 |     // MARK: - Public API (matches your BootstrapView calls)
   8 | 
   9 |     /// Imports games.json from Documents *if present*.
  10 |     /// Returns the number of templates imported/updated, or nil if the file doesn't exist.
  11 |     static func importFromDocumentsIfPresent(
  12 |         context: ModelContext,
  13 |         filename: String,
  14 |         fileExtension: String
  15 |     ) throws -> Int? {
  16 |         let url = documentsURL(filename: filename, fileExtension: fileExtension)
  17 | 
  18 |         guard FileManager.default.fileExists(atPath: url.path) else {
  19 |             return nil
  20 |         }
  21 | 
  22 |         let data = try Data(contentsOf: url)
  23 |         let count = try importFromData(context: context, jsonData: data)
  24 |         return count
  25 |     }
  26 | 
  27 |     /// Imports games.json from the app bundle.
  28 |     /// Returns the number of templates imported/updated.
  29 |     static func importFromBundle(
  30 |         context: ModelContext,
  31 |         filename: String,
  32 |         fileExtension: String
  33 |     ) throws -> Int {
  34 |         guard let url = Bundle.main.url(forResource: filename, withExtension: fileExtension) else {
  35 |             return 0 // treat missing bundled json as "no seed"
  36 |         }
  37 | 
  38 |         let data = try Data(contentsOf: url)
  39 |         let count = try importFromData(context: context, jsonData: data)
  40 |         return count
  41 |     }
  42 | 
  43 |     // MARK: - Backward-compatible helpers (optional; safe to keep)
  44 | 
  45 |     static func importFromBundle(context: ModelContext) throws {
  46 |         _ = try importFromBundle(context: context, filename: "games", fileExtension: "json")
  47 |     }
  48 | 
  49 |     static func importFromDocuments(context: ModelContext) throws {
  50 |         _ = try importFromDocumentsIfPresent(context: context, filename: "games", fileExtension: "json")
  51 |     }
  52 | 
  53 |     // MARK: - Core import
  54 | 
  55 |     private static func importFromData(context: ModelContext, jsonData: Data) throws -> Int {
  56 |         let decoder = JSONDecoder()
  57 |         let catalog = try decoder.decode(GameCatalog.self, from: jsonData)
  58 | 
  59 |         var count = 0
  60 |         for game in catalog.games {
  61 |             try upsert(game: game, context: context)
  62 |             count += 1
  63 |         }
  64 | 
  65 |         try context.save()
  66 |         return count
  67 |     }
  68 | 
  69 |     private static func upsert(game: GameCatalogGame, context: ModelContext) throws {
  70 |         let descriptor = FetchDescriptor<GameTemplate>(
  71 |             predicate: #Predicate { $0.externalId == game.externalId }
  72 |         )
  73 | 
  74 |         if let existing = try context.fetch(descriptor).first {
  75 |             existing.name = game.name
  76 |             existing.groupName = game.groupName
  77 |             existing.defaultTeamCount = game.defaultTeamCount
  78 |             existing.defaultPlayersPerTeam = game.defaultPlayersPerTeam
  79 |             existing.defaultRoundsPerGame = game.defaultRoundsPerGame
  80 |             existing.defaultTeamTypeRaw = game.teamType.rawValue
  81 |             existing.playInstructions = game.playInstructions
  82 |             existing.setupInstructions = game.setupInstructions
  83 |         } else {
  84 |             let template = GameTemplate(
  85 |                 externalId: game.externalId,
  86 |                 name: game.name,
  87 |                 groupName: game.groupName,
  88 |                 defaultTeamCount: game.defaultTeamCount,
  89 |                 defaultPlayersPerTeam: game.defaultPlayersPerTeam,
  90 |                 defaultRoundsPerGame: game.defaultRoundsPerGame,
  91 |                 defaultTeamType: game.teamType,
  92 |                 playInstructions: game.playInstructions,
  93 |                 setupInstructions: game.setupInstructions
  94 |             )
  95 |             context.insert(template)
  96 |         }
  97 |     }
  98 | 
  99 |     // MARK: - Paths
 100 | 
 101 |     private static func documentsURL(filename: String, fileExtension: String) -> URL {
 102 |         FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
 103 |             .appendingPathComponent("\(filename).\(fileExtension)")
 104 |     }
 105 | }
 106 | 
 107 | // MARK: - Private JSON DTOs (avoid redeclaration collisions)
 108 | 
 109 | private struct GameCatalog: Codable {
 110 |     let games: [GameCatalogGame]
 111 | }
 112 | 
 113 | private struct GameCatalogGame: Codable {
 114 |     let externalId: String
 115 |     let name: String
 116 |     let groupName: String?
 117 |     let defaultTeamCount: Int
 118 |     let defaultPlayersPerTeam: Int
 119 |     let defaultRoundsPerGame: Int
 120 |     let teamType: TeamType
 121 |     let playInstructions: String?
 122 |     let setupInstructions: String?
 123 | }


END FILE: ./Christmas Games/GameCatalogImporter.swift


################################################################################
START FILE: ./Christmas Games/EventStatsView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct EventStatsView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @Environment(\.colorTheme) private var theme
   7 | 
   8 |     @Query(sort: \Event.createdAt, order: .reverse)
   9 |     private var allEvents: [Event]
  10 | 
  11 |     @Query(sort: \Person.displayName)
  12 |     private var people: [Person]
  13 | 
  14 |     @State private var selectedEventId: UUID?
  15 |     
  16 |     @State private var showResetConfirm = false
  17 |     @State private var message: String?
  18 |     @State private var showMessage = false
  19 | 
  20 |     var body: some View {
  21 |         ZStack {
  22 |             LinearGradient(
  23 |                 colors: [theme.gradientStart, theme.gradientEnd],
  24 |                 startPoint: .topLeading,
  25 |                 endPoint: .bottomTrailing
  26 |             )
  27 |             .ignoresSafeArea()
  28 | 
  29 |             VStack(spacing: 0) {
  30 |                 eventPicker
  31 |                 if let stats = calculatedStats {
  32 |                     statsTable(stats: stats)
  33 |                 } else {
  34 |                     ContentUnavailableView(...)
  35 |                 }
  36 |             }
  37 |         }
  38 |         .navigationTitle("Event Stats")
  39 |         .toolbarBackground(.hidden, for: .navigationBar)
  40 |         .toolbarColorScheme(.dark, for: .navigationBar)
  41 |         ...
  42 | 
  43 |         .navigationTitle("Event Stats")
  44 |         .toolbar {
  45 |             ToolbarItem(placement: .topBarTrailing) {
  46 |                 Button("Reset") {
  47 |                     showResetConfirm = true
  48 |                 }
  49 |                 .disabled(selectedEventId == nil)
  50 |             }
  51 |         }
  52 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
  53 |             Button("Reset Event", role: .destructive) {
  54 |                 resetSelectedEvent()
  55 |             }
  56 |             Button("Cancel", role: .cancel) { }
  57 |         } message: {
  58 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
  59 |         }
  60 |         .alert("Message", isPresented: $showMessage) {
  61 |             Button("OK", role: .cancel) { }
  62 |         } message: {
  63 |             Text(message ?? "Unknown error")
  64 |         }
  65 |     }
  66 | 
  67 |     private var eventPicker: some View {
  68 |         Picker("Event", selection: $selectedEventId) {
  69 |             Text("All Events").tag(nil as UUID?)
  70 |             ForEach(allEvents) { event in
  71 |                 Text(event.name).tag(event.id as UUID?)
  72 |             }
  73 |         }
  74 |         .pickerStyle(.menu)
  75 |         .padding()
  76 |     }
  77 | 
  78 |     private var calculatedStats: [PlayerStats]? {
  79 |         let eventsToAnalyze: [Event]
  80 |         if let selectedEventId {
  81 |             eventsToAnalyze = allEvents.filter { $0.id == selectedEventId }
  82 |         } else {
  83 |             eventsToAnalyze = allEvents
  84 |         }
  85 | 
  86 |         guard !eventsToAnalyze.isEmpty else { return nil }
  87 | 
  88 |         var statsDict: [UUID: PlayerStats] = [:]
  89 | 
  90 |         for event in eventsToAnalyze {
  91 |             for eventGame in event.eventGames {
  92 |                 for round in eventGame.rounds where round.completedAt != nil {
  93 |                     // Process placements
  94 |                     for (personId, placement) in round.placements {
  95 |                         var stat = statsDict[personId] ?? PlayerStats(personId: personId)
  96 |                         stat.gamesPlayed += 1
  97 | 
  98 |                         switch placement {
  99 |                         case 1: stat.firstPlace += 1
 100 |                         case 2: stat.secondPlace += 1
 101 |                         case 3: stat.thirdPlace += 1
 102 |                         default: break
 103 |                         }
 104 | 
 105 |                         statsDict[personId] = stat
 106 |                     }
 107 | 
 108 |                     // Handle ties (when resultType == .tie and winningTeamId == nil)
 109 |                     if round.resultType == .tie, round.winningTeamId == nil {
 110 |                         for team in round.teams {
 111 |                             for personId in team.memberPersonIds {
 112 |                                 var stat = statsDict[personId] ?? PlayerStats(personId: personId)
 113 |                                 if round.placements[personId] == nil {
 114 |                                     stat.gamesPlayed += 1
 115 |                                 }
 116 |                                 stat.firstPlace += 1 // Tie counts as 1st place for all
 117 |                                 statsDict[personId] = stat
 118 |                             }
 119 |                         }
 120 |                     }
 121 |                 }
 122 |             }
 123 |         }
 124 | 
 125 |         guard !statsDict.isEmpty else { return nil }
 126 | 
 127 |         let peopleById = Dictionary(uniqueKeysWithValues: people.map { ($0.id, $0) })
 128 | 
 129 |         var result = statsDict.values.map { stat -> PlayerStats in
 130 |             var s = stat
 131 |             s.displayName = peopleById[stat.personId]?.displayName ?? "Unknown"
 132 |             s.totalPoints = (s.firstPlace * 3) + (s.secondPlace * 2) + (s.thirdPlace * 1)
 133 |             return s
 134 |         }
 135 | 
 136 |         result.sort { lhs, rhs in
 137 |             if lhs.totalPoints != rhs.totalPoints {
 138 |                 return lhs.totalPoints > rhs.totalPoints
 139 |             }
 140 |             return lhs.gamesPlayed < rhs.gamesPlayed
 141 |         }
 142 | 
 143 |         for (index, _) in result.enumerated() {
 144 |             result[index].rank = index + 1
 145 |         }
 146 | 
 147 |         return result
 148 |     }
 149 | 
 150 |     private func statsTable(stats: [PlayerStats]) -> some View {
 151 |         List {
 152 |             Section {
 153 |                 HStack {
 154 |                     Text("Name").frame(maxWidth: .infinity, alignment: .leading)
 155 |                     Text("Games").frame(width: 50)
 156 |                     Text("1st").frame(width: 40)
 157 |                     Text("2nd").frame(width: 40)
 158 |                     Text("3rd").frame(width: 40)
 159 |                     Text("Rank").frame(width: 50)
 160 |                 }
 161 |                 .font(.caption)
 162 |                 .bold()
 163 |             }
 164 | 
 165 |             ForEach(stats) { stat in
 166 |                 HStack {
 167 |                     Text(stat.displayName)
 168 |                         .frame(maxWidth: .infinity, alignment: .leading)
 169 |                     Text("\(stat.gamesPlayed)")
 170 |                         .frame(width: 50)
 171 |                     Text("\(stat.firstPlace)")
 172 |                         .frame(width: 40)
 173 |                     Text("\(stat.secondPlace)")
 174 |                         .frame(width: 40)
 175 |                     Text("\(stat.thirdPlace)")
 176 |                         .frame(width: 40)
 177 |                     Text("\(stat.rank)")
 178 |                         .frame(width: 50)
 179 |                         .bold()
 180 |                 }
 181 |                 .font(.body)
 182 |             }
 183 |         }
 184 |     }
 185 |     
 186 |     private func resetSelectedEvent() {
 187 |         guard let selectedEventId,
 188 |               let event = allEvents.first(where: { $0.id == selectedEventId }) else {
 189 |             return
 190 |         }
 191 |         
 192 |         do {
 193 |             try EventEngine(context: context).resetEvent(event)
 194 |             message = "Event '\(event.name)' has been reset successfully."
 195 |             showMessage = true
 196 |         } catch {
 197 |             message = error.localizedDescription
 198 |             showMessage = true
 199 |         }
 200 |     }
 201 | }
 202 | 
 203 | // MARK: - Stats Model
 204 | 
 205 | private struct PlayerStats: Identifiable {
 206 |     let id = UUID()
 207 |     let personId: UUID
 208 |     var displayName: String = ""
 209 |     var gamesPlayed: Int = 0
 210 |     var firstPlace: Int = 0
 211 |     var secondPlace: Int = 0
 212 |     var thirdPlace: Int = 0
 213 |     var totalPoints: Int = 0
 214 |     var rank: Int = 0
 215 | }
 216 | 
 217 | #Preview {
 218 |     NavigationStack {
 219 |         EventStatsView()
 220 |     }
 221 |     .modelContainer(for: [Event.self, Person.self])
 222 | }


END FILE: ./Christmas Games/EventStatsView.swift


################################################################################
START FILE: ./Christmas Games/EventEngine.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | final class EventEngine {
   6 |     private let context: ModelContext
   7 | 
   8 |     init(context: ModelContext) {
   9 |         self.context = context
  10 |     }
  11 | 
  12 |     // MARK: - Participants
  13 | 
  14 |     func setParticipants(for event: Event, participantIds: [UUID]) throws {
  15 |         event.participantIds = participantIds
  16 |         touch(event)
  17 |         try context.save()
  18 |     }
  19 | 
  20 |     // MARK: - Event Games: Import / Add / Remove
  21 | 
  22 |     /// Imports all GameTemplate rows into the given Event as EventGame rows.
  23 |     /// Idempotent: re-running does NOT create duplicates.
  24 |     func importAllCatalogGames(into event: Event) throws {
  25 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  26 |         let existingTemplateIds = Set(event.eventGames.map { $0.gameTemplateId })
  27 | 
  28 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  29 |         var nextIndex = maxIndex + 1
  30 | 
  31 |         for template in templates {
  32 |             guard !existingTemplateIds.contains(template.id) else { continue }
  33 | 
  34 |             let eg = EventGame(
  35 |                 event: event,
  36 |                 gameTemplateId: template.id,
  37 |                 orderIndex: nextIndex
  38 |             )
  39 |             nextIndex += 1
  40 | 
  41 |             context.insert(eg)
  42 |             event.eventGames.append(eg)
  43 |         }
  44 | 
  45 |         touch(event)
  46 |         try context.save()
  47 |     }
  48 | 
  49 |     /// Adds a single template to the event (no duplicates).
  50 |     func addGameTemplate(_ template: GameTemplate, to event: Event) throws {
  51 |         let exists = event.eventGames.contains(where: { $0.gameTemplateId == template.id })
  52 |         guard !exists else { return }
  53 | 
  54 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
  55 |         let eg = EventGame(
  56 |             event: event,
  57 |             gameTemplateId: template.id,
  58 |             orderIndex: maxIndex + 1
  59 |         )
  60 | 
  61 |         context.insert(eg)
  62 |         event.eventGames.append(eg)
  63 | 
  64 |         touch(event)
  65 |         try context.save()
  66 |     }
  67 | 
  68 |     /// Removes an EventGame from the event.
  69 |     func removeEventGame(_ eventGame: EventGame, from event: Event) throws {
  70 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
  71 |         context.delete(eventGame)
  72 | 
  73 |         // If you removed the current game, clear pointer
  74 |         if event.currentEventGameId == eventGame.id {
  75 |             event.currentEventGameId = nil
  76 |         }
  77 | 
  78 |         touch(event)
  79 |         try context.save()
  80 |     }
  81 | 
  82 |     // MARK: - Skip Current Game
  83 |     
  84 |     /// Skip current game and start a new random game, keeping same players
  85 |     func skipToNextGame(_ currentGame: EventGame, keepingPlayers playerIds: [UUID]) throws {
  86 |         guard let event = currentGame.event else { return }
  87 |         
  88 |         // Mark current game as completed (skipped)
  89 |         currentGame.status = .completed
  90 |         
  91 |         // Pick next random game
  92 |         guard let nextGame = try pickNextGameRandom(event: event) else {
  93 |             // No more games available
  94 |             event.status = .completed
  95 |             event.currentEventGameId = nil
  96 |             touch(event)
  97 |             try context.save()
  98 |             return
  99 |         }
 100 |         
 101 |         // Start the new game
 102 |         event.status = .active
 103 |         event.currentEventGameId = nextGame.id
 104 |         nextGame.status = .inProgress
 105 |         
 106 |         // Create round 0 if none exist
 107 |         if nextGame.rounds.isEmpty {
 108 |             let r = Round(eventGame: nextGame, roundIndex: 0, teams: [])
 109 |             context.insert(r)
 110 |             nextGame.rounds.append(r)
 111 |         }
 112 |         
 113 |         // Generate teams with preferred players
 114 |         if let currentRound = nextGame.rounds.first(where: { $0.completedAt == nil }) {
 115 |             let fairness = FairnessEngine(context: context)
 116 |             let teams = try fairness.generateTeamsWithPreferredPlayers(
 117 |                 for: currentRound,
 118 |                 in: event,
 119 |                 preferredPlayers: playerIds
 120 |             )
 121 |             currentRound.teams = teams
 122 |         }
 123 |         
 124 |         touch(event)
 125 |         try context.save()
 126 |     }
 127 | 
 128 |     // MARK: - Event Lifecycle
 129 | 
 130 |     func startEvent(_ event: Event) throws {
 131 |         // Starting the event means: mark active and immediately start the next game.
 132 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 133 | 
 134 |         event.status = .active
 135 | 
 136 |         if let next = try pickNextGameRandom(event: event) {
 137 |             try start(event: event, eventGame: next)
 138 |         }
 139 | 
 140 |         touch(event)
 141 |         try context.save()
 142 |     }
 143 | 
 144 |     func pauseEvent(_ event: Event) throws {
 145 |         event.status = .paused
 146 |         touch(event)
 147 |         try context.save()
 148 |     }
 149 | 
 150 |     // MARK: - Reset Event
 151 | 
 152 | func resetEvent(_ event: Event) throws {
 153 |     // Delete all rounds from all games
 154 |     for eventGame in event.eventGames {
 155 |         for round in eventGame.rounds {
 156 |             context.delete(round)
 157 |         }
 158 |         eventGame.rounds.removeAll()
 159 |         eventGame.status = .notStarted
 160 |     }
 161 |     
 162 |     // Reset event state
 163 |     event.status = .available
 164 |     event.currentEventGameId = nil
 165 |     
 166 |     touch(event)
 167 |     try context.save()
 168 | }
 169 |     
 170 |     func resumeEvent(_ event: Event) throws {
 171 |         guard !event.participantIds.isEmpty else { throw StartError.noParticipants }
 172 | 
 173 |         event.status = .active
 174 | 
 175 |         // If there is no current game (or it is completed), start the next game.
 176 |         let current = event.currentEventGameId.flatMap { id in
 177 |             event.eventGames.first(where: { $0.id == id })
 178 |         }
 179 | 
 180 |         if current == nil || current?.status == .completed {
 181 |             if let next = try pickNextGameRandom(event: event) {
 182 |                 try start(event: event, eventGame: next)
 183 |             } else {
 184 |                 event.status = .completed
 185 |                 event.currentEventGameId = nil
 186 |             }
 187 |         }
 188 | 
 189 |         touch(event)
 190 |         try context.save()
 191 |     }
 192 | 
 193 |     /// Starts a specific EventGame:
 194 |     /// - sets event active
 195 |     /// - sets currentEventGameId
 196 |     /// - sets game status to inProgress
 197 |     /// - creates round 0 if missing
 198 |     func start(event: Event, eventGame: EventGame) throws {
 199 |         // Must have participants to play
 200 |         guard !event.participantIds.isEmpty else {
 201 |             throw StartError.noParticipants
 202 |         }
 203 | 
 204 |         // Resolve template to know defaultRoundsPerGame
 205 |         guard try fetchTemplate(id: eventGame.gameTemplateId) != nil else {
 206 |             throw StartError.missingTemplate
 207 |         }
 208 | 
 209 |         event.status = .active
 210 |         event.currentEventGameId = eventGame.id
 211 |         eventGame.status = .inProgress
 212 | 
 213 |         // Create round 0 if no rounds exist, OR if all rounds are completed
 214 |         let hasActiveRound = eventGame.rounds.contains { $0.completedAt == nil }
 215 |         if eventGame.rounds.isEmpty || !hasActiveRound {
 216 |             let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 217 |             let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 218 |             context.insert(r)
 219 |             eventGame.rounds.append(r)
 220 |         }
 221 | 
 222 |         touch(event)
 223 |         try context.save()
 224 |     }
 225 |     
 226 |     // MARK: - Game / Round progression
 227 | 
 228 |     func createNextRound(for eventGame: EventGame) throws -> Round {
 229 |         let nextIndex = eventGame.rounds.map(\.roundIndex).max().map { $0 + 1 } ?? 0
 230 |         let r = Round(eventGame: eventGame, roundIndex: nextIndex, teams: [])
 231 |         r.eventGame = eventGame  // Explicitly set inverse relationship
 232 |         context.insert(r)
 233 |         eventGame.rounds.append(r)
 234 | 
 235 |         if let event = eventGame.event {
 236 |             touch(event)
 237 |         }
 238 |         try context.save()
 239 |         return r
 240 |     }
 241 | 
 242 |     func completeGame(_ eventGame: EventGame) throws {
 243 |         eventGame.status = .completed
 244 |         if let event = eventGame.event {
 245 |             // If the completed game was current, clear pointer (next game will set it)
 246 |             if event.currentEventGameId == eventGame.id {
 247 |                 event.currentEventGameId = nil
 248 |             }
 249 |             touch(event)
 250 |         }
 251 |         try context.save()
 252 |     }
 253 | 
 254 |     func pickNextGameRandom(event: Event) throws -> EventGame? {
 255 |         let remaining = event.eventGames.filter { $0.status == .notStarted }
 256 |         guard !remaining.isEmpty else { return nil }
 257 | 
 258 |         // Simple variety heuristic: prefer a different group than the last completed game.
 259 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
 260 |         let templateById = Dictionary(uniqueKeysWithValues: templates.map { ($0.id, $0) })
 261 | 
 262 |         let lastCompleted = event.eventGames
 263 |             .filter { $0.status == .completed }
 264 |             .sorted { ($0.orderIndex) > ($1.orderIndex) }
 265 |             .first
 266 | 
 267 |         let lastGroup = lastCompleted.flatMap { templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines) }
 268 | 
 269 |         if let lastGroup, !lastGroup.isEmpty {
 270 |             let differentGroup = remaining.filter {
 271 |                 let g = templateById[$0.gameTemplateId]?.groupName?.trimmingCharacters(in: .whitespacesAndNewlines)
 272 |                 return (g?.isEmpty == false) ? (g != lastGroup) : true
 273 |             }
 274 |             if let pick = differentGroup.randomElement() {
 275 |                 return pick
 276 |             }
 277 |         }
 278 | 
 279 |         return remaining.randomElement()
 280 |     }
 281 | 
 282 |     func pushGameToLater(_ eventGame: EventGame) throws {
 283 |         guard let event = eventGame.event else { return }
 284 |         let maxIndex = event.eventGames.map(\.orderIndex).max() ?? -1
 285 |         eventGame.orderIndex = maxIndex + 1
 286 |         touch(event)
 287 |         try context.save()
 288 |     }
 289 | 
 290 |     func removeGameFromEvent(_ eventGame: EventGame) throws {
 291 |         guard let event = eventGame.event else {
 292 |             context.delete(eventGame)
 293 |             try context.save()
 294 |             return
 295 |         }
 296 |         event.eventGames.removeAll(where: { $0.id == eventGame.id })
 297 |         context.delete(eventGame)
 298 |         if event.currentEventGameId == eventGame.id {
 299 |             event.currentEventGameId = nil
 300 |         }
 301 |         touch(event)
 302 |         try context.save()
 303 |     }
 304 | 
 305 |     // MARK: - Teams / Rounds
 306 | 
 307 |     func generateTeams(for round: Round) throws {
 308 |         guard let eventGame = round.eventGame, let event = eventGame.event else { return }
 309 | 
 310 |         let fairness = FairnessEngine(context: context)
 311 |         let teams = try fairness.generateTeams(for: round, in: event)
 312 | 
 313 |         round.teams = teams
 314 |         touch(event)
 315 |         try context.save()
 316 |     }
 317 | 
 318 |     func swapPlayer(in round: Round, from outgoing: UUID, to incoming: UUID) throws {
 319 |         var updated = round.teams
 320 |         guard let teamIndex = updated.firstIndex(where: { $0.memberPersonIds.contains(outgoing) }) else { return }
 321 | 
 322 |         var team = updated[teamIndex]
 323 |         team.memberPersonIds = team.memberPersonIds.map { $0 == outgoing ? incoming : $0 }
 324 |         updated[teamIndex] = team
 325 |         round.teams = updated
 326 | 
 327 |         if let event = round.eventGame?.event {
 328 |             touch(event)
 329 |         }
 330 |         try context.save()
 331 |     }
 332 | 
 333 |     func finalizeRound(_ round: Round, winnerTeamId: UUID?) throws {
 334 |     round.completedAt = Date()
 335 | 
 336 |     // Calculate placements for all participants
 337 |     var placements: [UUID: Int] = [:]
 338 |     
 339 |     if let winnerTeamId {
 340 |         // Winner case
 341 |         round.resultType = .win
 342 |         round.winningTeamId = winnerTeamId
 343 |         
 344 |         // Assign placements
 345 |         for team in round.teams {
 346 |             let placement = (team.id == winnerTeamId) ? 1 : 2
 347 |             for personId in team.memberPersonIds {
 348 |                 placements[personId] = placement
 349 |             }
 350 |         }
 351 |     } else {
 352 |         // Tie case - everyone gets 1st place
 353 |         round.resultType = .tie
 354 |         round.winningTeamId = nil
 355 |         
 356 |         for team in round.teams {
 357 |             for personId in team.memberPersonIds {
 358 |                 placements[personId] = 1
 359 |             }
 360 |         }
 361 |     }
 362 |     
 363 |     round.placements = placements
 364 | 
 365 |     if let event = round.eventGame?.event {
 366 |         touch(event)
 367 |     }
 368 |     try context.save()
 369 | }
 370 | 
 371 |     // MARK: - Helpers
 372 | 
 373 |     private func fetchTemplate(id: UUID) throws -> GameTemplate? {
 374 |         let descriptor = FetchDescriptor<GameTemplate>()
 375 |         let templates = try context.fetch(descriptor)
 376 |         return templates.first(where: { $0.id == id })
 377 |     }
 378 | 
 379 |     private func touch(_ event: Event) {
 380 |         event.lastModifiedAt = Date()
 381 |     }
 382 | 
 383 |     enum StartError: LocalizedError {
 384 |         case noParticipants
 385 |         case missingTemplate
 386 |         case invalidRoundCount
 387 | 
 388 |         var errorDescription: String? {
 389 |             switch self {
 390 |             case .noParticipants:
 391 |                 return "No players selected for this event. Add players before starting a game."
 392 |             case .missingTemplate:
 393 |                 return "The selected game template could not be found in the catalog."
 394 |             case .invalidRoundCount:
 395 |                 return "This game has an invalid number of rounds."
 396 |             }
 397 |         }
 398 |     }
 399 | }


END FILE: ./Christmas Games/EventEngine.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogExporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | @MainActor
   5 | enum GameCatalogExporter {
   6 | 
   7 |     static func exportToDocuments(
   8 |         context: ModelContext,
   9 |         filename: String = "games",
  10 |         fileExtension: String = "json"
  11 |     ) throws -> URL {
  12 | 
  13 |         let templates = try context.fetch(FetchDescriptor<GameTemplate>())
  14 | 
  15 |         let games: [ExportGameCatalogGame] = templates
  16 |             .map { t in
  17 |                 ExportGameCatalogGame(
  18 |                     externalId: t.externalId,
  19 |                     name: t.name,
  20 |                     groupName: t.groupName,
  21 |                     defaultTeamCount: t.defaultTeamCount,
  22 |                     defaultPlayersPerTeam: t.defaultPlayersPerTeam,
  23 |                     defaultRoundsPerGame: t.defaultRoundsPerGame,
  24 |                     teamType: t.defaultTeamType,
  25 |                     playInstructions: t.playInstructions,
  26 |                     setupInstructions: t.setupInstructions
  27 |                 )
  28 |             }
  29 |             .sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
  30 | 
  31 |         let catalog = ExportGameCatalog(games: games)
  32 | 
  33 |         let data = try JSONEncoder().encode(catalog)
  34 | 
  35 |         let url = try documentsURL(filename: filename, fileExtension: fileExtension)
  36 |         try data.write(to: url, options: [.atomic])
  37 | 
  38 |         return url
  39 |     }
  40 | 
  41 |     private static func documentsURL(filename: String, fileExtension: String) throws -> URL {
  42 |         let dir = try FileManager.default.url(
  43 |             for: .documentDirectory,
  44 |             in: .userDomainMask,
  45 |             appropriateFor: nil,
  46 |             create: true
  47 |         )
  48 |         return dir.appendingPathComponent("\(filename).\(fileExtension)")
  49 |     }
  50 | }
  51 | 
  52 | // MARK: - Private JSON DTOs (scoped to exporter)
  53 | 
  54 | private struct ExportGameCatalog: Codable {
  55 |     let games: [ExportGameCatalogGame]
  56 | }
  57 | 
  58 | private struct ExportGameCatalogGame: Codable {
  59 |     let externalId: String
  60 |     let name: String
  61 |     let groupName: String?
  62 |     let defaultTeamCount: Int
  63 |     let defaultPlayersPerTeam: Int
  64 |     let defaultRoundsPerGame: Int
  65 |     let teamType: TeamType
  66 |     let playInstructions: String?
  67 |     let setupInstructions: String?
  68 | }


END FILE: ./Christmas Games/GameCatalogExporter.swift


################################################################################
START FILE: ./Christmas Games/Christmas_GamesApp.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | @main
   5 | struct Christmas_GamesApp: App {
   6 | 
   7 |     private var sharedModelContainer: ModelContainer = {
   8 |         let schema = Schema([
   9 |             Person.self,
  10 |             GameTemplate.self,
  11 |             Event.self,
  12 |             EventGame.self,
  13 |             Round.self
  14 |         ])
  15 | 
  16 |         let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
  17 |         let folder = docs.appendingPathComponent("Christmas Games", isDirectory: true)
  18 |         try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
  19 | 
  20 |         let storeURL = folder.appendingPathComponent("ChristmasGames_v2.store")
  21 | 
  22 |         let configuration = ModelConfiguration(schema: schema, url: storeURL)
  23 | 
  24 |         do {
  25 |             return try ModelContainer(for: schema, configurations: [configuration])
  26 |         } catch {
  27 |             fatalError("Failed to create ModelContainer: \(error)")
  28 |         }
  29 |     }()
  30 | 
  31 |     var body: some Scene {
  32 |         WindowGroup {
  33 |             MainMenuView()
  34 |         }
  35 |         .modelContainer(sharedModelContainer)
  36 |     }
  37 | }


END FILE: ./Christmas Games/Christmas_GamesApp.swift


################################################################################
START FILE: ./Christmas Games/ColorTheme.swift
################################################################################
   1 | import SwiftUI
   2 | 
   3 | // MARK: - Color Theme System
   4 | 
   5 | enum ColorTheme: String, CaseIterable, Identifiable {
   6 |     case christmas = "Christmas"
   7 |     case ocean = "Ocean"
   8 |     case sunset = "Sunset"
   9 |     case forest = "Forest"
  10 |     case classic = "Classic"
  11 |     
  12 |     var id: String { rawValue }
  13 |     
  14 |     // Background gradient colors
  15 |     var gradientStart: Color {
  16 |         switch self {
  17 |         case .christmas:
  18 |             return Color(red: 0.7, green: 0.15, blue: 0.15)  // Deep red
  19 |         case .ocean:
  20 |             return Color(red: 0.1, green: 0.3, blue: 0.6)    // Deep blue
  21 |         case .sunset:
  22 |             return Color(red: 0.8, green: 0.3, blue: 0.2)    // Orange-red
  23 |         case .forest:
  24 |             return Color(red: 0.15, green: 0.4, blue: 0.2)   // Dark green
  25 |         case .classic:
  26 |             return Color(red: 0.3, green: 0.3, blue: 0.35)   // Neutral gray
  27 |         }
  28 |     }
  29 |     
  30 |     var gradientEnd: Color {
  31 |         switch self {
  32 |         case .christmas:
  33 |             return Color(red: 0.15, green: 0.5, blue: 0.2)   // Forest green
  34 |         case .ocean:
  35 |             return Color(red: 0.1, green: 0.5, blue: 0.5)    // Teal
  36 |         case .sunset:
  37 |             return Color(red: 0.9, green: 0.6, blue: 0.3)    // Golden
  38 |         case .forest:
  39 |             return Color(red: 0.3, green: 0.6, blue: 0.3)    // Light green
  40 |         case .classic:
  41 |             return Color(red: 0.5, green: 0.5, blue: 0.55)   // Light gray
  42 |         }
  43 |     }
  44 |     
  45 |     // Team colors for gameplay
  46 |     var teamColors: [Color] {
  47 |         switch self {
  48 |         case .christmas:
  49 |             return [
  50 |                 .red,
  51 |                 Color(red: 0.0, green: 0.5, blue: 0.2),      // Green
  52 |                 Color(red: 0.8, green: 0.7, blue: 0.2),      // Gold
  53 |                 .white,
  54 |                 Color(red: 0.6, green: 0.3, blue: 0.0),      // Brown
  55 |                 Color(red: 0.3, green: 0.3, blue: 0.8)       // Blue
  56 |             ]
  57 |         case .ocean:
  58 |             return [
  59 |                 Color(red: 0.0, green: 0.3, blue: 0.8),      // Deep blue
  60 |                 Color(red: 0.0, green: 0.7, blue: 0.7),      // Cyan
  61 |                 Color(red: 0.3, green: 0.5, blue: 0.9),      // Light blue
  62 |                 Color(red: 0.0, green: 0.5, blue: 0.5),      // Teal
  63 |                 Color(red: 0.5, green: 0.7, blue: 1.0),      // Sky blue
  64 |                 Color(red: 0.0, green: 0.4, blue: 0.6)       // Navy
  65 |             ]
  66 |         case .sunset:
  67 |             return [
  68 |                 Color(red: 0.9, green: 0.3, blue: 0.2),      // Red-orange
  69 |                 Color(red: 1.0, green: 0.6, blue: 0.2),      // Orange
  70 |                 Color(red: 1.0, green: 0.8, blue: 0.3),      // Yellow
  71 |                 Color(red: 0.8, green: 0.4, blue: 0.6),      // Pink
  72 |                 Color(red: 0.6, green: 0.3, blue: 0.8),      // Purple
  73 |                 Color(red: 0.9, green: 0.5, blue: 0.3)       // Peach
  74 |             ]
  75 |         case .forest:
  76 |             return [
  77 |                 Color(red: 0.2, green: 0.6, blue: 0.3),      // Green
  78 |                 Color(red: 0.4, green: 0.5, blue: 0.2),      // Olive
  79 |                 Color(red: 0.5, green: 0.4, blue: 0.2),      // Brown
  80 |                 Color(red: 0.3, green: 0.7, blue: 0.4),      // Light green
  81 |                 Color(red: 0.6, green: 0.6, blue: 0.3),      // Yellow-green
  82 |                 Color(red: 0.3, green: 0.5, blue: 0.5)       // Teal
  83 |             ]
  84 |         case .classic:
  85 |             return [
  86 |                 .red,
  87 |                 .blue,
  88 |                 .green,
  89 |                 .orange,
  90 |                 .purple,
  91 |                 Color(red: 0.0, green: 0.7, blue: 0.7)       // Teal
  92 |             ]
  93 |         }
  94 |     }
  95 |     
  96 |     // Accent color for buttons and highlights
  97 |     var accentColor: Color {
  98 |         switch self {
  99 |         case .christmas:
 100 |             return Color(red: 0.8, green: 0.7, blue: 0.2)    // Gold
 101 |         case .ocean:
 102 |             return Color(red: 0.0, green: 0.7, blue: 0.7)    // Cyan
 103 |         case .sunset:
 104 |             return Color(red: 1.0, green: 0.6, blue: 0.2)    // Orange
 105 |         case .forest:
 106 |             return Color(red: 0.4, green: 0.7, blue: 0.3)    // Light green
 107 |         case .classic:
 108 |             return .blue
 109 |         }
 110 |     }
 111 |     
 112 |     // Status colors (can be customized per theme or kept standard)
 113 |     func statusColor(_ status: EventStatus) -> Color {
 114 |         switch status {
 115 |         case .available: return .gray
 116 |         case .active: return accentColor
 117 |         case .paused: return .orange
 118 |         case .completed: return .blue
 119 |         }
 120 |     }
 121 |     
 122 |     // Preview icon for theme picker
 123 |     var icon: String {
 124 |         switch self {
 125 |         case .christmas: return "🎄"
 126 |         case .ocean: return "🌊"
 127 |         case .sunset: return "🌅"
 128 |         case .forest: return "🌲"
 129 |         case .classic: return "⚪️"
 130 |         }
 131 |     }
 132 | }
 133 | 
 134 | // MARK: - Theme Manager (SwiftUI Environment)
 135 | 
 136 | struct ThemeKey: EnvironmentKey {
 137 |     static let defaultValue: ColorTheme = .christmas
 138 | }
 139 | 
 140 | extension EnvironmentValues {
 141 |     var colorTheme: ColorTheme {
 142 |         get { self[ThemeKey.self] }
 143 |         set { self[ThemeKey.self] = newValue }
 144 |     }
 145 | }
 146 | 
 147 | // MARK: - Convenience Extensions
 148 | 
 149 | extension View {
 150 |     func themedBackground(_ theme: ColorTheme) -> some View {
 151 |         self.background(
 152 |             LinearGradient(
 153 |                 colors: [theme.gradientStart, theme.gradientEnd],
 154 |                 startPoint: .topLeading,
 155 |                 endPoint: .bottomTrailing
 156 |             )
 157 |             .ignoresSafeArea()
 158 |         )
 159 |     }
 160 | }


END FILE: ./Christmas Games/ColorTheme.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct GameCatalogView: View {
   6 |     @Environment(\.modelContext) private var context
   7 | 
   8 |     @Query(sort: \GameTemplate.name)
   9 |     private var templates: [GameTemplate]
  10 | 
  11 |     @State private var showCreateTemplate = false
  12 |     @State private var showCSVImporter = false
  13 |     @State private var editingTemplate: GameTemplate?
  14 | 
  15 |     @State private var pendingCSVData: Data?
  16 |     @State private var pendingCSVFilename: String?
  17 |     @State private var showCSVPreview = false
  18 | 
  19 |     @State private var alertTitle = "Message"
  20 |     @State private var alertMessage: String?
  21 |     @State private var showAlert = false
  22 |     
  23 |     // Filter and sort state
  24 |     @State private var filterTeamSize: Int? = nil
  25 |     @State private var filterTeamCount: Int? = nil
  26 |     @State private var sortOption: SortOption = .alphabetical
  27 |     @State private var teamTypeFilter: TeamTypeFilter = .all
  28 |     
  29 |     enum SortOption: String, CaseIterable {
  30 |         case alphabetical = "A-Z"
  31 |         case reverseAlphabetical = "Z-A"
  32 |         case status = "Status"
  33 |     }
  34 |     
  35 |     enum TeamTypeFilter: String, CaseIterable {
  36 |         case all = "All"
  37 |         case any = "Any"
  38 |         case maleOnly = "Male Only"
  39 |         case femaleOnly = "Female Only"
  40 |         case couplesOnly = "Couples Only"
  41 |     }
  42 | 
  43 |     var body: some View {
  44 |         List {
  45 |             // Filters section
  46 |             Section {
  47 |                 HStack {
  48 |                     Picker("Team Size", selection: $filterTeamSize) {
  49 |                         Text("Any").tag(nil as Int?)
  50 |                         ForEach(availableTeamSizes, id: \.self) { size in
  51 |                             Text("\(size)").tag(size as Int?)
  52 |                         }
  53 |                     }
  54 |                     .pickerStyle(.menu)
  55 |                     
  56 |                     Picker("Teams", selection: $filterTeamCount) {
  57 |                         Text("Any").tag(nil as Int?)
  58 |                         ForEach(availableTeamCounts, id: \.self) { count in
  59 |                             Text("\(count)").tag(count as Int?)
  60 |                         }
  61 |                     }
  62 |                     .pickerStyle(.menu)
  63 |                 }
  64 |                 
  65 |                 HStack {
  66 |                     Picker("Sort", selection: $sortOption) {
  67 |                         ForEach(SortOption.allCases, id: \.self) { option in
  68 |                             Text(option.rawValue).tag(option)
  69 |                         }
  70 |                     }
  71 |                     .pickerStyle(.menu)
  72 |                     
  73 |                     Picker("Team Type", selection: $teamTypeFilter) {
  74 |                         ForEach(TeamTypeFilter.allCases, id: \.self) { filter in
  75 |                             Text(filter.rawValue).tag(filter)
  76 |                         }
  77 |                     }
  78 |                     .pickerStyle(.menu)
  79 |                 }
  80 |             } header: {
  81 |                 Text("Games (\(filteredAndSortedTemplates.count))")
  82 |             }
  83 |             
  84 |             // Games list
  85 |             Section {
  86 |                 ForEach(filteredAndSortedTemplates) { template in
  87 |                     Button {
  88 |                         editingTemplate = template
  89 |                     } label: {
  90 |                         gameRow(for: template)
  91 |                     }
  92 |                 }
  93 |                 .onDelete(perform: deleteTemplates)
  94 |             }
  95 |         }
  96 |         .navigationTitle("Game Catalog")
  97 |         .toolbar {
  98 |             ToolbarItemGroup(placement: .topBarTrailing) {
  99 |                 Button("Add") { showCreateTemplate = true }
 100 |                 Button("Import CSV") { showCSVImporter = true }
 101 |             }
 102 |         }
 103 |         .sheet(isPresented: $showCreateTemplate) {
 104 |             CreateGameTemplateSheet { _ in }
 105 |         }
 106 |         .sheet(item: $editingTemplate) { template in
 107 |             EditGameTemplateSheet(template: template)
 108 |         }
 109 |         .fileImporter(
 110 |             isPresented: $showCSVImporter,
 111 |             allowedContentTypes: [UTType.commaSeparatedText],
 112 |             allowsMultipleSelection: false
 113 |         ) { result in
 114 |             do {
 115 |                 let urls = try result.get()
 116 |                 guard let url = urls.first else { return }
 117 | 
 118 |                 let didStart = url.startAccessingSecurityScopedResource()
 119 |                 defer { if didStart { url.stopAccessingSecurityScopedResource() } }
 120 | 
 121 |                 let data = try Data(contentsOf: url)
 122 | 
 123 |                 pendingCSVData = data
 124 |                 pendingCSVFilename = url.lastPathComponent
 125 |                 showCSVPreview = true
 126 | 
 127 |             } catch {
 128 |                 alertTitle = "Import failed"
 129 |                 alertMessage = error.localizedDescription
 130 |                 showAlert = true
 131 |             }
 132 |         }
 133 |         .sheet(isPresented: $showCSVPreview) {
 134 |             if let data = pendingCSVData {
 135 |                 CSVImportPreviewSheet(csvData: data, filename: pendingCSVFilename)
 136 |             } else {
 137 |                 Text("No CSV loaded.")
 138 |                     .padding()
 139 |             }
 140 |         }
 141 |         .alert(alertTitle, isPresented: $showAlert) {
 142 |             Button("OK", role: .cancel) { }
 143 |         } message: {
 144 |             Text(alertMessage ?? "Unknown error")
 145 |         }
 146 |     }
 147 |     
 148 |     // MARK: - Computed Properties
 149 |     
 150 |     private var availableTeamSizes: [Int] {
 151 |         Set(templates.map { $0.defaultPlayersPerTeam }).sorted()
 152 |     }
 153 |     
 154 |     private var availableTeamCounts: [Int] {
 155 |         Set(templates.map { $0.defaultTeamCount }).sorted()
 156 |     }
 157 |     
 158 |     private var filteredAndSortedTemplates: [GameTemplate] {
 159 |         var result = templates
 160 |         
 161 |         // Apply team size filter
 162 |         if let filterTeamSize {
 163 |             result = result.filter { $0.defaultPlayersPerTeam == filterTeamSize }
 164 |         }
 165 |         
 166 |         // Apply team count filter
 167 |         if let filterTeamCount {
 168 |             result = result.filter { $0.defaultTeamCount == filterTeamCount }
 169 |         }
 170 |         
 171 |         // Apply team type filter
 172 |         switch teamTypeFilter {
 173 |         case .all:
 174 |             break
 175 |         case .any:
 176 |             result = result.filter { $0.defaultTeamType == .any }
 177 |         case .maleOnly:
 178 |             result = result.filter { $0.defaultTeamType == .maleOnly }
 179 |         case .femaleOnly:
 180 |             result = result.filter { $0.defaultTeamType == .femaleOnly }
 181 |         case .couplesOnly:
 182 |             result = result.filter { $0.defaultTeamType == .couplesOnly }
 183 |         }
 184 |         
 185 |         // Apply sort
 186 |         switch sortOption {
 187 |         case .alphabetical:
 188 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
 189 |         case .reverseAlphabetical:
 190 |             result.sort { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedDescending }
 191 |         case .status:
 192 |             // For GameCatalog, we can sort by group name as a proxy for "status"
 193 |             result.sort { lhs, rhs in
 194 |                 let lGroup = lhs.groupName ?? ""
 195 |                 let rGroup = rhs.groupName ?? ""
 196 |                 if lGroup != rGroup {
 197 |                     return lGroup.localizedCaseInsensitiveCompare(rGroup) == .orderedAscending
 198 |                 }
 199 |                 return lhs.name.localizedCaseInsensitiveCompare(rhs.name) == .orderedAscending
 200 |             }
 201 |         }
 202 |         
 203 |         return result
 204 |     }
 205 |     
 206 |     private func gameRow(for template: GameTemplate) -> some View {
 207 |         VStack(alignment: .leading, spacing: 4) {
 208 |             Text(template.name)
 209 |                 .font(.body)
 210 |                 .foregroundStyle(.primary)
 211 |             
 212 |             HStack {
 213 |                 if let group = template.groupName?.trimmingCharacters(in: .whitespacesAndNewlines),
 214 |                    !group.isEmpty {
 215 |                     Text(group)
 216 |                         .font(.footnote)
 217 |                         .foregroundStyle(.secondary)
 218 |                     Text("•")
 219 |                         .font(.footnote)
 220 |                         .foregroundStyle(.secondary)
 221 |                 }
 222 |                 
 223 |                 Text("Teams: \(template.defaultTeamCount) × \(template.defaultPlayersPerTeam)")
 224 |                     .font(.footnote)
 225 |                     .foregroundStyle(.secondary)
 226 |                 
 227 |                 Text("•")
 228 |                     .font(.footnote)
 229 |                     .foregroundStyle(.secondary)
 230 |                 
 231 |                 Text("Rounds: \(template.defaultRoundsPerGame)")
 232 |                     .font(.footnote)
 233 |                     .foregroundStyle(.secondary)
 234 |             }
 235 |         }
 236 |     }
 237 | 
 238 |     private func deleteTemplates(at offsets: IndexSet) {
 239 |         for index in offsets {
 240 |             let template = filteredAndSortedTemplates[index]
 241 |             if let original = templates.first(where: { $0.id == template.id }) {
 242 |                 context.delete(original)
 243 |             }
 244 |         }
 245 |         try? context.save()
 246 |     }
 247 | }
 248 | 
 249 | // MARK: - Edit Game Template Sheet
 250 | 
 251 | private struct EditGameTemplateSheet: View {
 252 |     @Environment(\.dismiss) private var dismiss
 253 |     @Environment(\.modelContext) private var context
 254 | 
 255 |     let template: GameTemplate
 256 | 
 257 |     @State private var name = ""
 258 |     @State private var groupName = ""
 259 |     @State private var defaultTeamCount = 2
 260 |     @State private var defaultPlayersPerTeam = 2
 261 |     @State private var defaultRoundsPerGame = 1
 262 |     @State private var teamType: TeamType = .any
 263 |     @State private var playInstructions = ""
 264 |     @State private var setupInstructions = ""
 265 | 
 266 |     var body: some View {
 267 |         NavigationStack {
 268 |             Form {
 269 |                 Section("Basic") {
 270 |                     TextField("Name", text: $name)
 271 |                     TextField("Group (optional)", text: $groupName)
 272 |                 }
 273 | 
 274 |                 Section("Defaults") {
 275 |                     Stepper("Teams: \(defaultTeamCount)", value: $defaultTeamCount, in: 1...20)
 276 |                     Stepper("Players per Team: \(defaultPlayersPerTeam)", value: $defaultPlayersPerTeam, in: 1...20)
 277 |                     Stepper("Rounds: \(defaultRoundsPerGame)", value: $defaultRoundsPerGame, in: 1...50)
 278 | 
 279 |                     Picker("Team Type", selection: $teamType) {
 280 |                         Text("Any").tag(TeamType.any)
 281 |                         Text("Male Only").tag(TeamType.maleOnly)
 282 |                         Text("Female Only").tag(TeamType.femaleOnly)
 283 |                         Text("Couples Only").tag(TeamType.couplesOnly)
 284 |                     }
 285 |                 }
 286 | 
 287 |                 Section("Instructions") {
 288 |                     TextField("Setup Instructions (optional)", text: $setupInstructions, axis: .vertical)
 289 |                         .lineLimit(3...8)
 290 |                     TextField("Playing Instructions (optional)", text: $playInstructions, axis: .vertical)
 291 |                         .lineLimit(3...8)
 292 |                 }
 293 |             }
 294 |             .navigationTitle("Edit Game Template")
 295 |             .toolbar {
 296 |                 ToolbarItem(placement: .topBarLeading) {
 297 |                     Button("Cancel") { dismiss() }
 298 |                 }
 299 | 
 300 |                 ToolbarItem(placement: .topBarTrailing) {
 301 |                     Button("Save") { save() }
 302 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 303 |                 }
 304 |             }
 305 |             .onAppear {
 306 |                 name = template.name
 307 |                 groupName = template.groupName ?? ""
 308 |                 defaultTeamCount = template.defaultTeamCount
 309 |                 defaultPlayersPerTeam = template.defaultPlayersPerTeam
 310 |                 defaultRoundsPerGame = template.defaultRoundsPerGame
 311 |                 teamType = template.defaultTeamType
 312 |                 playInstructions = template.playInstructions ?? ""
 313 |                 setupInstructions = template.setupInstructions ?? ""
 314 |             }
 315 |         }
 316 |     }
 317 | 
 318 |     private func save() {
 319 |         let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
 320 |         guard !trimmedName.isEmpty else { return }
 321 | 
 322 |         template.name = trimmedName
 323 |         template.groupName = groupName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : groupName
 324 |         template.defaultTeamCount = defaultTeamCount
 325 |         template.defaultPlayersPerTeam = defaultPlayersPerTeam
 326 |         template.defaultRoundsPerGame = defaultRoundsPerGame
 327 |         template.defaultTeamType = teamType
 328 |         template.playInstructions = playInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : playInstructions
 329 |         template.setupInstructions = setupInstructions.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : setupInstructions
 330 | 
 331 |         try? context.save()
 332 |         dismiss()
 333 |     }
 334 | }
 335 | 
 336 | #Preview {
 337 |     NavigationStack {
 338 |         GameCatalogView()
 339 |     }
 340 |     .modelContainer(for: [GameTemplate.self])
 341 | }


END FILE: ./Christmas Games/GameCatalogView.swift


################################################################################
START FILE: ./Christmas Games/SeedData.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum SeedData {
   5 | 
   6 |     @MainActor
   7 |     static func seedOrUpdateRoster(context: ModelContext) throws {
   8 | 
   9 |         let existing = try context.fetch(FetchDescriptor<Person>())
  10 |         var byName: [String: Person] =
  11 |             Dictionary(uniqueKeysWithValues: existing.map { ($0.displayName, $0) })
  12 | 
  13 |         let legacyNamesToDelete: Set<String> = ["Couple2-A", "Couple2-B"]
  14 |         for person in existing where legacyNamesToDelete.contains(person.displayName) {
  15 |             context.delete(person)
  16 |             byName[person.displayName] = nil
  17 |         }
  18 | 
  19 |         @discardableResult
  20 |         func upsert(
  21 |             _ name: String,
  22 |             sex: String,
  23 |             age: Int,
  24 |             weight: Int,
  25 |             athleticAbility: Int,
  26 |             height: String
  27 |         ) -> Person {
  28 | 
  29 |             if let p = byName[name] {
  30 |                 p.sex = sex
  31 |                 p.age = age
  32 |                 p.weight = weight
  33 |                 p.athleticAbility = athleticAbility
  34 |                 p.height = height
  35 |                 p.isActive = true
  36 |                 
  37 |                 // Set categories from detailed values
  38 |                 p.weightCategory = categoryForWeight(weight)
  39 |                 p.heightCategory = categoryForHeight(height)
  40 |                 
  41 |                 return p
  42 |             } else {
  43 |                 let p = Person(
  44 |                     displayName: name,
  45 |                     sex: sex,
  46 |                     age: age,
  47 |                     weight: weight,
  48 |                     athleticAbility: athleticAbility,
  49 |                     height: height,
  50 |                     weightCategory: categoryForWeight(weight),
  51 |                     heightCategory: categoryForHeight(height),
  52 |                     isActive: true
  53 |                 )
  54 |                 context.insert(p)
  55 |                 byName[name] = p
  56 |                 return p
  57 |             }
  58 |         }
  59 | 
  60 |         let dean     = upsert("Dean",     sex: "M", age: 60, weight: 250, athleticAbility: 3, height: #"6'3""#)
  61 |         let shannon  = upsert("Shannon",  sex: "F", age: 57, weight: 150, athleticAbility: 4, height: #"6'"#)
  62 | 
  63 |         let michael  = upsert("Michael",  sex: "M", age: 34, weight: 250, athleticAbility: 3, height: #"6'"#)
  64 |         let brittany = upsert("Brittany", sex: "F", age: 33, weight: 190, athleticAbility: 1, height: #"5'10""#)
  65 | 
  66 |         let blake    = upsert("Blake",    sex: "M", age: 30, weight: 250, athleticAbility: 5, height: #"6'2""#)
  67 |         let brooklin = upsert("Brooklin", sex: "F", age: 30, weight: 140, athleticAbility: 4, height: #"5'2""#)
  68 | 
  69 |         let brandon  = upsert("Brandon",  sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'6""#)
  70 |         let jenna    = upsert("Jenna",    sex: "F", age: 27, weight: 140, athleticAbility: 4, height: #"5'8""#)
  71 | 
  72 |         let hunter   = upsert("Hunter",   sex: "M", age: 27, weight: 260, athleticAbility: 5, height: #"6'5""#)
  73 |         let brooke   = upsert("Brooke",   sex: "F", age: 24, weight: 140, athleticAbility: 5, height: #"5'10""#)
  74 | 
  75 |         func linkSpouses(_ a: Person, _ b: Person) {
  76 |             a.spouseId = b.id
  77 |             b.spouseId = a.id
  78 |         }
  79 | 
  80 |         linkSpouses(dean, shannon)
  81 |         linkSpouses(michael, brittany)
  82 |         linkSpouses(blake, brooklin)
  83 |         linkSpouses(brandon, jenna)
  84 |         linkSpouses(hunter, brooke)
  85 | 
  86 |         try context.save()
  87 |     }
  88 |     
  89 |     // MARK: - Category Mapping
  90 |     
  91 |     private static func categoryForWeight(_ weight: Int) -> String {
  92 |         switch weight {
  93 |         case ..<160: return "S"
  94 |         case 160..<220: return "M"
  95 |         default: return "L"
  96 |         }
  97 |     }
  98 |     
  99 |     private static func categoryForHeight(_ height: String) -> String {
 100 |         // Parse height like "6'3"" → inches
 101 |         let components = height.replacingOccurrences(of: "\"", with: "").split(separator: "'")
 102 |         guard components.count == 2,
 103 |               let feet = Int(components[0]),
 104 |               let inches = Int(components[1]) else {
 105 |             return "M" // Default
 106 |         }
 107 |         
 108 |         let totalInches = (feet * 12) + inches
 109 |         
 110 |         switch totalInches {
 111 |         case ..<67: return "S"  // < 5'7"
 112 |         case 67..<73: return "M" // 5'7" - 6'0"
 113 |         default: return "L"      // > 6'0"
 114 |         }
 115 |     }
 116 | }


END FILE: ./Christmas Games/SeedData.swift


################################################################################
START FILE: ./Christmas Games/GameCatalogCSVImporter.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | enum GameCatalogCSVImporterError: LocalizedError {
   5 |     case invalidFormat(String)
   6 |     case missingRequiredColumn(String)
   7 | 
   8 |     var errorDescription: String? {
   9 |         switch self {
  10 |         case .invalidFormat(let msg): return msg
  11 |         case .missingRequiredColumn(let col): return "CSV is missing required column: \(col)"
  12 |         }
  13 |     }
  14 | }
  15 | 
  16 | @MainActor
  17 | enum GameCatalogCSVImporter {
  18 | 
  19 |     struct ImportResult {
  20 |         var insertedOrUpdated: Int
  21 |         var skipped: Int
  22 |         var removed: Int
  23 |     }
  24 | 
  25 |     /// Importer tailored for your "Minute to Win It - Head to Head" CSV:
  26 |     /// Required columns:
  27 |     /// - gameId
  28 |     /// - gameName
  29 |     /// - teamType
  30 |     ///
  31 |     /// Optional columns:
  32 |     /// - groupName
  33 |     /// - defaultTeamCount, defaultPlayersPerTeam, defaultRoundsPerGame
  34 |     /// - instructionText
  35 |     /// - Materials, Gather, Purchase, Url (ignored by default)
  36 |     /// - Check (if "x", row is skipped and counted as removed)
  37 |     static func importCSV(context: ModelContext, csvData: Data) throws -> ImportResult {
  38 | 
  39 |         guard let text = String(data: csvData, encoding: .utf8) else {
  40 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file could not be read as UTF-8 text.")
  41 |         }
  42 | 
  43 |         let rawLines = text
  44 |             .split(whereSeparator: \.isNewline)
  45 |             .map(String.init)
  46 |             .filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
  47 | 
  48 |         guard !rawLines.isEmpty else {
  49 |             throw GameCatalogCSVImporterError.invalidFormat("CSV file is empty.")
  50 |         }
  51 | 
  52 |         // 1) Find the header row by detecting the expected columns.
  53 |         guard let headerIndex = rawLines.firstIndex(where: { line in
  54 |             let cols = parseCSVLine(line).map(normalizeHeaderKey)
  55 |             return cols.contains("gameid") && cols.contains("gamename") && cols.contains("teamtype")
  56 |         }) else {
  57 |             let firstLineCols = parseCSVLine(rawLines.first ?? "")
  58 |                 .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
  59 |                 .joined(separator: ", ")
  60 |             throw GameCatalogCSVImporterError.invalidFormat(
  61 |                 "Could not find a valid header row. Expected columns: gameId, gameName, teamType. " +
  62 |                 "First line columns were: \(firstLineCols)"
  63 |             )
  64 |         }
  65 | 
  66 |         let headerCols = parseCSVLine(rawLines[headerIndex])
  67 | 
  68 |         // Build header map; tolerate duplicate column names by keeping first occurrence.
  69 |         var headerMap: [String: Int] = [:]
  70 |         for (idx, name) in headerCols.enumerated() {
  71 |             let key = normalizeHeaderKey(name)
  72 |             if headerMap[key] == nil {
  73 |                 headerMap[key] = idx
  74 |             }
  75 |         }
  76 | 
  77 |         func colIndex(_ key: String, alternatives: [String] = []) -> Int? {
  78 |             if let i = headerMap[normalizeHeaderKey(key)] { return i }
  79 |             for alt in alternatives {
  80 |                 if let i = headerMap[normalizeHeaderKey(alt)] { return i }
  81 |             }
  82 |             return nil
  83 |         }
  84 | 
  85 |         // Required
  86 |         guard let iGameId = colIndex("gameId", alternatives: ["gameid", "id"]) else {
  87 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameId")
  88 |         }
  89 |         guard let iGameName = colIndex("gameName", alternatives: ["gamename", "name"]) else {
  90 |             throw GameCatalogCSVImporterError.missingRequiredColumn("gameName")
  91 |         }
  92 |         guard let iTeamType = colIndex("teamType", alternatives: ["teamtype"]) else {
  93 |             throw GameCatalogCSVImporterError.missingRequiredColumn("teamType")
  94 |         }
  95 | 
  96 |         // Optional
  97 |         let iGroupName = colIndex("groupName", alternatives: ["group", "groupname"])
  98 |         let iTeamCount = colIndex("defaultTeamCount", alternatives: ["defaultteamcount"])
  99 |         let iPlayersPerTeam = colIndex("defaultPlayersPerTeam", alternatives: ["defaultplayersperteam"])
 100 |         let iRounds = colIndex("defaultRoundsPerGame", alternatives: ["defaultroundspergame"])
 101 |         let iPlayInstructionText = colIndex("playInstructions", alternatives: ["playinstructions", "playinstructiontext"])
 102 |         let iSetupInstructionText = colIndex("setupInstructions", alternatives: ["setupinstructions", "setupinstructiontext"])
 103 |         let iCheck = colIndex("check", alternatives: ["Check"])
 104 | 
 105 |         var result = ImportResult(insertedOrUpdated: 0, skipped: 0, removed: 0)
 106 | 
 107 |         // 2) Process rows
 108 |         for line in rawLines.dropFirst(headerIndex + 1) {
 109 |             let cols = parseCSVLine(line)
 110 | 
 111 |             guard iGameId < cols.count, iGameName < cols.count, iTeamType < cols.count else {
 112 |                 result.skipped += 1
 113 |                 continue
 114 |             }
 115 | 
 116 |             // Check column: if "x" -> skip/remove
 117 |             if let iCheck, iCheck < cols.count {
 118 |                 let flag = cols[iCheck].trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
 119 |                 if flag == "x" {
 120 |                     result.removed += 1
 121 |                     continue
 122 |                 }
 123 |             }
 124 | 
 125 |             let gameIdRaw = cols[iGameId].trimmingCharacters(in: .whitespacesAndNewlines)
 126 |             let name = cols[iGameName].trimmingCharacters(in: .whitespacesAndNewlines)
 127 | 
 128 |             guard !gameIdRaw.isEmpty, !name.isEmpty else {
 129 |                 result.skipped += 1
 130 |                 continue
 131 |             }
 132 | 
 133 |             // Stable externalId derived from gameId
 134 |             let externalId = "mtwi_\(slug(gameIdRaw))"
 135 | 
 136 |             let groupName: String? = {
 137 |                 guard let iGroupName, iGroupName < cols.count else { return nil }
 138 |                 let g = cols[iGroupName].trimmingCharacters(in: .whitespacesAndNewlines)
 139 |                 return g.isEmpty ? nil : g
 140 |             }()
 141 | 
 142 |             let playInstructions: String? = {
 143 |                 guard let iPlayInstructionText, iPlayInstructionText < cols.count else { return nil }
 144 |                 let t = cols[iPlayInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 145 |                 return t.isEmpty ? nil : t
 146 |             }()
 147 | 
 148 |             let setupInstructions: String? = {
 149 |                 guard let iSetupInstructionText, iSetupInstructionText < cols.count else { return nil }
 150 |                 let t = cols[iSetupInstructionText].trimmingCharacters(in: .whitespacesAndNewlines)
 151 |                 return t.isEmpty ? nil : t
 152 |             }()
 153 | 
 154 |             let teamType = mapTeamType(cols[iTeamType])
 155 | 
 156 |             let defaultTeamCount = parsePositiveInt(cols, iTeamCount, defaultValue: 2)
 157 |             let defaultPlayersPerTeam = parsePositiveInt(cols, iPlayersPerTeam, defaultValue: 2)
 158 |             let defaultRoundsPerGame = parsePositiveInt(cols, iRounds, defaultValue: 1)
 159 | 
 160 |             let existing = try fetchTemplateByExternalId(context: context, externalId: externalId)
 161 | 
 162 |             if let t = existing {
 163 |                 t.name = name
 164 |                 t.groupName = groupName
 165 |                 t.defaultTeamCount = defaultTeamCount
 166 |                 t.defaultPlayersPerTeam = defaultPlayersPerTeam
 167 |                 t.defaultRoundsPerGame = defaultRoundsPerGame
 168 |                 t.defaultTeamTypeRaw = teamType.rawValue
 169 |                 t.playInstructions = playInstructions
 170 |                 t.setupInstructions = setupInstructions
 171 |                 result.insertedOrUpdated += 1
 172 |             } else {
 173 |                 let t = GameTemplate(
 174 |                     externalId: externalId,
 175 |                     name: name,
 176 |                     groupName: groupName,
 177 |                     defaultTeamCount: defaultTeamCount,
 178 |                     defaultPlayersPerTeam: defaultPlayersPerTeam,
 179 |                     defaultRoundsPerGame: defaultRoundsPerGame,
 180 |                     defaultTeamType: teamType,
 181 |                     playInstructions: playInstructions,
 182 |                     setupInstructions: setupInstructions
 183 |                 )
 184 |                 context.insert(t)
 185 |                 result.insertedOrUpdated += 1
 186 |             }
 187 |         }
 188 | 
 189 |         try context.save()
 190 |         return result
 191 |     }
 192 | 
 193 |     // MARK: - Helpers
 194 | 
 195 |     private static func parsePositiveInt(_ cols: [String], _ index: Int?, defaultValue: Int) -> Int {
 196 |         guard let index, index < cols.count else { return defaultValue }
 197 |         let s = cols[index].trimmingCharacters(in: .whitespacesAndNewlines)
 198 |         if s.isEmpty { return defaultValue }
 199 |         if let v = Int(s), v > 0 { return v }
 200 |         return defaultValue
 201 |     }
 202 | 
 203 |     private static func mapTeamType(_ raw: String) -> TeamType {
 204 |         let n = raw
 205 |             .trimmingCharacters(in: .whitespacesAndNewlines)
 206 |             .lowercased()
 207 |             .replacingOccurrences(of: " ", with: "")
 208 |             .replacingOccurrences(of: "_", with: "")
 209 |             .replacingOccurrences(of: "-", with: "")
 210 | 
 211 |         if n.isEmpty { return .any }
 212 | 
 213 |         switch n {
 214 |         case "any", "anygender", "mixed", "coed", "all":
 215 |             return .any
 216 |         case "maleonly", "menonly", "boysonly", "male", "men":
 217 |             return .maleOnly
 218 |         case "femaleonly", "womenonly", "girlsonly", "female", "women":
 219 |             return .femaleOnly
 220 |         case "couplesonly", "couples", "couple", "spousesonly", "spouse":
 221 |             return .couplesOnly
 222 |         default:
 223 |             return .any
 224 |         }
 225 |     }
 226 | 
 227 |     private static func normalizeHeaderKey(_ s: String) -> String {
 228 |         let lowered = s.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
 229 |         let compact = lowered
 230 |             .replacingOccurrences(of: " ", with: "")
 231 |             .replacingOccurrences(of: "_", with: "")
 232 |         let allowed = compact.unicodeScalars.filter { CharacterSet.alphanumerics.contains($0) }
 233 |         return String(String.UnicodeScalarView(allowed))
 234 |     }
 235 | 
 236 |     private static func slug(_ s: String) -> String {
 237 |         let lowered = s.lowercased()
 238 |         let mapped = lowered.unicodeScalars.map { scalar -> Character in
 239 |             CharacterSet.alphanumerics.contains(scalar) ? Character(scalar) : "-"
 240 |         }
 241 |         let raw = String(mapped)
 242 |         let collapsed = raw
 243 |             .replacingOccurrences(of: "-+", with: "-", options: .regularExpression)
 244 |             .trimmingCharacters(in: CharacterSet(charactersIn: "-"))
 245 |         return collapsed.isEmpty ? UUID().uuidString.lowercased() : collapsed
 246 |     }
 247 | 
 248 |     /// CSV parser with quote handling (supports commas inside quoted fields)
 249 |     private static func parseCSVLine(_ line: String) -> [String] {
 250 |         var result: [String] = []
 251 |         var current = ""
 252 |         var inQuotes = false
 253 |         var i = line.startIndex
 254 | 
 255 |         while i < line.endIndex {
 256 |             let ch = line[i]
 257 | 
 258 |             if ch == "\"" {
 259 |                 let next = line.index(after: i)
 260 |                 if inQuotes, next < line.endIndex, line[next] == "\"" {
 261 |                     current.append("\"")
 262 |                     i = line.index(after: next)
 263 |                     continue
 264 |                 }
 265 |                 inQuotes.toggle()
 266 |                 i = line.index(after: i)
 267 |                 continue
 268 |             }
 269 | 
 270 |             if ch == ",", !inQuotes {
 271 |                 result.append(current)
 272 |                 current = ""
 273 |                 i = line.index(after: i)
 274 |                 continue
 275 |             }
 276 | 
 277 |             current.append(ch)
 278 |             i = line.index(after: i)
 279 |         }
 280 | 
 281 |         result.append(current)
 282 |         return result
 283 |     }
 284 | 
 285 |     private static func fetchTemplateByExternalId(context: ModelContext, externalId: String) throws -> GameTemplate? {
 286 |         let descriptor = FetchDescriptor<GameTemplate>()
 287 |         let templates = try context.fetch(descriptor)
 288 |         return templates.first(where: { $0.externalId == externalId })
 289 |         }
 290 |     }
 291 | 


END FILE: ./Christmas Games/GameCatalogCSVImporter.swift


################################################################################
START FILE: ./Christmas Games/Models.swift
################################################################################
   1 | import Foundation
   2 | import SwiftData
   3 | 
   4 | // MARK: - Enums
   5 | 
   6 | enum EventStatus: String, Codable, CaseIterable {
   7 |     case available
   8 |     case active
   9 |     case paused
  10 |     case completed
  11 | }
  12 | 
  13 | enum GameStatus: String, Codable, CaseIterable {
  14 |     case notStarted
  15 |     case inProgress
  16 |     case completed
  17 | }
  18 | 
  19 | enum TeamType: String, Codable, CaseIterable {
  20 |     case any
  21 |     case maleOnly
  22 |     case femaleOnly
  23 |     case couplesOnly
  24 | }
  25 | 
  26 | enum RoundResultType: String, Codable, CaseIterable {
  27 |     case win
  28 |     case tie
  29 | }
  30 | 
  31 | // MARK: - People
  32 | 
  33 | @Model
  34 | final class Person {
  35 |     @Attribute(.unique) var id: UUID
  36 |     var displayName: String
  37 |     var sex: String?
  38 |     var spouseId: UUID?
  39 | 
  40 |     // Detailed (used by CSV import, FairnessEngine)
  41 |     var age: Int?
  42 |     var weight: Int?
  43 |     var athleticAbility: Int?
  44 |     var height: String?
  45 | 
  46 |     // Categories (used by simple UI)
  47 |     var weightCategory: String?   // "S", "M", "L"
  48 |     var heightCategory: String?   // "S", "M", "L"
  49 | 
  50 |     var isActive: Bool
  51 | 
  52 |     init(
  53 |         id: UUID = UUID(),
  54 |         displayName: String,
  55 |         sex: String? = nil,
  56 |         spouseId: UUID? = nil,
  57 |         age: Int? = nil,
  58 |         weight: Int? = nil,
  59 |         athleticAbility: Int? = nil,
  60 |         height: String? = nil,
  61 |         weightCategory: String? = nil,
  62 |         heightCategory: String? = nil,
  63 |         isActive: Bool = true
  64 |     ) {
  65 |         self.id = id
  66 |         self.displayName = displayName
  67 |         self.sex = sex
  68 |         self.spouseId = spouseId
  69 |         self.age = age
  70 |         self.weight = weight
  71 |         self.athleticAbility = athleticAbility
  72 |         self.height = height
  73 |         self.weightCategory = weightCategory
  74 |         self.heightCategory = heightCategory
  75 |         self.isActive = isActive
  76 |     }
  77 | }
  78 | 
  79 | // MARK: - Game Templates
  80 | 
  81 | @Model
  82 | final class GameTemplate {
  83 |     @Attribute(.unique) var id: UUID
  84 |     @Attribute(.unique) var externalId: String
  85 | 
  86 |     var name: String
  87 |     var groupName: String?
  88 | 
  89 |     var defaultTeamCount: Int
  90 |     var defaultPlayersPerTeam: Int
  91 |     var defaultRoundsPerGame: Int
  92 |     var defaultTeamTypeRaw: String
  93 | 
  94 |     var playInstructions: String?
  95 |     var setupInstructions: String?
  96 | 
  97 |     init(
  98 |         id: UUID = UUID(),
  99 |         externalId: String,
 100 |         name: String,
 101 |         groupName: String? = nil,
 102 |         defaultTeamCount: Int,
 103 |         defaultPlayersPerTeam: Int,
 104 |         defaultRoundsPerGame: Int,
 105 |         defaultTeamType: TeamType,
 106 |         playInstructions: String? = nil,
 107 |         setupInstructions: String? = nil
 108 |     ) {
 109 |         self.id = id
 110 |         self.externalId = externalId
 111 |         self.name = name
 112 |         self.groupName = groupName
 113 |         self.defaultTeamCount = defaultTeamCount
 114 |         self.defaultPlayersPerTeam = defaultPlayersPerTeam
 115 |         self.defaultRoundsPerGame = defaultRoundsPerGame
 116 |         self.defaultTeamTypeRaw = defaultTeamType.rawValue
 117 |         self.playInstructions = playInstructions
 118 |         self.setupInstructions = setupInstructions
 119 |     }
 120 | 
 121 |     @Transient
 122 |     var defaultTeamType: TeamType {
 123 |         get { TeamType(rawValue: defaultTeamTypeRaw) ?? .any }
 124 |         set { defaultTeamTypeRaw = newValue.rawValue }
 125 |     }
 126 | }
 127 | 
 128 | // MARK: - RoundTeam
 129 | 
 130 | struct RoundTeam: Codable, Equatable, Identifiable {
 131 |     var id: UUID
 132 |     var memberPersonIds: [UUID]
 133 | 
 134 |     init(id: UUID = UUID(), memberPersonIds: [UUID]) {
 135 |         self.id = id
 136 |         self.memberPersonIds = memberPersonIds
 137 |     }
 138 | }
 139 | 
 140 | // MARK: - Event
 141 | 
 142 | @Model
 143 | final class Event {
 144 |     @Attribute(.unique) var id: UUID
 145 |     var name: String
 146 | 
 147 |     var statusRaw: String
 148 |     var participantIds: [UUID]
 149 | 
 150 |     var createdAt: Date
 151 |     var lastModifiedAt: Date
 152 | 
 153 |     var currentEventGameId: UUID?
 154 | 
 155 |     @Relationship(deleteRule: .cascade, inverse: \EventGame.event)
 156 |     var eventGames: [EventGame]
 157 | 
 158 |     init(
 159 |         id: UUID = UUID(),
 160 |         name: String,
 161 |         status: EventStatus = .available,
 162 |         participantIds: [UUID] = [],
 163 |         createdAt: Date = Date(),
 164 |         lastModifiedAt: Date = Date(),
 165 |         currentEventGameId: UUID? = nil,
 166 |         eventGames: [EventGame] = []
 167 |     ) {
 168 |         self.id = id
 169 |         self.name = name
 170 |         self.statusRaw = status.rawValue
 171 |         self.participantIds = participantIds
 172 |         self.createdAt = createdAt
 173 |         self.lastModifiedAt = lastModifiedAt
 174 |         self.currentEventGameId = currentEventGameId
 175 |         self.eventGames = eventGames
 176 |     }
 177 | 
 178 |     @Transient
 179 |     var status: EventStatus {
 180 |         get { EventStatus(rawValue: statusRaw) ?? .available }
 181 |         set { statusRaw = newValue.rawValue }
 182 |     }
 183 | }
 184 | 
 185 | // MARK: - EventGame
 186 | 
 187 | @Model
 188 | final class EventGame {
 189 |     @Attribute(.unique) var id: UUID
 190 | 
 191 |     var event: Event?
 192 | 
 193 |     var gameTemplateId: UUID
 194 |     var orderIndex: Int
 195 |     var statusRaw: String
 196 | 
 197 |     var overrideTeamCount: Int?
 198 |     var overridePlayersPerTeam: Int?
 199 |     var overrideRoundsPerGame: Int?
 200 |     var overrideTeamTypeRaw: String?
 201 |     var overridePlayInstructions: String?
 202 |     var overrideSetupInstructions: String?
 203 | 
 204 |     var overrideTeamPlayersData: Data?
 205 | 
 206 |     @Relationship(deleteRule: .cascade, inverse: \Round.eventGame)
 207 |     var rounds: [Round]
 208 | 
 209 |     init(
 210 |         id: UUID = UUID(),
 211 |         event: Event? = nil,
 212 |         gameTemplateId: UUID,
 213 |         orderIndex: Int,
 214 |         status: GameStatus = .notStarted,
 215 |         overrideTeamCount: Int? = nil,
 216 |         overridePlayersPerTeam: Int? = nil,
 217 |         overrideRoundsPerGame: Int? = nil,
 218 |         overrideTeamType: TeamType? = nil,
 219 |         overrideTeamPlayers: [[UUID]]? = nil,
 220 |         overridePlayInstructions: String? = nil,
 221 |         overrideSetupInstructions: String? = nil,
 222 |         rounds: [Round] = []
 223 |     ) {
 224 |         self.id = id
 225 |         self.event = event
 226 |         self.gameTemplateId = gameTemplateId
 227 |         self.orderIndex = orderIndex
 228 |         self.statusRaw = status.rawValue
 229 |         self.overrideTeamCount = overrideTeamCount
 230 |         self.overridePlayersPerTeam = overridePlayersPerTeam
 231 |         self.overrideRoundsPerGame = overrideRoundsPerGame
 232 |         self.overrideTeamTypeRaw = overrideTeamType?.rawValue
 233 |         if let overrideTeamPlayers {
 234 |             self.overrideTeamPlayersData = try? JSONEncoder().encode(overrideTeamPlayers)
 235 |         } else {
 236 |             self.overrideTeamPlayersData = nil
 237 |         }
 238 |         self.overridePlayInstructions = overridePlayInstructions
 239 |         self.overrideSetupInstructions = overrideSetupInstructions
 240 |         self.rounds = rounds
 241 |     }
 242 | 
 243 |     @Transient
 244 |     var status: GameStatus {
 245 |         get { GameStatus(rawValue: statusRaw) ?? .notStarted }
 246 |         set { statusRaw = newValue.rawValue }
 247 |     }
 248 | 
 249 |     @Transient
 250 |     var overrideTeamType: TeamType? {
 251 |         get { overrideTeamTypeRaw.flatMap { TeamType(rawValue: $0) } }
 252 |         set { overrideTeamTypeRaw = newValue?.rawValue }
 253 |     }
 254 | 
 255 |     @Transient
 256 |     var overrideTeamPlayers: [[UUID]]? {
 257 |         get {
 258 |             guard let data = overrideTeamPlayersData else { return nil }
 259 |             return try? JSONDecoder().decode([[UUID]].self, from: data)
 260 |         }
 261 |         set {
 262 |             if let newValue {
 263 |                 overrideTeamPlayersData = try? JSONEncoder().encode(newValue)
 264 |             } else {
 265 |                 overrideTeamPlayersData = nil
 266 |             }
 267 |         }
 268 |     }
 269 | }
 270 | 
 271 | // MARK: - Round
 272 | 
 273 | @Model
 274 | final class Round {
 275 |     @Attribute(.unique) var id: UUID
 276 | 
 277 |     var eventGame: EventGame?
 278 | 
 279 |     var roundIndex: Int
 280 |     var createdAt: Date
 281 |     var completedAt: Date?
 282 | 
 283 |     var teamsData: Data
 284 |     var placementsData: Data
 285 | 
 286 |     var resultTypeRaw: String?
 287 |     var winningTeamId: UUID?
 288 | 
 289 |     init(
 290 |         id: UUID = UUID(),
 291 |         eventGame: EventGame? = nil,
 292 |         roundIndex: Int,
 293 |         createdAt: Date = Date(),
 294 |         completedAt: Date? = nil,
 295 |         teams: [RoundTeam] = [],
 296 |         placements: [UUID: Int] = [:],
 297 |         resultType: RoundResultType? = nil,
 298 |         winningTeamId: UUID? = nil
 299 |     ) {
 300 |         self.id = id
 301 |         self.eventGame = eventGame
 302 |         self.roundIndex = roundIndex
 303 |         self.createdAt = createdAt
 304 |         self.completedAt = completedAt
 305 |         self.teamsData = (try? JSONEncoder().encode(teams)) ?? Data()
 306 |         self.placementsData = (try? JSONEncoder().encode(placements)) ?? Data()
 307 |         self.resultTypeRaw = resultType?.rawValue
 308 |         self.winningTeamId = winningTeamId
 309 |     }
 310 | 
 311 |     @Transient
 312 |     var teams: [RoundTeam] {
 313 |         get { (try? JSONDecoder().decode([RoundTeam].self, from: teamsData)) ?? [] }
 314 |         set { teamsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 315 |     }
 316 | 
 317 |     @Transient
 318 |     var placements: [UUID: Int] {
 319 |         get { (try? JSONDecoder().decode([UUID: Int].self, from: placementsData)) ?? [:] }
 320 |         set { placementsData = (try? JSONEncoder().encode(newValue)) ?? Data() }
 321 |     }
 322 | 
 323 |     @Transient
 324 |     var resultType: RoundResultType? {
 325 |         get { resultTypeRaw.flatMap { RoundResultType(rawValue: $0) } }
 326 |         set { resultTypeRaw = newValue?.rawValue }
 327 |     }
 328 | 
 329 |     @Transient
 330 |     var isLocked: Bool {
 331 |         completedAt != nil
 332 |     }
 333 | }


END FILE: ./Christmas Games/Models.swift


################################################################################
START FILE: ./Christmas Games/ParticipantCatalogView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | 
   4 | struct ParticipantCatalogView: View {
   5 |     @Environment(\.modelContext) private var context
   6 |     @Environment(\.colorTheme) private var theme
   7 | 
   8 |     @Query(sort: \Person.displayName)
   9 |     private var people: [Person]
  10 | 
  11 |     @State private var showCreatePerson = false
  12 |     @State private var editingPerson: Person?
  13 | 
  14 |     @State private var alertTitle = "Message"
  15 |     @State private var alertMessage: String?
  16 |     @State private var showAlert = false
  17 | 
  18 |     var body: some View {
  19 |     ZStack {
  20 |         // Gradient background
  21 |         LinearGradient(
  22 |             colors: [theme.gradientStart, theme.gradientEnd],
  23 |             startPoint: .topLeading,
  24 |             endPoint: .bottomTrailing
  25 |         )
  26 |         .ignoresSafeArea()
  27 | 
  28 |         // Your existing List
  29 |         List {
  30 |             ForEach(people) { person in
  31 |                 Button {
  32 |                     editingPerson = person
  33 |                 } label: {
  34 |                     HStack {
  35 |                         VStack(alignment: .leading, spacing: 4) {
  36 |                             Text(person.displayName)
  37 |                                 .font(.body)
  38 |                                 .foregroundStyle(.primary)
  39 | 
  40 |                             if let sex = person.sex {
  41 |                                 Text("Gender: \(sex)")
  42 |                                     .font(.footnote)
  43 |                                     .foregroundStyle(.secondary)
  44 |                             }
  45 |                         }
  46 | 
  47 |                         Spacer()
  48 | 
  49 |                         if !person.isActive {
  50 |                             Text("Inactive")
  51 |                                 .font(.footnote)
  52 |                                 .foregroundStyle(.secondary)
  53 |                         }
  54 |                     }
  55 |                 }
  56 |             }
  57 |             .onDelete(perform: deletePeople)
  58 |         }
  59 |         .scrollContentBackground(.hidden) // <- critical
  60 |     }
  61 |     .navigationTitle("Participant Catalog")
  62 |     .toolbarBackground(.hidden, for: .navigationBar)   // lets gradient show under title
  63 |     .toolbarColorScheme(.dark, for: .navigationBar)    // keeps title readable on gradient
  64 |     .toolbar {
  65 |         ToolbarItem(placement: .topBarTrailing) {
  66 |             Button("Add") { showCreatePerson = true }
  67 |         }
  68 |     }
  69 |     .sheet(isPresented: $showCreatePerson) {
  70 |         CreatePersonSheet()
  71 |     }
  72 |     .sheet(item: $editingPerson) { person in
  73 |         EditPersonSheet(person: person)
  74 |     }
  75 |     .alert(alertTitle, isPresented: $showAlert) {
  76 |         Button("OK", role: .cancel) { }
  77 |     } message: {
  78 |         Text(alertMessage ?? "Unknown error")
  79 |     }
  80 | }
  81 | 
  82 |     private func deletePeople(at offsets: IndexSet) {
  83 |         for index in offsets {
  84 |             context.delete(people[index])
  85 |         }
  86 |         try? context.save()
  87 |     }
  88 | }
  89 | 
  90 | #Preview {
  91 |     NavigationStack {
  92 |         ParticipantCatalogView()
  93 |     }
  94 |     .modelContainer(for: [Person.self])
  95 | }
  96 | 


END FILE: ./Christmas Games/ParticipantCatalogView.swift


################################################################################
START FILE: ./Christmas Games/EventsListView.swift
################################################################################
   1 | import SwiftUI
   2 | import SwiftData
   3 | import UniformTypeIdentifiers
   4 | 
   5 | struct EventsListView: View {
   6 |     @Environment(\.modelContext) private var context
   7 |     @Environment(\.colorTheme) private var theme
   8 | 
   9 |     @Query(sort: \Event.createdAt, order: .reverse)
  10 |     private var events: [Event]
  11 | 
  12 |     @State private var showAddEvent = false
  13 | 
  14 |     var body: some View {
  15 |     ZStack {
  16 |         LinearGradient(
  17 |             colors: [theme.gradientStart, theme.gradientEnd],
  18 |             startPoint: .topLeading,
  19 |             endPoint: .bottomTrailing
  20 |         )
  21 |         .ignoresSafeArea()
  22 | 
  23 |         List {
  24 |             ForEach(events) { event in
  25 |                 NavigationLink {
  26 |                     EventDetailView(event: event)
  27 |                 } label: {
  28 |                     VStack(alignment: .leading, spacing: 4) {
  29 |                         Text(event.name).font(.headline)
  30 |                         Text(event.statusRaw.capitalized)
  31 |                             .font(.subheadline)
  32 |                             .foregroundStyle(.secondary)
  33 |                     }
  34 |                 }
  35 |             }
  36 |             .onDelete(perform: deleteEvents)
  37 |         }
  38 |         .scrollContentBackground(.hidden)
  39 |     }
  40 |     .navigationTitle("Events")
  41 |     .toolbarBackground(.hidden, for: .navigationBar)
  42 |     .toolbarColorScheme(.dark, for: .navigationBar)
  43 |     .toolbar {
  44 |         ToolbarItem(placement: .topBarTrailing) {
  45 |             Button("Add Event") { showAddEvent = true }
  46 |         }
  47 |     }
  48 |     .sheet(isPresented: $showAddEvent) {
  49 |         AddEventSheet()
  50 |     }
  51 | }
  52 |     }
  53 | 
  54 |     private func deleteEvents(at offsets: IndexSet) {
  55 |         for index in offsets { context.delete(events[index]) }
  56 |         try? context.save()
  57 |     }
  58 | }
  59 | 
  60 | // MARK: - Event Detail
  61 | 
  62 | private struct EventDetailView: View {
  63 |     @Environment(\.modelContext) private var context
  64 | 
  65 |     let event: Event
  66 | 
  67 |     @Query(sort: \GameTemplate.name)
  68 |     private var templates: [GameTemplate]
  69 | 
  70 |     @State private var showAddGame = false
  71 |     @State private var showPlayers = false
  72 |     @State private var showResetConfirm = false
  73 | 
  74 |     @State private var message: String?
  75 |     @State private var showMessage = false
  76 |     
  77 |     // Filter and sort state
  78 |     @State private var filterTeamSize: Int? = nil
  79 |     @State private var filterTeamCount: Int? = nil
  80 |     @State private var sortOption: SortOption = .orderIndex
  81 |     @State private var statusFilter: StatusFilter = .all
  82 |     
  83 |     enum SortOption: String, CaseIterable {
  84 |         case orderIndex = "Order"
  85 |         case alphabetical = "A-Z"
  86 |         case reverseAlphabetical = "Z-A"
  87 |         case status = "Status"
  88 |     }
  89 |     
  90 |     enum StatusFilter: String, CaseIterable {
  91 |         case all = "All"
  92 |         case notStarted = "Not Started"
  93 |         case inProgress = "In Progress"
  94 |         case completed = "Completed"
  95 |     }
  96 | 
  97 |     var body: some View {
  98 |         List {
  99 |             // Compact stats section
 100 |             Section {
 101 |                 HStack {
 102 |                     Label("\(event.participantIds.count)", systemImage: "person.2")
 103 |                     Spacer()
 104 |                     Label("\(completedGamesCount)/\(event.eventGames.count)", systemImage: "gamecontroller")
 105 |                     Spacer()
 106 |                     Label(event.statusRaw.capitalized, systemImage: statusIcon)
 107 |                         .foregroundStyle(statusColor)
 108 |                 }
 109 |                 .font(.subheadline)
 110 |             }
 111 | 
 112 |             Section {
 113 |                 NavigationLink("Run Event") {
 114 |                     RunGameView(event: event)
 115 |                 }
 116 |                 .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty)
 117 |             } header: {
 118 |                 Text("Host")
 119 |             }
 120 | 
 121 |             Section {
 122 |                 // Filters
 123 |                 HStack {
 124 |                     Picker("Team Size", selection: $filterTeamSize) {
 125 |                         Text("Any").tag(nil as Int?)
 126 |                         ForEach(availableTeamSizes, id: \.self) { size in
 127 |                             Text("\(size)").tag(size as Int?)
 128 |                         }
 129 |                     }
 130 |                     .pickerStyle(.menu)
 131 |                     
 132 |                     Picker("Teams", selection: $filterTeamCount) {
 133 |                         Text("Any").tag(nil as Int?)
 134 |                         ForEach(availableTeamCounts, id: \.self) { count in
 135 |                             Text("\(count)").tag(count as Int?)
 136 |                         }
 137 |                     }
 138 |                     .pickerStyle(.menu)
 139 |                 }
 140 |                 
 141 |                 // Sort and Status Filter
 142 |                 HStack {
 143 |                     Picker("Sort", selection: $sortOption) {
 144 |                         ForEach(SortOption.allCases, id: \.self) { option in
 145 |                             Text(option.rawValue).tag(option)
 146 |                         }
 147 |                     }
 148 |                     .pickerStyle(.menu)
 149 |                     
 150 |                     Picker("Status", selection: $statusFilter) {
 151 |                         ForEach(StatusFilter.allCases, id: \.self) { filter in
 152 |                             Text(filter.rawValue).tag(filter)
 153 |                         }
 154 |                     }
 155 |                     .pickerStyle(.menu)
 156 |                 }
 157 |             } header: {
 158 |                 Text("Games (\(filteredAndSortedGames.count))")
 159 |             }
 160 |             
 161 |             // Games list
 162 |             Section {
 163 |                 ForEach(filteredAndSortedGames) { eg in
 164 |                     gameRow(for: eg)
 165 |                 }
 166 |             }
 167 |         }
 168 |         .navigationTitle(event.name)
 169 |         .navigationBarTitleDisplayMode(.large)
 170 |         .toolbar {
 171 |             ToolbarItem(placement: .topBarLeading) {
 172 |                 lifecycleButton()
 173 |             }
 174 |             ToolbarItemGroup(placement: .topBarTrailing) {
 175 |                 if event.status != .active {
 176 |                     Button("Reset") {
 177 |                         showResetConfirm = true
 178 |                     }
 179 |                 }
 180 |                 Button("Players") { showPlayers = true }
 181 |                 Button("Add Games") { showAddGame = true }
 182 |             }
 183 |         }
 184 |         .sheet(isPresented: $showAddGame) {
 185 |             AddGameToEventSheet(event: event)
 186 |         }
 187 |         .sheet(isPresented: $showPlayers) {
 188 |             SelectEventPlayersSheet(event: event)
 189 |         }
 190 |         .alert("Message", isPresented: $showMessage) {
 191 |             Button("OK", role: .cancel) { }
 192 |         } message: {
 193 |             Text(message ?? "Unknown error")
 194 |         }
 195 |         .confirmationDialog("Reset Event", isPresented: $showResetConfirm, titleVisibility: .visible) {
 196 |             Button("Reset Event", role: .destructive) {
 197 |                 do {
 198 |                     try EventEngine(context: context).resetEvent(event)
 199 |                 } catch {
 200 |                     show(error)
 201 |                 }
 202 |             }
 203 |             Button("Cancel", role: .cancel) { }
 204 |         } message: {
 205 |             Text("This will reset all games to 'not started', delete all rounds and statistics. Participants will be kept.")
 206 |         }
 207 |     }
 208 |     
 209 |     // MARK: - Computed Properties
 210 |     
 211 |     private var completedGamesCount: Int {
 212 |         event.eventGames.filter { $0.status == .completed }.count
 213 |     }
 214 |     
 215 |     private var statusIcon: String {
 216 |         switch event.status {
 217 |         case .available: return "circle"
 218 |         case .active: return "play.circle.fill"
 219 |         case .paused: return "pause.circle.fill"
 220 |         case .completed: return "checkmark.circle.fill"
 221 |         }
 222 |     }
 223 |     
 224 |     private var statusColor: Color {
 225 |         switch event.status {
 226 |         case .available: return .secondary
 227 |         case .active: return .green
 228 |         case .paused: return .orange
 229 |         case .completed: return .blue
 230 |         }
 231 |     }
 232 |     
 233 |     private var availableTeamSizes: [Int] {
 234 |         let sizes = Set(event.eventGames.compactMap { eg -> Int? in
 235 |             let template = templates.first(where: { $0.id == eg.gameTemplateId })
 236 |             return eg.overridePlayersPerTeam ?? template?.defaultPlayersPerTeam
 237 |         })
 238 |         return sizes.sorted()
 239 |     }
 240 |     
 241 |     private var availableTeamCounts: [Int] {
 242 |         let counts = Set(event.eventGames.compactMap { eg -> Int? in
 243 |             let template = templates.first(where: { $0.id == eg.gameTemplateId })
 244 |             return eg.overrideTeamCount ?? template?.defaultTeamCount
 245 |         })
 246 |         return counts.sorted()
 247 |     }
 248 |     
 249 |     private var filteredAndSortedGames: [EventGame] {
 250 |         var games = event.eventGames
 251 |         
 252 |         // Apply status filter
 253 |         switch statusFilter {
 254 |         case .all:
 255 |             break
 256 |         case .notStarted:
 257 |             games = games.filter { $0.status == .notStarted }
 258 |         case .inProgress:
 259 |             games = games.filter { $0.status == .inProgress }
 260 |         case .completed:
 261 |             games = games.filter { $0.status == .completed }
 262 |         }
 263 |         
 264 |         // Apply team size filter
 265 |         if let filterTeamSize {
 266 |             games = games.filter { eg in
 267 |                 let template = templates.first(where: { $0.id == eg.gameTemplateId })
 268 |                 let size = eg.overridePlayersPerTeam ?? template?.defaultPlayersPerTeam ?? 0
 269 |                 return size == filterTeamSize
 270 |             }
 271 |         }
 272 |         
 273 |         // Apply team count filter
 274 |         if let filterTeamCount {
 275 |             games = games.filter { eg in
 276 |                 let template = templates.first(where: { $0.id == eg.gameTemplateId })
 277 |                 let count = eg.overrideTeamCount ?? template?.defaultTeamCount ?? 0
 278 |                 return count == filterTeamCount
 279 |             }
 280 |         }
 281 |         
 282 |         // Apply sort
 283 |         switch sortOption {
 284 |         case .orderIndex:
 285 |             games.sort { $0.orderIndex < $1.orderIndex }
 286 |         case .alphabetical:
 287 |             games.sort { game1, game2 in
 288 |                 let name1 = templates.first(where: { $0.id == game1.gameTemplateId })?.name ?? ""
 289 |                 let name2 = templates.first(where: { $0.id == game2.gameTemplateId })?.name ?? ""
 290 |                 return name1.localizedCaseInsensitiveCompare(name2) == .orderedAscending
 291 |             }
 292 |         case .reverseAlphabetical:
 293 |             games.sort { game1, game2 in
 294 |                 let name1 = templates.first(where: { $0.id == game1.gameTemplateId })?.name ?? ""
 295 |                 let name2 = templates.first(where: { $0.id == game2.gameTemplateId })?.name ?? ""
 296 |                 return name1.localizedCaseInsensitiveCompare(name2) == .orderedDescending
 297 |             }
 298 |         case .status:
 299 |             games.sort { game1, game2 in
 300 |                 if game1.status != game2.status {
 301 |                     return game1.statusRaw < game2.statusRaw
 302 |                 }
 303 |                 return game1.orderIndex < game2.orderIndex
 304 |             }
 305 |         }
 306 |         
 307 |         return games
 308 |     }
 309 |     
 310 |     // MARK: - Game Row
 311 |     
 312 |     private func gameRow(for eg: EventGame) -> some View {
 313 |         let template = templates.first(where: { $0.id == eg.gameTemplateId })
 314 |         let name = template?.name ?? "Unknown Game"
 315 |         let teamCount = eg.overrideTeamCount ?? template?.defaultTeamCount ?? 2
 316 |         let playersPerTeam = eg.overridePlayersPerTeam ?? template?.defaultPlayersPerTeam ?? 2
 317 |         
 318 |         return HStack {
 319 |             VStack(alignment: .leading, spacing: 4) {
 320 |                 Text(name)
 321 |                     .font(.body)
 322 |                 
 323 |                 Text("\(teamCount) teams × \(playersPerTeam) players")
 324 |                     .font(.caption)
 325 |                     .foregroundStyle(.secondary)
 326 |             }
 327 |             
 328 |             Spacer()
 329 |             
 330 |             Text(eg.statusRaw.capitalized)
 331 |                 .font(.caption)
 332 |                 .foregroundStyle(gameStatusColor(eg.status))
 333 |         }
 334 |     }
 335 |     
 336 |     private func gameStatusColor(_ status: GameStatus) -> Color {
 337 |         switch status {
 338 |         case .notStarted: return .secondary
 339 |         case .inProgress: return .green
 340 |         case .completed: return .blue
 341 |         }
 342 |     }
 343 | 
 344 |     @ViewBuilder
 345 |     private func lifecycleButton() -> some View {
 346 |         let engine = EventEngine(context: context)
 347 | 
 348 |         switch event.status {
 349 |         case .available:
 350 |             Button("Start") {
 351 |                 do { try engine.startEvent(event) }
 352 |                 catch { show(error) }
 353 |             }
 354 |             .disabled(event.eventGames.isEmpty || event.participantIds.isEmpty)
 355 | 
 356 |         case .active:
 357 |             Button("Pause") {
 358 |                 do { try engine.pauseEvent(event) }
 359 |                 catch { show(error) }
 360 |             }
 361 | 
 362 |         case .paused:
 363 |             Button("Resume") {
 364 |                 do { try engine.resumeEvent(event) }
 365 |                 catch { show(error) }
 366 |             }
 367 | 
 368 |         case .completed:
 369 |             EmptyView()
 370 |         }
 371 |     }
 372 | 
 373 |     private func show(_ error: Error) {
 374 |         message = error.localizedDescription
 375 |         showMessage = true
 376 |     }
 377 | }
 378 | 
 379 | // MARK: - Event Players Sheet
 380 | 
 381 | private struct SelectEventPlayersSheet: View {
 382 |     @Environment(\.dismiss) private var dismiss
 383 |     @Environment(\.modelContext) private var context
 384 | 
 385 |     let event: Event
 386 | 
 387 |     @Query(sort: \Person.displayName)
 388 |     private var people: [Person]
 389 | 
 390 |     @State private var selectedIds: Set<UUID> = []
 391 |     @State private var errorMessage: String?
 392 |     @State private var showError = false
 393 | 
 394 |     var body: some View {
 395 |         NavigationStack {
 396 |             List(selection: $selectedIds) {
 397 |                 ForEach(activePeople) { person in
 398 |                     Text(person.displayName).tag(person.id)
 399 |                 }
 400 |             }
 401 |             .environment(\.editMode, .constant(.active))
 402 |             .navigationTitle("Select Players")
 403 |             .toolbar {
 404 |                 ToolbarItem(placement: .topBarLeading) { Button("Cancel") { dismiss() } }
 405 |                 ToolbarItem(placement: .topBarTrailing) {
 406 |                     Button("Save (\(selectedIds.count))") { save() }
 407 |                         .disabled(selectedIds.isEmpty)
 408 |                 }
 409 |                 ToolbarItem(placement: .bottomBar) {
 410 |                     HStack {
 411 |                         Button("Select All") { selectedIds = Set(activePeople.map { $0.id }) }
 412 |                         Button("Select None") { selectedIds.removeAll() }
 413 |                     }
 414 |                 }
 415 |             }
 416 |             .onAppear { selectedIds = Set(event.participantIds) }
 417 |             .alert("Error", isPresented: $showError) {
 418 |                 Button("OK", role: .cancel) { }
 419 |             } message: {
 420 |                 Text(errorMessage ?? "Unknown error")
 421 |             }
 422 |         }
 423 |     }
 424 | 
 425 |     private var activePeople: [Person] {
 426 |         people.filter { $0.isActive }
 427 |     }
 428 | 
 429 |     private func save() {
 430 |         do {
 431 |             try EventEngine(context: context).setParticipants(for: event, participantIds: Array(selectedIds))
 432 |             dismiss()
 433 |         } catch {
 434 |             errorMessage = error.localizedDescription
 435 |             showError = true
 436 |         }
 437 |     }
 438 | }
 439 | 
 440 | // MARK: - Add Event
 441 | 
 442 | private struct AddEventSheet: View {
 443 |     @Environment(\.dismiss) private var dismiss
 444 |     @Environment(\.modelContext) private var context
 445 |     @State private var name = ""
 446 | 
 447 |     var body: some View {
 448 |         NavigationStack {
 449 |             Form {
 450 |                 TextField("Event Name", text: $name)
 451 |             }
 452 |             .navigationTitle("New Event")
 453 |             .toolbar {
 454 |                 ToolbarItem(placement: .topBarLeading) { Button("Cancel") { dismiss() } }
 455 |                 ToolbarItem(placement: .topBarTrailing) {
 456 |                     Button("Save") { save() }
 457 |                         .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
 458 |                 }
 459 |             }
 460 |         }
 461 |     }
 462 | 
 463 |     private func save() {
 464 |         let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
 465 |         guard !trimmed.isEmpty else { return }
 466 |         context.insert(Event(name: trimmed))
 467 |         try? context.save()
 468 |         dismiss()
 469 |     }
 470 | }
 471 | 
 472 | // MARK: - Add Games
 473 | 
 474 | private struct AddGameToEventSheet: View {
 475 |     @Environment(\.dismiss) private var dismiss
 476 |     @Environment(\.modelContext) private var context
 477 | 
 478 |     let event: Event
 479 | 
 480 |     @Query(sort: \GameTemplate.name)
 481 |     private var templates: [GameTemplate]
 482 | 
 483 |     @State private var selectedIds: Set<UUID> = []
 484 |     @State private var showCSVImporter = false
 485 |     @State private var showCreateTemplate = false
 486 | 
 487 |     @State private var alertTitle = "Message"
 488 |     @State private var alertMessage: String?
 489 |     @State private var showAlert = false
 490 | 
 491 |     @State private var pendingCSVData: Data?
 492 |     @State private var pendingCSVFilename: String?
 493 |     @State private var showCSVPreview = false
 494 | 
 495 |     var body: some View {
 496 |         NavigationStack {
 497 |             List(selection: $selectedIds) {
 498 |                 Section("Select games to add") {
 499 |                     ForEach(templates) { t in
 500 |                         HStack {
 501 |                             Text(t.name)
 502 |                             Spacer()
 503 |                             if alreadyInEvent(t) {
 504 |                                 Text("Added")
 505 |                                     .font(.footnote)
 506 |                                     .foregroundStyle(.secondary)
 507 |                             }
 508 |                         }
 509 |                         .tag(t.id)
 510 |                         .contentShape(Rectangle())
 511 |                     }
 512 |                 }
 513 |             }
 514 |             .environment(\.editMode, .constant(.active))
 515 |             .navigationTitle("Add Games")
 516 |             .toolbar {
 517 |                 ToolbarItem(placement: .topBarLeading) {
 518 |                     Button("Cancel") { dismiss() }
 519 |                 }
 520 | 
 521 |                 ToolbarItem(placement: .topBarTrailing) {
 522 |                     Button("Add (\(selectedAddableCount))") { addSelected() }
 523 |                         .disabled(selectedAddableCount == 0)
 524 |                 }
 525 | 
 526 |                 ToolbarItem(placement: .bottomBar) {
 527 |                     HStack {
 528 |                         Button("Select All") { selectedIds = Set(templates.map { $0.id }) }
 529 |                             .disabled(templates.isEmpty)
 530 | 
 531 |                         Button("None") { selectedIds.removeAll() }
 532 |                             .disabled(selectedIds.isEmpty)
 533 | 
 534 |                         Spacer()
 535 | 
 536 |                         Button("Import CSV") { showCSVImporter = true }
 537 |                         Button("New Template") { showCreateTemplate = true }
 538 |                     }
 539 |                 }
 540 |             }
 541 |             .fileImporter(
 542 |                 isPresented: $showCSVImporter,
 543 |                 allowedContentTypes: [UTType.commaSeparatedText],
 544 |                 allowsMultipleSelection: false
 545 |             ) { result in
 546 |                 do {
 547 |                     let urls = try result.get()
 548 |                     guard let url = urls.first else { return }
 549 | 
 550 |                     let didStart = url.startAccessingSecurityScopedResource()
 551 |                     defer { if didStart { url.stopAccessingSecurityScopedResource() } }
 552 | 
 553 |                     let data = try Data(contentsOf: url)
 554 | 
 555 |                     pendingCSVData = data
 556 |                     pendingCSVFilename = url.lastPathComponent
 557 |                     showCSVPreview = true
 558 | 
 559 |                 } catch {
 560 |                     alertTitle = "Import failed"
 561 |                     alertMessage = error.localizedDescription
 562 |                     showAlert = true
 563 |                 }
 564 |             }
 565 |             .sheet(isPresented: $showCSVPreview) {
 566 |                 if let data = pendingCSVData {
 567 |                     CSVImportPreviewSheet(csvData: data, filename: pendingCSVFilename)
 568 |                 } else {
 569 |                     Text("No CSV loaded.")
 570 |                         .padding()
 571 |                 }
 572 |             }
 573 |             .sheet(isPresented: $showCreateTemplate) {
 574 |                 CreateGameTemplateSheet { newTemplate in
 575 |                     selectedIds.insert(newTemplate.id)
 576 |                 }
 577 |             }
 578 |             .alert(alertTitle, isPresented: $showAlert) {
 579 |                 Button("OK", role: .cancel) { }
 580 |             } message: {
 581 |                 Text(alertMessage ?? "Unknown error")
 582 |             }
 583 |         }
 584 |     }
 585 | 
 586 |     private func alreadyInEvent(_ template: GameTemplate) -> Bool {
 587 |         event.eventGames.contains(where: { $0.gameTemplateId == template.id })
 588 |     }
 589 | 
 590 |     private var selectedAddableCount: Int {
 591 |         let existing = Set(event.eventGames.map { $0.gameTemplateId })
 592 |         return selectedIds.filter { !existing.contains($0) }.count
 593 |     }
 594 | 
 595 |     private func addSelected() {
 596 |         let existing = Set(event.eventGames.map { $0.gameTemplateId })
 597 |         var nextOrder = (event.eventGames.map(\.orderIndex).max() ?? -1) + 1
 598 | 
 599 |         for tid in selectedIds {
 600 |             guard !existing.contains(tid) else { continue }
 601 |             let eg = EventGame(event: event, gameTemplateId: tid, orderIndex: nextOrder, status: .notStarted)
 602 |             nextOrder += 1
 603 |             context.insert(eg)
 604 |             event.eventGames.append(eg)
 605 |         }
 606 | 
 607 |         do {
 608 |             try context.save()
 609 |             dismiss()
 610 |         } catch {
 611 |             alertTitle = "Add failed"
 612 |             alertMessage = error.localizedDescription
 613 |             showAlert = true
 614 |         }
 615 |     }
 616 | }
 617 | 
 618 | #Preview {
 619 |     EventsListView()
 620 |         .modelContainer(for: [Event.self, Person.self, GameTemplate.self])
 621 | }


END FILE: ./Christmas Games/EventsListView.swift


